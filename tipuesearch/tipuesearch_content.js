var tipuesearch = {"pages":[{"title":" FRTС project ","text":"FRTС project Код FRTC Тут что-то про него надо написать This is a project which I wrote. This file will provide the documents. I'm writing the body of the text here. It contains an overall description of the project. It might explain how to go about installing/compiling it. It might provide a change-log for the code. FRTC Maybe it will talk about the history and/or motivation for this software. Note You can include any notes (or bugs, warnings, or todos) like so. Bug You can have multi-paragraph versions of these too! That means you can include ordered lists\nunordered lists\nimages\netc.\nIsn't that cool? Bug Hey I'm doing it again... This ones ends mid... ...paragraph. You can have as many paragraphs as you like here and can use headlines, links, images, etc. Basically, you can use anything in Markdown and Markdown-Extra. Furthermore, you can insert LaTeX into your documentation. So, for example, you can provide inline math using like or math on its own line like or You can even use LaTeX environments! So you can get numbered equations like this: So let your imagination run wild. As you can tell, I'm more or less just filling in space now. This will be the last sentence Developer Info Popov's Lab","tags":"home","loc":"index.html"},{"title":"DrivenCurrent – FRTС project ","text":"type, public :: DrivenCurrent Contents Variables cu cu0 c c0 outj ohj grid_size Constructor DrivenCurrent Type-Bound Procedures evaluate Components Type Visibility Attributes Name Initial real(kind=wp), public :: cu ??  может лучше cuj real(kind=wp), public :: cu0 ??              cujoh real(kind=wp), public :: c ?? real(kind=wp), public :: c0 ?? real(kind=wp), public, dimension(:), allocatable :: outj outj(i)  = LH driven current density, MA/m&#94;2 real(kind=wp), public, dimension(:), allocatable :: ohj integer, public :: grid_size Constructor public        interface DrivenCurrent public  function DrivenCurrent_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( DrivenCurrent ) Type-Bound Procedures procedure, public :: evaluate => DrivenCurrent_evaluate public  subroutine DrivenCurrent_evaluate (this, ROC) Arguments Type Intent Optional Attributes Name class( DrivenCurrent ), intent(inout) :: this real(kind=wp), intent(in) :: ROC","tags":"","loc":"type\\drivencurrent.html"},{"title":"DrivenCurrentResult – FRTС project ","text":"type, public :: DrivenCurrentResult Contents Variables cup cp cum cm cup0 cp0 cum0 cm0 Constructor DrivenCurrentResult Type-Bound Procedures print save Components Type Visibility Attributes Name Initial real(kind=wp), public :: cup real(kind=wp), public :: cp real(kind=wp), public :: cum real(kind=wp), public :: cm real(kind=wp), public :: cup0 real(kind=wp), public :: cp0 real(kind=wp), public :: cum0 real(kind=wp), public :: cm0 Constructor public        interface DrivenCurrentResult public  function DrivenCurrentResult_constructor (positive_dc, negative_dc) result(this) Arguments Type Intent Optional Attributes Name type( DrivenCurrent ), intent(in) :: positive_dc type( DrivenCurrent ), intent(in) :: negative_dc Return Value type( DrivenCurrentResult ) Type-Bound Procedures procedure, public :: print => driven_current_result_print public  subroutine driven_current_result_print (this, time) Arguments Type Intent Optional Attributes Name class( DrivenCurrentResult ), intent(in) :: this real(kind=wp), intent(in) :: time procedure, public :: save => driven_current_result_save public  subroutine driven_current_result_save (this, time) Arguments Type Intent Optional Attributes Name class( DrivenCurrentResult ), intent(in) :: this real(kind=wp), intent(in) :: time","tags":"","loc":"type\\drivencurrentresult.html"},{"title":"FokkerPlanck1D – FRTС project ","text":"type, public :: FokkerPlanck1D solver of FP eq Contents Variables enorm v_lim v f i0 alfa2 n h d1 d2 d3 Constructor FokkerPlanck1D Type-Bound Procedures print solve_time_step init_zero_diffusion init_diffusion Components Type Visibility Attributes Name Initial real(kind=dp), public :: enorm = 0 электрическое поле real(kind=dp), public :: v_lim = 0 верхняя граница скорости электронов real(kind=dp), public, allocatable :: v (:) сетка скоростей real(kind=dp), public, allocatable :: f (:) распределение integer, public :: i0 = 0 size of distribution grid real(kind=dp), public :: alfa2 = 0 поле со знаком integer, public :: n = 0 size of local grid real(kind=dp), public :: h = 0 step of local grid real(kind=dp), public, allocatable :: d1 (:) диффузия real(kind=dp), public, allocatable :: d2 (:) диффузия real(kind=dp), public, allocatable :: d3 (:) диффузия Constructor public        interface FokkerPlanck1D public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) конструктор для FokkerPlanck1D Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Type-Bound Procedures procedure, public :: print => FokkerPlanck1D_print public  subroutine FokkerPlanck1D_print (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(in) :: this procedure, public :: solve_time_step => FokkerPlanck1D_solve_time_step public  subroutine FokkerPlanck1D_solve_time_step (this, dt, nt) !!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in) :: dt integer, intent(in) :: nt procedure, public :: init_zero_diffusion => FokkerPlanck1D_init_zero_diffusion public  subroutine FokkerPlanck1D_init_zero_diffusion (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this procedure, public :: init_diffusion => FokkerPlanck1D_init_diffusion public  subroutine FokkerPlanck1D_init_diffusion (this, dif) инициализация диффузии для схемы савельева Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in), dimension(:) :: dif","tags":"","loc":"type\\fokkerplanck1d.html"},{"title":"SpectrumPoint – FRTС project ","text":"type, public :: SpectrumPoint Contents Variables Ntor Npol power Components Type Visibility Attributes Name Initial real(kind=wp), public :: Ntor Ntau=-Ntor real(kind=wp), public :: Npol Ntet=Npol real(kind=wp), public :: power power","tags":"","loc":"type\\spectrumpoint.html"},{"title":"Spectrum – FRTС project ","text":"type, public :: Spectrum Contents Variables size input_power power_ratio max_power sum_power direction data Constructor Spectrum Type-Bound Procedures get_positive_part get_negative_part calc_max_power Components Type Visibility Attributes Name Initial integer, public :: size size of spectrum real(kind=wp), public :: input_power power of spectrum real(kind=wp), public :: power_ratio доля входной мощности real(kind=wp), public :: max_power real(kind=wp), public :: sum_power суммарная power integer, public :: direction направление спектра   +1 или -1 или 0 - полный type( SpectrumPoint ), public, allocatable :: data (:) Constructor public        interface Spectrum public  function spectrum_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( Spectrum ) Type-Bound Procedures procedure, public :: get_positive_part => get_positive_part_method public  function get_positive_part_method (this) result(spectr) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value type( Spectrum ) procedure, public :: get_negative_part => get_negative_part_method public  function get_negative_part_method (this) result(spectr) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value type( Spectrum ) procedure, public :: calc_max_power => calc_max_power_method public  subroutine calc_max_power_method (this) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(inout) :: this","tags":"","loc":"type\\spectrum.html"},{"title":"FluxSurface – FRTС project ","text":"type, public :: FluxSurface класс магнитной поверхности Contents Variables index r vmax vt ipt vgrid vr_grid diffusion Components Type Visibility Attributes Name Initial integer, public :: index номер магнитной поверхности real(kind=wp), public :: r радиус real(kind=wp), public :: vmax vmax=cltn/vto real(kind=wp), public :: vt наверно тепловая скорость электронов????? vt=fvt(r) integer, public :: ipt размер vgrid real(kind=wp), public, allocatable :: vgrid (:) real(kind=wp), public, allocatable :: vr_grid (:) бываший vrj real(kind=wp), public, allocatable :: diffusion (:) бывший dijk(i,j,k) или dj(i)","tags":"","loc":"type\\fluxsurface.html"},{"title":"IterationResult – FRTС project ","text":"type, public :: IterationResult Contents Variables number spectr_direction P_launched P_landau P_coll P_alph alphas_power P_fast P_lost P_not_accounted P_landau_strong_absorption P_landau_weak_absorption P_turns efficiency avedens r0 eta_eff residual Type-Bound Procedures print save Components Type Visibility Attributes Name Initial integer, public :: number iteration number 'iteration=',iterat integer, public :: spectr_direction 'ispectr=',ispectr real(kind=wp), public :: P_launched P_launched, MW=',plaun real(kind=wp), public :: P_landau 'P_landau, MW=',ol real(kind=wp), public :: P_coll 'P_coll, MW=',oc real(kind=wp), public :: P_alph 'P_alph, MW=',oa real(kind=wp), public :: alphas_power 'Alphas power, MW=',fuspow real(kind=wp), public :: P_fast real(kind=wp), public :: P_lost real(kind=wp), public :: P_not_accounted real(kind=wp), public :: P_landau_strong_absorption real(kind=wp), public :: P_landau_weak_absorption real(kind=wp), public :: P_turns real(kind=wp), public :: efficiency real(kind=wp), public :: avedens real(kind=wp), public :: r0 real(kind=wp), public :: eta_eff real(kind=wp), public :: residual невязка 'nevyazka=', pchg Type-Bound Procedures procedure, public :: print => iteration_result_print public  subroutine iteration_result_print (this) Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this procedure, public :: save => iteration_result_save public  subroutine iteration_result_save (this, time_stamp) save Iteration Result to file Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this real(kind=wp), intent(in) :: time_stamp","tags":"","loc":"type\\iterationresult.html"},{"title":"Iderivs_func – FRTС project","text":"abstract interface public  subroutine Iderivs_func(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(inout) :: dydx (:)","tags":"","loc":"interface\\iderivs_func.html"},{"title":"drivencurrent95 – FRTС project","text":"subroutine drivencurrent95(outj, sigmaj, UPL, NRD, NA1, TIME, TAU, ROC, RTOR, GP2) Uses FokkerPlanck_module driven_current_module outj(i)  = LH driven current density, MA/m&#94;2\n   dndt(i)  = d&#94;2Jr1/dt&#94;2/E, MA/m&#94;2/sec&#94;2/(V/m), ~runaway d(el.density)/dt/E\n   djdt(i)  = dJr2/dt, time drivative of runaway current Jr2, MA/m&#94;2/sec\n   outjrun(i)  = LH driven runaway current density, MA/m&#94;2\n   outnerun(i) = runaway electron density/10&#94;19 m&#94;-3 variant\n!!       write( , ) i,outj(i) Arguments Type Intent Optional Attributes Name real(kind=8) :: outj (NRD) real(kind=8) :: sigmaj (NRD) double precision :: UPL (NRD) integer :: NRD integer :: NA1 double precision :: TIME double precision :: TAU double precision :: ROC double precision :: RTOR double precision :: GP2 Contents","tags":"","loc":"proc\\drivencurrent95.html"},{"title":"lhcurrent – FRTС project","text":"subroutine lhcurrent(driven_current, ispectr) Uses lock_module maxwell rt_parameters plasma driven_current_module implicit real 8 (a-h,o-z)\nwrite( , )\nwrite( , )'ccur',ccur,' curdir=',curdir,' nr=',nr\nwrite( ,*)'cu_out, MA=',cu_out,' cfull, A=',cfull\n     close(111) Arguments Type Intent Optional Attributes Name type( DrivenCurrent ), intent(inout) :: driven_current integer, intent(in) :: ispectr Contents Common Blocks plosh Common Blocks common /plosh/ Type Attributes Name Initial real :: zv1 (100,2) real :: zv2 (100,2)","tags":"","loc":"proc\\lhcurrent.html"},{"title":"polin – FRTС project","text":"public  function polin(k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\polin.html"},{"title":"polin1 – FRTС project","text":"public  function polin1(k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\polin1.html"},{"title":"polin2 – FRTС project","text":"public  function polin2(k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\polin2.html"},{"title":"fdf – FRTС project","text":"public  function fdf(x, c, n, df) result(p) вычисление значения полинома и его производной Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: c (n) integer, intent(in) :: n real(kind=wp), intent(out) :: df Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fdf.html"},{"title":"fdfddf – FRTС project","text":"public  function fdfddf(x, c, n, df, ddf) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: c (n) integer :: n real(kind=wp) :: df real(kind=wp) :: ddf Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fdfddf.html"},{"title":"approx – FRTС project","text":"public  subroutine approx(x, y, n, f, m, b) the data to be approximated. number of points in the input data. number of coefficients of decomposition\n       over base functions : found decomposition coefficients Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) real(kind=wp) :: y (n) integer :: n real :: f integer :: m real(kind=wp) :: b (*) Contents","tags":"","loc":"proc\\approx.html"},{"title":"ludcmp – FRTС project","text":"public  subroutine ludcmp(a, n, np, indx, d) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a (np,np) integer :: n integer :: np real(kind=wp) :: indx (n) real :: d Contents","tags":"","loc":"proc\\ludcmp.html"},{"title":"lubksb – FRTС project","text":"public  subroutine lubksb(a, n, np, indx, b) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a (np,np) integer :: n integer :: np real(kind=wp) :: indx (n) real(kind=wp) :: b (n) Contents","tags":"","loc":"proc\\lubksb.html"},{"title":"chang_cooper_solver – FRTС project","text":"public  subroutine chang_cooper_solver(alfa2, nt, h, dt, n, ybeg, yend, d1, d2, d3, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 integer, intent(in) :: nt real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) real(kind=wp), intent(inout) :: y (n+2) Contents","tags":"","loc":"proc\\chang_cooper_solver.html"},{"title":"chang_cooper_abcoef – FRTС project","text":"public  subroutine chang_cooper_abcoef(alfa2, a, b, c, f, y, dt, n, ybeg, yend, xx, h, df) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 real(kind=wp), intent(inout) :: a (n) real(kind=wp), intent(inout) :: b (n) real(kind=wp), intent(inout) :: c (n) real(kind=wp), intent(inout) :: f (n) real(kind=wp), intent(inout) :: y (n+2) real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: xx (n+1) real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: df (n+1) Contents","tags":"","loc":"proc\\chang_cooper_abcoef.html"},{"title":"chebev – FRTС project","text":"public  function chebev(a, b, c, m, x) Chebyshev evaluation: All arguments are input. \nc(1:m) is an array of Chebyshev coefficients, the first m elements \nof c output from chebft (which must have been called with\nthe same a and b). The Chebyshev polynomial evaluated\nand the result is returned as the function value. Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (m) integer :: m real(kind=wp) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\chebev.html"},{"title":"chebft1 – FRTС project","text":"public  subroutine chebft1(a, b, c, n, func) Chebyshev fit: Given a function func, lower and upper limits\nof the interval [a,b], and a maximum degree n, this routine \ncomputes the n coefficients c(k) such that func(x) approximately =\nSUMM_(k=1)&#94;(k=n)[c(k)*T(k-1)(y)]-c(1)/2, where y and x are related by\n(5.8.10). This routine is to be used with moderately large n \n(e.g., 30 or 50), the array of cs subsequently to be truncated\nat the smaller value m such that c(m+1) and subsequent elements \nare negligible. Parameters: Maximum expected value of n, and ð. Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (n) integer :: n real(kind=wp) :: func Contents","tags":"","loc":"proc\\chebft1.html"},{"title":"chder – FRTС project","text":"public  subroutine chder(a, b, c, cder, n) Given a,b,c(1:n), as output from routine chebft(), and given n, \nthe desired degree of approximation (length of c to be used), \nthis routine returns the array cder(1:n), the Chebyshev \ncoefficients of the derivative of the function whose coefficients \nare c(1:n). Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (n) real(kind=wp) :: cder (n) integer :: n Contents","tags":"","loc":"proc\\chder.html"},{"title":"show_constants – FRTС project","text":"public  subroutine show_constants() Arguments None Contents None","tags":"","loc":"proc\\show_constants.html"},{"title":"linf – FRTС project","text":"public  subroutine linf(x, y, t, fout, klo, khi) линейная аппроксимация\nTODO будет удобнее если переделать в функцию Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (*) real(kind=wp), intent(in) :: y (*) real(kind=wp), intent(in) :: t real(kind=wp), intent(out) :: fout integer, intent(in) :: klo integer, intent(in) :: khi Contents","tags":"","loc":"proc\\linf.html"},{"title":"lock – FRTС project","text":"public  subroutine lock(xa, n, x, klo, khi, ierr) что делает? Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xa (*) integer, intent(in) :: n real(kind=wp), intent(in) :: x integer, intent(inout) :: klo integer, intent(inout) :: khi integer, intent(inout) :: ierr Contents","tags":"","loc":"proc\\lock.html"},{"title":"lock2 – FRTС project","text":"public  subroutine lock2(xa, n, x, klo, khi, ierr) Uses constants что делает Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xa (*) integer, intent(in) :: n real(kind=wp), intent(in) :: x integer, intent(inout) :: klo integer, intent(inout) :: khi integer, intent(inout) :: ierr Contents","tags":"","loc":"proc\\lock2.html"},{"title":"currlhcd – FRTС project","text":"public  function currlhcd(v, f) result(curs) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: v (:) real(kind=wp), intent(in) :: f (:) Return Value real(kind=wp) Contents","tags":"","loc":"proc\\currlhcd.html"},{"title":"create_vt_grid – FRTС project","text":"public  function create_vt_grid(vclt) result(vt_grid) создание сетки тепловых скоростей Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt Return Value real(kind=wp), (i0) Contents","tags":"","loc":"proc\\create_vt_grid.html"},{"title":"funmaxwell – FRTС project","text":"public  function funmaxwell(v, dfunmaxwell) распределение Максвелла и его производная Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: dfunmaxwell Return Value real(kind=wp) Contents","tags":"","loc":"proc\\funmaxwell.html"},{"title":"fmaxw_classic – FRTС project","text":"public  function fmaxw_classic(v, alfa2, dfmaxw) распределение Максвелла с альфа-частицами и его производная Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fmaxw_classic.html"},{"title":"fmaxw_ext – FRTС project","text":"public  function fmaxw_ext(v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fmaxw_ext.html"},{"title":"fmaxw – FRTС project","text":"public  function fmaxw(v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fmaxw.html"},{"title":"psiq – FRTС project","text":"public  function psiq(v, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 Return Value real(kind=wp) Contents","tags":"","loc":"proc\\psiq.html"},{"title":"erfcc – FRTС project","text":"public  function erfcc(x) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\erfcc.html"},{"title":"init_vi – FRTС project","text":"public  subroutine init_vi(vclt, vi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(out) :: vi (i0) Contents","tags":"","loc":"proc\\init_vi.html"},{"title":"init_fmaxw_classic – FRTС project","text":"public  subroutine init_fmaxw_classic(vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(in) :: enorm real(kind=wp), intent(out) :: fi (i0) real(kind=wp), intent(out) :: dfi (i0) Contents","tags":"","loc":"proc\\init_fmaxw_classic.html"},{"title":"init_fmaxw_ext – FRTС project","text":"public  subroutine init_fmaxw_ext(vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(in) :: enorm real(kind=wp), intent(out) :: fi (i0) real(kind=wp), intent(out) :: dfi (i0) Contents","tags":"","loc":"proc\\init_fmaxw_ext.html"},{"title":"show_parameters – FRTС project","text":"public  subroutine show_parameters() Arguments None Contents None","tags":"","loc":"proc\\show_parameters.html"},{"title":"read_parameters – FRTС project","text":"public  subroutine read_parameters(file_name) !!!!!!!!!!!  read  physical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read parameters for alphas calculation !!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read grill parameters and input LH spectrum !!!!!!!!!!!!\n!!!!!!!!!!! checking initial parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name character :: file_name Contents","tags":"","loc":"proc\\read_parameters.html"},{"title":"rkqc – FRTС project","text":"public  subroutine rkqc(y, dydx, n, x, htry, eps, yscal, hdid, hnext, derivs) Uses constants Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: y (n) real(kind=wp), intent(inout) :: dydx (n) integer, intent(in) :: n real(kind=wp), intent(inout) :: x real(kind=wp), intent(in) :: htry real(kind=wp), intent(in) :: eps real(kind=wp), intent(in) :: yscal (n) real(kind=wp), intent(inout) :: hdid real(kind=wp), intent(inout) :: hnext procedure( Iderivs_func ) :: derivs Contents","tags":"","loc":"proc\\rkqc.html"},{"title":"rk4 – FRTС project","text":"public  subroutine rk4(y, dydx, n, x, h, yout, derivs) Arguments Type Intent Optional Attributes Name real :: y real :: dydx integer, intent(in) :: n real :: x real :: h real :: yout procedure( Iderivs_func ) :: derivs Contents","tags":"","loc":"proc\\rk4.html"},{"title":"runge_kutta_qs – FRTС project","text":"public  subroutine runge_kutta_qs(y, dydx, n, x, htry, eps, yscal, hdid, hnext, derivs) метод рунге-кутта Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: y (n) real(kind=wp), intent(inout) :: dydx (n) integer, intent(in) :: n real(kind=wp), intent(inout) :: x real(kind=wp), intent(in) :: htry real(kind=wp), intent(in) :: eps real(kind=wp), intent(in) :: yscal (n) real(kind=wp), intent(inout) :: hdid real(kind=wp), intent(inout) :: hnext procedure( Iderivs_func ) :: derivs Contents","tags":"","loc":"proc\\runge_kutta_qs.html"},{"title":"rkck – FRTС project","text":"public  subroutine rkck(y, dydx, n, x, h, yout, yerr, derivs) метод рунге-кутта, нужны подробности Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: y (n) real(kind=wp), intent(in) :: dydx (n) integer, intent(in) :: n real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out) :: yout (n) real(kind=wp), intent(out) :: yerr (n) procedure( Iderivs_func ) :: derivs Contents","tags":"","loc":"proc\\rkck.html"},{"title":"rplusk – FRTС project","text":"public  function rplusk(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) Contents","tags":"","loc":"proc\\rplusk.html"},{"title":"rplusk2 – FRTС project","text":"public  function rplusk2(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) Contents","tags":"","loc":"proc\\rplusk2.html"},{"title":"rmink – FRTС project","text":"public  function rmink(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) Contents","tags":"","loc":"proc\\rmink.html"},{"title":"rmink2 – FRTС project","text":"public  function rmink2(x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) Contents","tags":"","loc":"proc\\rmink2.html"},{"title":"rs – FRTС project","text":"public  function rs(x, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) Contents","tags":"","loc":"proc\\rs.html"},{"title":"qf – FRTС project","text":"public  function qf(x) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\qf.html"},{"title":"k2 – FRTС project","text":"public  function k2(x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif Return Value real(kind=wp) Contents","tags":"","loc":"proc\\k2.html"},{"title":"kinv – FRTС project","text":"public  function kinv(x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif Return Value real(kind=wp) Contents","tags":"","loc":"proc\\kinv.html"},{"title":"kinv2 – FRTС project","text":"public  function kinv2(x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif Return Value real(kind=wp) Contents","tags":"","loc":"proc\\kinv2.html"},{"title":"savelyev_solver – FRTС project","text":"public  subroutine savelyev_solver(alfa2, nt, h, dt, n, ybeg, yend, d1, d2, d3, y) разностная схема Савельева для уравнения Фоккера-Планка Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 integer, intent(in) :: nt real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) real(kind=wp), intent(inout) :: y (n) Contents","tags":"","loc":"proc\\savelyev_solver.html"},{"title":"savelyev_abccoef – FRTС project","text":"public  subroutine savelyev_abccoef(alfa2, a, b, c, f, y, dt, n, ybeg, yend, xx, h, d1, d2, d3) -- fill abc matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 real(kind=wp), intent(inout) :: a (n) real(kind=wp), intent(inout) :: b (n) real(kind=wp), intent(inout) :: c (n) real(kind=wp), intent(inout) :: f (n) real(kind=wp), intent(inout) :: y (n) real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: xx (n+1) real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) Contents","tags":"","loc":"proc\\savelyev_abccoef.html"},{"title":"tridag – FRTС project","text":"public  subroutine tridag(a, b, c, r, u, n) создает трехдиагональнйю матрицу Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (n) real(kind=wp), intent(in) :: b (n) real(kind=wp), intent(in) :: c (n) real(kind=wp), intent(in) :: r (n) real(kind=wp), intent(inout) :: u (n) integer, intent(in) :: n Contents","tags":"","loc":"proc\\tridag.html"},{"title":"splne – FRTС project","text":"public  subroutine splne(x, y, n, y2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) real(kind=wp) :: y (n) integer :: n real(kind=wp) :: y2 (n) Contents","tags":"","loc":"proc\\splne.html"},{"title":"splnt – FRTС project","text":"public  subroutine splnt(xa, ya, y2a, n, x, y, dy) Arguments Type Intent Optional Attributes Name real(kind=wp) :: xa (n) real(kind=wp) :: ya (n) real(kind=wp) :: y2a (n) integer :: n real(kind=wp) :: x real(kind=wp) :: y real(kind=wp) :: dy Contents","tags":"","loc":"proc\\splnt.html"},{"title":"dsplnt – FRTС project","text":"public  subroutine dsplnt(xa, ya, y2a, n, x, y, dy, ddy) Arguments Type Intent Optional Attributes Name real(kind=wp) :: xa (n) real(kind=wp) :: ya (n) real(kind=wp) :: y2a (n) integer :: n real(kind=wp) :: x real(kind=wp) :: y real(kind=wp) :: dy real(kind=wp) :: ddy Contents","tags":"","loc":"proc\\dsplnt.html"},{"title":"sys_time – FRTС project","text":"public  function sys_time() Arguments None Return Value real(kind=wp) Contents None","tags":"","loc":"proc\\sys_time.html"},{"title":"write_v_array – FRTС project","text":"public  subroutine write_v_array(v, a, time, array_name) сохраняет массивы расределения и скорости Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: v (:,:) real(kind=wp), intent(in) :: a (:,:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name Contents","tags":"","loc":"proc\\write_v_array.html"},{"title":"write_x_array – FRTС project","text":"public  subroutine write_x_array(x, arr, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:,:) real(kind=wp), intent(in) :: arr (:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name Contents","tags":"","loc":"proc\\write_x_array.html"},{"title":"write_matrix – FRTС project","text":"public  subroutine write_matrix(arr, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name Contents","tags":"","loc":"proc\\write_matrix.html"},{"title":"write_array – FRTС project","text":"public  subroutine write_array(arr, N, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (*) integer, intent(in) :: N character(len=*), intent(in) :: array_name Contents","tags":"","loc":"proc\\write_array.html"},{"title":"write_distribution – FRTС project","text":"public  subroutine write_distribution(arr, N, time) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (*) integer, intent(in) :: N real(kind=wp), intent(in) :: time Contents","tags":"","loc":"proc\\write_distribution.html"},{"title":"DrivenCurrent_constructor – FRTС project","text":"public  function DrivenCurrent_constructor(size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( DrivenCurrent ) Contents","tags":"","loc":"proc\\drivencurrent_constructor.html"},{"title":"DrivenCurrentResult_constructor – FRTС project","text":"public  function DrivenCurrentResult_constructor(positive_dc, negative_dc) result(this) Arguments Type Intent Optional Attributes Name type( DrivenCurrent ), intent(in) :: positive_dc type( DrivenCurrent ), intent(in) :: negative_dc Return Value type( DrivenCurrentResult ) Contents","tags":"","loc":"proc\\drivencurrentresult_constructor.html"},{"title":"DrivenCurrent_evaluate – FRTС project","text":"public  subroutine DrivenCurrent_evaluate(this, ROC) Uses constants Arguments Type Intent Optional Attributes Name class( DrivenCurrent ), intent(inout) :: this real(kind=wp), intent(in) :: ROC Contents","tags":"","loc":"proc\\drivencurrent_evaluate.html"},{"title":"driven_current_result_print – FRTС project","text":"public  subroutine driven_current_result_print(this, time) Arguments Type Intent Optional Attributes Name class( DrivenCurrentResult ), intent(in) :: this real(kind=wp), intent(in) :: time Contents","tags":"","loc":"proc\\driven_current_result_print.html"},{"title":"driven_current_result_save – FRTС project","text":"public  subroutine driven_current_result_save(this, time) Arguments Type Intent Optional Attributes Name class( DrivenCurrentResult ), intent(in) :: this real(kind=wp), intent(in) :: time Contents","tags":"","loc":"proc\\driven_current_result_save.html"},{"title":"DrivenCurrent – FRTС project","text":"public interface DrivenCurrent Contents Module Procedures DrivenCurrent_constructor Module Procedures public  function DrivenCurrent_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( DrivenCurrent )","tags":"","loc":"interface\\drivencurrent.html"},{"title":"DrivenCurrentResult – FRTС project","text":"public interface DrivenCurrentResult Contents Module Procedures DrivenCurrentResult_constructor Module Procedures public  function DrivenCurrentResult_constructor (positive_dc, negative_dc) result(this) Arguments Type Intent Optional Attributes Name type( DrivenCurrent ), intent(in) :: positive_dc type( DrivenCurrent ), intent(in) :: negative_dc Return Value type( DrivenCurrentResult )","tags":"","loc":"interface\\drivencurrentresult.html"},{"title":"FokkerPlanck1D_constructor – FRTС project","text":"public  function FokkerPlanck1D_constructor(e, v_lim, v, f) result(this) конструктор для FokkerPlanck1D Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Contents","tags":"","loc":"proc\\fokkerplanck1d_constructor.html"},{"title":"FokkerPlanck1D_print – FRTС project","text":"public  subroutine FokkerPlanck1D_print(this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(in) :: this Contents","tags":"","loc":"proc\\fokkerplanck1d_print.html"},{"title":"FokkerPlanck1D_init_zero_diffusion – FRTС project","text":"public  subroutine FokkerPlanck1D_init_zero_diffusion(this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this Contents","tags":"","loc":"proc\\fokkerplanck1d_init_zero_diffusion.html"},{"title":"FokkerPlanck1D_init_diffusion – FRTС project","text":"public  subroutine FokkerPlanck1D_init_diffusion(this, dif) Uses lock_module инициализация диффузии для схемы савельева Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in), dimension(:) :: dif Contents","tags":"","loc":"proc\\fokkerplanck1d_init_diffusion.html"},{"title":"FokkerPlanck1D_solve_time_step – FRTС project","text":"public  subroutine FokkerPlanck1D_solve_time_step(this, dt, nt) Uses lock_module !!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in) :: dt integer, intent(in) :: nt Contents","tags":"","loc":"proc\\fokkerplanck1d_solve_time_step.html"},{"title":"burying_procedure – FRTС project","text":"public  subroutine burying_procedure(v, f0, df0) процедура закапывания Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (:) real(kind=8), intent(inout) :: f0 (:) real(kind=8), intent(inout), optional :: df0 (:) Contents","tags":"","loc":"proc\\burying_procedure.html"},{"title":"FokkerPlanck1D – FRTС project","text":"public interface FokkerPlanck1D Contents Module Procedures FokkerPlanck1D_constructor Module Procedures public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) конструктор для FokkerPlanck1D Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D )","tags":"","loc":"interface\\fokkerplanck1d.html"},{"title":"fn – FRTС project","text":"public  function fn(x) Uses spline_module constants plasma  density,  cm&#94;-3 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fn.html"},{"title":"fvt – FRTС project","text":"public  function fvt(r) нет описания Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fvt.html"},{"title":"fn1 – FRTС project","text":"public  function fn1(x, fnp) Uses spline_module constants plasma density and its derivative Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: fnp Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fn1.html"},{"title":"fn2 – FRTС project","text":"public  function fn2(r, fnp, fnpp) Uses chebyshev constants plasma density and its first and second derivatives Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r real(kind=wp), intent(out) :: fnp real(kind=wp), intent(out) :: fnpp Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fn2.html"},{"title":"ft – FRTС project","text":"public  function ft(x) Uses spline_module constants electron temperature, erg\n     ft=y            ! kev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\ft.html"},{"title":"fti – FRTС project","text":"public  function fti(x) Uses spline_module constants ion temperature, kev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\fti.html"},{"title":"zefff – FRTС project","text":"public  function zefff(x) Uses spline_module constants z_effective profile Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Contents","tags":"","loc":"proc\\zefff.html"},{"title":"obeom – FRTС project","text":"public  function obeom(ptet, pa) Uses approximation constants Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value real(kind=wp) Contents","tags":"","loc":"proc\\obeom.html"},{"title":"ploshad – FRTС project","text":"public  function ploshad(ptet, pa) Uses approximation constants Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value real(kind=wp) Contents","tags":"","loc":"proc\\ploshad.html"},{"title":"gaussint – FRTС project","text":"public  function gaussint(f, a, b, r, eps) что-то про гаусс Arguments Type Intent Optional Attributes Name real(kind=wp) :: f real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: r real(kind=wp) :: eps Return Value real(kind=wp) Contents","tags":"","loc":"proc\\gaussint.html"},{"title":"init_plasma – FRTС project","text":"public  subroutine init_plasma(NA1, ABC, BTOR, RTOR, UPDWN, GP2, AMETR, RHO, SHIF, ELON, TRIA, MU, NE, TE, TI, ZEF, UPL) Uses spline_module rt_parameters constants chebyshev approximation variant\n amy=(btor/q) rho (drho/dr) is a function of \"minor radius\" r=rh(i).\n Poloidal magnetic field: B_pol=amy(r)*sqrt(g22/g), where g is\n determinant of 3D metric tensor and g22 is the (22) element of\n the tensor, normalized on ABC&#94;4 and ABC&#94;2, correspondingly. Polinomial approximation of the amy(r): !!!!!!!!!!!!! spline approximation of plasma profiles !!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name integer, intent(in) :: NA1 real(kind=wp), intent(in) :: ABC real(kind=wp), intent(in) :: BTOR real(kind=wp), intent(in) :: RTOR real(kind=wp), intent(in) :: UPDWN real(kind=wp), intent(in) :: GP2 real(kind=wp), dimension(*) :: AMETR real(kind=wp), dimension(*) :: RHO real(kind=wp), dimension(*) :: SHIF real(kind=wp), dimension(*) :: ELON real(kind=wp), dimension(*) :: TRIA real(kind=wp), dimension(*) :: MU real(kind=wp), dimension(*) :: NE real(kind=wp), dimension(*) :: TE real(kind=wp), dimension(*) :: TI real(kind=wp), dimension(*) :: ZEF real(kind=wp), dimension(*) :: UPL Contents","tags":"","loc":"proc\\init_plasma.html"},{"title":"init_parameters – FRTС project","text":"public  subroutine init_parameters() Uses rt_parameters approximation constants !!!!!!      ptkev=ft(zero)/0.16d-8  !Te in keV\n      ccurnr=pqe pqe 0.333d-9/pme Arguments None Contents None","tags":"","loc":"proc\\init_parameters.html"},{"title":"find_volums_and_surfaces – FRTС project","text":"public  subroutine find_volums_and_surfaces() Uses rt_parameters constants Arguments None Contents None","tags":"","loc":"proc\\find_volums_and_surfaces.html"},{"title":"calc_enorm – FRTС project","text":"public  subroutine calc_enorm() Uses spline_module lock_module maxwell rt_parameters constants fst(j)=pn xlogj c0 4/pi4/vt 3 Arguments None Contents None","tags":"","loc":"proc\\calc_enorm.html"},{"title":"init_maxwell – FRTС project","text":"public  subroutine init_maxwell() Uses spline_module rt_parameters maxwell constants Arguments None Contents None","tags":"","loc":"proc\\init_maxwell.html"},{"title":"spectrum_constructor – FRTС project","text":"public  function spectrum_constructor(size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( Spectrum ) Contents","tags":"","loc":"proc\\spectrum_constructor.html"},{"title":"get_positive_part_method – FRTС project","text":"public  function get_positive_part_method(this) result(spectr) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value type( Spectrum ) Contents","tags":"","loc":"proc\\get_positive_part_method.html"},{"title":"get_negative_part_method – FRTС project","text":"public  function get_negative_part_method(this) result(spectr) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value type( Spectrum ) Contents","tags":"","loc":"proc\\get_negative_part_method.html"},{"title":"read_spectrum – FRTС project","text":"public  function read_spectrum(file_name) result(spectr) Arguments Type Intent Optional Attributes Name character(len=*), value :: file_name Return Value type( Spectrum ) Contents","tags":"","loc":"proc\\read_spectrum.html"},{"title":"make_spline_approximation – FRTС project","text":"public  function make_spline_approximation(spectr) result(appx_spectr) Uses spline_module rt_parameters constants approximation of input LH spectrum Arguments Type Intent Optional Attributes Name type( Spectrum ), intent(in) :: spectr Return Value type( Spectrum ) Contents","tags":"","loc":"proc\\make_spline_approximation.html"},{"title":"calc_max_power_method – FRTС project","text":"public  subroutine calc_max_power_method(this) Uses rt_parameters constants Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(inout) :: this Contents","tags":"","loc":"proc\\calc_max_power_method.html"},{"title":"divide_spectrum – FRTС project","text":"public  subroutine divide_spectrum(spectr, pos_spectr, neg_spectr) деление спектра на две части Arguments Type Intent Optional Attributes Name type( Spectrum ), intent(in) :: spectr type( Spectrum ), intent(out) :: pos_spectr type( Spectrum ), intent(out) :: neg_spectr Contents","tags":"","loc":"proc\\divide_spectrum.html"},{"title":"Spectrum – FRTС project","text":"public interface Spectrum Contents Module Procedures spectrum_constructor Module Procedures public  function spectrum_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( Spectrum )","tags":"","loc":"interface\\spectrum.html"},{"title":"create_spectrum – FRTС project","text":"public  function create_spectrum() result(spectr) Uses rt_parameters spectrum_mod Arguments None Return Value type( Spectrum ) Contents None","tags":"","loc":"proc\\create_spectrum.html"},{"title":"read_positive_spectrum – FRTС project","text":"public  subroutine read_positive_spectrum(file_name, p_in) Arguments Type Intent Optional Attributes Name character :: file_name real(kind=wp) :: p_in Contents","tags":"","loc":"proc\\read_positive_spectrum.html"},{"title":"read_negative_spectrum – FRTС project","text":"public  subroutine read_negative_spectrum(file_name, p_in) Arguments Type Intent Optional Attributes Name character :: file_name real(kind=wp) :: p_in Contents","tags":"","loc":"proc\\read_negative_spectrum.html"},{"title":"spectrum_approximation – FRTС project","text":"public  subroutine spectrum_approximation(ispectr) Uses spline_module rt_parameters constants approximation of input LH spectrum Arguments Type Intent Optional Attributes Name integer, intent(in) :: ispectr Contents","tags":"","loc":"proc\\spectrum_approximation.html"},{"title":"copy_to_spectrum_1D – FRTС project","text":"public  subroutine copy_to_spectrum_1D(spectr) Uses spectrum_mod Arguments Type Intent Optional Attributes Name type( Spectrum ) :: spectr Contents","tags":"","loc":"proc\\copy_to_spectrum_1d.html"},{"title":"write_spectrum – FRTС project","text":"public  subroutine write_spectrum(ispectr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ispectr Contents","tags":"","loc":"proc\\write_spectrum.html"},{"title":"find_achieved_radial_points – FRTС project","text":"public  subroutine find_achieved_radial_points(nvpt) Uses rt_parameters find achieved radial points jbeg-jend Arguments Type Intent Optional Attributes Name integer, intent(in) :: nvpt Contents","tags":"","loc":"proc\\find_achieved_radial_points.html"},{"title":"dfind – FRTС project","text":"public  subroutine dfind(j, i, v, powpr, pil, pic, pia, df, decv, refr, vlf, vrt, ifast) Uses plasma rt_parameters constants pchgl=powpr*(1.d0-dexp(-2d0*pil))\n   pchgc=powpr*dexp(-2d0*pil)*dabs(-2d0*pic)\n   pchga=powpr*dexp(-2d0*pil)*dabs(-2d0*pia) !        adde=zze (dd/dens(j)) weight\n!        e2perp(i,j)=e2perp(i,j)+adde Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: i real(kind=wp), intent(in) :: v real(kind=wp), intent(in) :: powpr real(kind=wp), intent(in) :: pil real(kind=wp), intent(in) :: pic real(kind=wp), intent(in) :: pia real(kind=wp), intent(in) :: df real(kind=wp), intent(in) :: decv real(kind=wp), intent(in) :: refr real(kind=wp), intent(in) :: vlf real(kind=wp), intent(in) :: vrt integer, intent(in) :: ifast Contents","tags":"","loc":"proc\\dfind.html"},{"title":"zatukh – FRTС project","text":"public  function zatukh(psy, j, u, n) Uses constants Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: psy integer, intent(in) :: j real(kind=wp), intent(in) :: u (:,:) integer, intent(in) :: n Return Value real(kind=wp) Contents","tags":"","loc":"proc\\zatukh.html"},{"title":"disp2 – FRTС project","text":"public  subroutine disp2(pa, yn2, ptet, xnro, prt, prm) Uses plasma rt_parameters approximation constants pn=fn1(pa,fnr)\n  pn=fn2(pa,fnr,fnrr) !sav2008 old variant: !!!!!!!!!!!! new variant:\n        pdec1=-pdecv*dfdv Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: ptet real(kind=wp), intent(inout) :: xnro real(kind=wp), intent(inout) :: prt real(kind=wp), intent(inout) :: prm Contents","tags":"","loc":"proc\\disp2.html"},{"title":"disp4 – FRTС project","text":"public  subroutine disp4(pa, ptet, xnr, yn2) Uses plasma rt_parameters approximation constants pn=fn1(pa,fnr)\n  pn=fn2(pa,fnr,fnrr) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n      dl=bs 2-4d0 as bs Arguments Type Intent Optional Attributes Name real :: pa real :: ptet real :: xnr real :: yn2 Contents","tags":"","loc":"proc\\disp4.html"},{"title":"dhdomega – FRTС project","text":"public  subroutine dhdomega(rho, theta, yn1, yn2) w*dH/dw=wdhdw: Arguments Type Intent Optional Attributes Name real :: rho real :: theta real :: yn1 real :: yn2 Contents","tags":"","loc":"proc\\dhdomega.html"},{"title":"source_new – FRTС project","text":"public  subroutine source_new(r, out) Uses lock_module Arguments Type Intent Optional Attributes Name real :: r real :: out Contents","tags":"","loc":"proc\\source_new.html"},{"title":"extd4 – FRTС project","text":"public  subroutine extd4(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(inout) :: dydx (:) Contents","tags":"","loc":"proc\\extd4.html"},{"title":"fokkerplanck_compute – FRTС project","text":"public  subroutine fokkerplanck_compute(time, TAU) Uses writer_module maxwell rt_parameters Utils plasma FokkerPlanck1D_mod Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: time real(kind=wp), intent(in) :: TAU Contents","tags":"","loc":"proc\\fokkerplanck_compute.html"},{"title":"init_diffusion – FRTС project","text":"public  subroutine init_diffusion(h, n, vj, dj, d1, d2, d3) Uses lock_module Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: h integer, intent(in) :: n real(kind=wp), intent(in), dimension(:) :: vj real(kind=wp), intent(in), dimension(:) :: dj real(kind=wp), intent(out), dimension(:) :: d1 real(kind=wp), intent(out), dimension(:) :: d2 real(kind=wp), intent(out), dimension(:) :: d3 Contents","tags":"","loc":"proc\\init_diffusion.html"},{"title":"iteration_result_print – FRTС project","text":"public  subroutine iteration_result_print(this) Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this Contents","tags":"","loc":"proc\\iteration_result_print.html"},{"title":"iteration_result_save – FRTС project","text":"public  subroutine iteration_result_save(this, time_stamp) save Iteration Result to file Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this real(kind=wp), intent(in) :: time_stamp Contents","tags":"","loc":"proc\\iteration_result_save.html"},{"title":"init_iteration – FRTС project","text":"public  subroutine init_iteration() Uses rt_parameters plasma constants current Arguments None Contents None","tags":"","loc":"proc\\init_iteration.html"},{"title":"recalculate_f_for_a_new_mesh – FRTС project","text":"public  subroutine recalculate_f_for_a_new_mesh(ispectr) Uses lock_module maxwell rt_parameters current constants plasma recalculate f' for a new mesh\n!         if(vrj(i).gt.vvj(i0)) exit Arguments Type Intent Optional Attributes Name integer, intent(in) :: ispectr Contents","tags":"","loc":"proc\\recalculate_f_for_a_new_mesh.html"},{"title":"init_trajectory – FRTС project","text":"public  subroutine init_trajectory() Uses constants Arguments None Contents None","tags":"","loc":"proc\\init_trajectory.html"},{"title":"view – FRTС project","text":"public  subroutine view(tview, iview, nnz, ntet) Uses spectrum1D dispersion_module rt_parameters constants plasma approximation !writing trajectories into a file\n          pintld=-dland(i) (dflf+dfrt)/2d0\n          pdec1=-pdecv df Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: tview integer, intent(in) :: iview integer, intent(in) :: nnz integer, intent(in) :: ntet Contents Common Blocks vth a0ghp Common Blocks common /vth/ Type Attributes Name Initial real :: vthc (length) real :: poloidn (length) common /a0ghp/ Type Attributes Name Initial real :: vlf real :: vrt real :: dflf real :: dfrt","tags":"","loc":"proc\\view.html"},{"title":"traj – FRTС project","text":"public  subroutine traj(xm0, tet0, xbeg, nmax, nb1, nb2, nomth, nomnz, pabs) Uses dispersion_module rt_parameters runge_kutta_module constants plasma approximation Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xm0 real(kind=wp), intent(in) :: tet0 real(kind=wp), intent(inout) :: xbeg integer, intent(inout) :: nmax integer, intent(inout) :: nb1 integer, intent(inout) :: nb2 integer, intent(in) :: nomth integer, intent(in) :: nomnz real(kind=wp), intent(in) :: pabs Contents","tags":"","loc":"proc\\traj.html"},{"title":"driver4 – FRTС project","text":"public  subroutine driver4(ystart, x1, x2, rexi, hmin, derivs) Uses dispersion_module rt_parameters runge_kutta_module constants plasma var        if(dabs(dydx(3)).ne.zero) h=dabs(hmin1/dydx(3))/hdrob1\n    if(dabs(y(3)-rexi).gt.rrange.or.nstp.eq.maxstep4) then  ! exit !sav2008 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ystart (:) real(kind=wp), intent(inout) :: x1 real(kind=wp), intent(inout) :: x2 real(kind=wp), intent(in) :: rexi real(kind=wp), intent(in) :: hmin procedure( Iderivs_func ) :: derivs Contents Common Blocks dg Common Blocks common /dg/ Type Attributes Name Initial real(kind=wp) :: pintld4 real(kind=wp) :: pintcl4 real(kind=wp) :: pintal4","tags":"","loc":"proc\\driver4.html"},{"title":"rini – FRTС project","text":"public  function rini(xm, tet, xnr, point, hr, ifail) Uses rt_parameters dispersion_module constants spectrum_mod xm=yn dsqrt(g22)         !given yn=(N jpol) at Nfi=0\nyn3=yn*dsqrt(g33)       !if given Nfi at Nteta=0 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: xm real(kind=wp), intent(in) :: tet real(kind=wp), intent(inout) :: xnr type( SpectrumPoint ), intent(in) :: point real(kind=wp), intent(in) :: hr integer, intent(inout) :: ifail Return Value real(kind=wp) Contents","tags":"","loc":"proc\\rini.html"},{"title":"manager – FRTС project","text":"public  subroutine manager(iterat, iw0, ntet, spectr) Uses dispersion_module rt_parameters iterator_mod trajectory constants spectrum_mod plasma Arguments Type Intent Optional Attributes Name integer :: iterat integer :: iw0 integer :: ntet type( Spectrum ) :: spectr Contents","tags":"","loc":"proc\\manager.html"},{"title":"kind_module – FRTС project","text":"Uses iso_fortran_env Contents Variables wp Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64 double precision reals","tags":"","loc":"module\\kind_module.html"},{"title":"approximation – FRTС project","text":"polinomial approximation Uses kind_module Contents Functions polin polin1 polin2 fdf fdfddf Subroutines approx ludcmp lubksb Functions public  function polin (k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) public  function polin1 (k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) public  function polin2 (k, x) Arguments Type Intent Optional Attributes Name integer :: k real(kind=wp) :: x Return Value real(kind=wp) public  function fdf (x, c, n, df) result(p) вычисление значения полинома и его производной Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: c (n) integer, intent(in) :: n real(kind=wp), intent(out) :: df Return Value real(kind=wp) public  function fdfddf (x, c, n, df, ddf) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x real(kind=wp) :: c (n) integer :: n real(kind=wp) :: df real(kind=wp) :: ddf Return Value real(kind=wp) Subroutines public  subroutine approx (x, y, n, f, m, b) the data to be approximated. number of points in the input data. number of coefficients of decomposition\n       over base functions : found decomposition coefficients Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) real(kind=wp) :: y (n) integer :: n real :: f integer :: m real(kind=wp) :: b (*) public  subroutine ludcmp (a, n, np, indx, d) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a (np,np) integer :: n integer :: np real(kind=wp) :: indx (n) real :: d public  subroutine lubksb (a, n, np, indx, b) Arguments Type Intent Optional Attributes Name real(kind=wp) :: a (np,np) integer :: n integer :: np real(kind=wp) :: indx (n) real(kind=wp) :: b (n)","tags":"","loc":"module\\approximation.html"},{"title":"chang_cooper_module – FRTС project","text":"Uses kind_module Contents Subroutines chang_cooper_solver chang_cooper_abcoef Subroutines public  subroutine chang_cooper_solver (alfa2, nt, h, dt, n, ybeg, yend, d1, d2, d3, y) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 integer, intent(in) :: nt real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) real(kind=wp), intent(inout) :: y (n+2) public  subroutine chang_cooper_abcoef (alfa2, a, b, c, f, y, dt, n, ybeg, yend, xx, h, df) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 real(kind=wp), intent(inout) :: a (n) real(kind=wp), intent(inout) :: b (n) real(kind=wp), intent(inout) :: c (n) real(kind=wp), intent(inout) :: f (n) real(kind=wp), intent(inout) :: y (n+2) real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: xx (n+1) real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: df (n+1)","tags":"","loc":"module\\chang_cooper_module.html"},{"title":"chebyshev – FRTС project","text":"Chebyshev fit Uses kind_module Contents Functions chebev Subroutines chebft1 chder Functions public  function chebev (a, b, c, m, x) Chebyshev evaluation: All arguments are input. \nc(1:m) is an array of Chebyshev coefficients, the first m elements \nof c output from chebft (which must have been called with\nthe same a and b). The Chebyshev polynomial evaluated\nand the result is returned as the function value. Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (m) integer :: m real(kind=wp) :: x Return Value real(kind=wp) Subroutines public  subroutine chebft1 (a, b, c, n, func) Chebyshev fit: Given a function func, lower and upper limits\nof the interval [a,b], and a maximum degree n, this routine \ncomputes the n coefficients c(k) such that func(x) approximately =\nSUMM_(k=1)&#94;(k=n)[c(k)*T(k-1)(y)]-c(1)/2, where y and x are related by\n(5.8.10). This routine is to be used with moderately large n \n(e.g., 30 or 50), the array of cs subsequently to be truncated\nat the smaller value m such that c(m+1) and subsequent elements \nare negligible. Parameters: Maximum expected value of n, and ð. Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (n) integer :: n real(kind=wp) :: func public  subroutine chder (a, b, c, cder, n) Given a,b,c(1:n), as output from routine chebft(), and given n, \nthe desired degree of approximation (length of c to be used), \nthis routine returns the array cder(1:n), the Chebyshev \ncoefficients of the derivative of the function whose coefficients \nare c(1:n). Arguments Type Intent Optional Attributes Name real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: c (n) real(kind=wp) :: cder (n) integer :: n","tags":"","loc":"module\\chebyshev.html"},{"title":"constants – FRTС project","text":"модуль с математическими и физическими константами\nnt_001 тестовый комментарий Uses kind_module Contents Variables zero one two one_third tiny tin pi pi2 pi4 piq pisqrt pi2sqrt talfa zalfa xmalfa clt pme pme_e pqe xlog c0 c1 xsgs xwtt cnst1 cnst2 Subroutines show_constants Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: zero = 0.0_wp real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public, parameter :: two = 2.0_wp real(kind=wp), public, parameter :: one_third = 1.0_wp/3.0_wp real(kind=wp), public, parameter :: tiny = 1.e-100_wp real(kind=wp), public, parameter :: tin = 1e-7_wp real(kind=wp), public, parameter :: pi = acos(-one) число Пи = 3.1415.... real(kind=wp), public, parameter :: pi2 = 2.0_wp*pi real(kind=wp), public, parameter :: pi4 = 4.0_wp*pi real(kind=wp), public, parameter :: piq = sqrt(pi) real(kind=wp), public, parameter :: pisqrt = sqrt(pi) real(kind=wp), public, parameter :: pi2sqrt = sqrt(pi2) real(kind=wp), public, parameter :: talfa = 3.5_wp alpha particles' birth energy, MeV real(kind=wp), public, parameter :: zalfa = 2.0_wp alpha particles' electrical charge real(kind=wp), public, parameter :: xmalfa = 4.0_wp alpha particles' atomic mass real(kind=wp), public, parameter :: clt = 3.0e+10_wp скорость света real(kind=wp), public, parameter :: pme = 9.11e-28_wp real(kind=wp), public, parameter :: pme_e = 9.11e-28 real(kind=wp), public, parameter :: pqe = 4.803e-10_wp real(kind=wp), public, parameter :: xlog = 16.0_wp+dlog(16.0_wp) real(kind=wp), public, parameter :: c0 = sqrt(pi4*pqe**2/pme) real(kind=wp), public, parameter :: c1 = pqe/pme/clt real(kind=wp), public, parameter :: xsgs = 1e+13_wp real(kind=wp), public, parameter :: xwtt = 1e-7_wp real(kind=wp), public, parameter :: cnst1 = 0.2965924106e-6_wp cnst1=(m_e/m_p)**2, CGS real(kind=wp), public, parameter :: cnst2 = 0.359680922e-35_wp cnst2=(m_e/e)**2,  CGS Subroutines public  subroutine show_constants () Arguments None","tags":"","loc":"module\\constants.html"},{"title":"lock_module – FRTС project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses kind_module Contents Subroutines linf lock lock2 Subroutines public  subroutine linf (x, y, t, fout, klo, khi) линейная аппроксимация\nTODO будет удобнее если переделать в функцию Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (*) real(kind=wp), intent(in) :: y (*) real(kind=wp), intent(in) :: t real(kind=wp), intent(out) :: fout integer, intent(in) :: klo integer, intent(in) :: khi public  subroutine lock (xa, n, x, klo, khi, ierr) что делает? Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xa (*) integer, intent(in) :: n real(kind=wp), intent(in) :: x integer, intent(inout) :: klo integer, intent(inout) :: khi integer, intent(inout) :: ierr public  subroutine lock2 (xa, n, x, klo, khi, ierr) что делает Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xa (*) integer, intent(in) :: n real(kind=wp), intent(in) :: x integer, intent(inout) :: klo integer, intent(inout) :: khi integer, intent(inout) :: ierr","tags":"","loc":"module\\lock_module.html"},{"title":"maxwell – FRTС project","text":"Все что относится к распределению Максвелла Uses constants kind_module Contents Variables i0 v_grid vij fij0 fij dfij dij flag_d0 jindex kindex Functions currlhcd create_vt_grid funmaxwell fmaxw_classic fmaxw_ext fmaxw psiq erfcc Subroutines init_vi init_fmaxw_classic init_fmaxw_ext Variables Type Visibility Attributes Name Initial integer, public, parameter :: i0 = 1002 real(kind=wp), public :: v_grid (i0,100) сетка обычных скоростей real(kind=wp), public :: vij (i0,100) real(kind=wp), public :: fij0 (i0,100,2) real(kind=wp), public :: fij (i0,100,2) real(kind=wp), public :: dfij (i0,100,2) real(kind=wp), public :: dij (i0,100,2) logical, public :: flag_d0 бывший d0 integer, public :: jindex common/dddql/ d0,jindex,kindex integer, public :: kindex common/dddql/ d0,jindex,kindex Functions public  function currlhcd (v, f) result(curs) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: v (:) real(kind=wp), intent(in) :: f (:) Return Value real(kind=wp) public  function create_vt_grid (vclt) result(vt_grid) создание сетки тепловых скоростей Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt Return Value real(kind=wp), (i0) public  function funmaxwell (v, dfunmaxwell) распределение Максвелла и его производная Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: dfunmaxwell Return Value real(kind=wp) public  function fmaxw_classic (v, alfa2, dfmaxw) распределение Максвелла с альфа-частицами и его производная Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value real(kind=wp) public  function fmaxw_ext (v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value real(kind=wp) public  function fmaxw (v, alfa2, dfmaxw) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 real(kind=wp) :: dfmaxw Return Value real(kind=wp) public  function psiq (v, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: v real(kind=wp) :: alfa2 Return Value real(kind=wp) public  function erfcc (x) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x Return Value real(kind=wp) Subroutines public  subroutine init_vi (vclt, vi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(out) :: vi (i0) public  subroutine init_fmaxw_classic (vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(in) :: enorm real(kind=wp), intent(out) :: fi (i0) real(kind=wp), intent(out) :: dfi (i0) public  subroutine init_fmaxw_ext (vclt, enorm, fi, dfi) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vclt real(kind=wp), intent(in) :: enorm real(kind=wp), intent(out) :: fi (i0) real(kind=wp), intent(out) :: dfi (i0)","tags":"","loc":"module\\maxwell.html"},{"title":"rt_parameters – FRTС project","text":"Uses kind_module Contents Variables freq xmi1 zi1 xmi2 zi2 dni2 xmi3 zi3 dni3 itend0 energy factor dra kv nr hmin1 rrange eps hdrob cleft cright cdel rbord pchm pabs0 pgiter ni1 ni2 niterat nmaxm maxstep2 maxstep4 ipri iw ismth ismthalf ismthout inew itor i_pol zplus zminus ntet nnz spectrum_type Subroutines show_parameters read_parameters Variables Type Visibility Attributes Name Initial real(kind=wp), public :: freq Freq,     RF frequency, GHz real(kind=wp), public :: xmi1 Mi1/Mp,  relative mass of ions 1 real(kind=wp), public :: zi1 charge of ions 1 real(kind=wp), public :: xmi2 Mi2/Mp,  relative mass of ions 2 real(kind=wp), public :: zi2 charge of ions 2 real(kind=wp), public :: dni2 0.03   Ni2/Ni1, relative density of ions 2 real(kind=wp), public :: xmi3 Mi3/Mp,  relative mass of ions 3 real(kind=wp), public :: zi3 charge of ions 3 real(kind=wp), public :: dni3 Ni3/Ni1, relative density of ions 3 !!!!!!!!!!!  parameters for alphas calculations !!! integer, public :: itend0 itend0,   if = 0, no alphas real(kind=wp), public :: energy energy,   max. perp. energy of alphas (MeV) real(kind=wp), public :: factor factor,   factor in alpha source real(kind=wp), public :: dra dra,      relative alpha source broadening (dr/a) integer, public :: kv kv,       V_perp  greed number !!!!!!!!!!! numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer, public :: nr nr,  radial grid number  <= 505 real(kind=wp), public :: hmin1 hmin1, rel.(hr) min. step in the Fast comp. mode, <1.d0 real(kind=wp), public :: rrange rrange,   rel.(hr) size of a 'turning' point region, <1.d0 real(kind=wp), public :: eps eps,      accuracy real(kind=wp), public :: hdrob hdrob,    h4 correction, real(kind=wp), public :: cleft cleft,    left Vz plato border shift (<1) real(kind=wp), public :: cright cright,   right Vz plato border shift (>1) real(kind=wp), public :: cdel cdel,     (left part)/(Vz plato size) real(kind=wp), public :: rbord rbord,    relative radius of reflection, <1. real(kind=wp), public :: pchm pchm,     threshold between 'strong' and weak' absorption, <1. real(kind=wp), public :: pabs0 pabs,     part of remaining power interp. as absorption real(kind=wp), public :: pgiter pgiter,   relative accuracy to stop iterations integer, public :: ni1 ni1,      grid number in the left part of Vz plato integer, public :: ni2 ni2,      grid number in the right part of Vz plato integer, public :: niterat niterat,  maximal number of iterations integer, public :: nmaxm (4) nmaxm(1), permitted reflections at 0 iteration\nnmaxm(2), permitted reflections at 1 iteration\nnmaxm(3), permitted reflections at 2 iteration\nnmaxm(4), permitted reflections at 3 iteration integer, public :: maxstep2 maxstep2, maximal steps' number in Fast comp. mode integer, public :: maxstep4 maxstep4, maximal steps' number in Slow comp. mode !!!!!!!!!!!  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer, public :: ipri ipri, printing output monitoring: 0,1,2,3,4 integer, public :: iw iw, initial mode (slow=1, fast=-1) integer, public :: ismth ismth, if=0, no smoothing in Ne(rho),Te(rho),Ti(rho) integer, public :: ismthalf ismthalf,  if=0, no smoothing in D_alpha(vperp) integer, public :: ismthout ismthout,  if=0, no smoothing in output profiles integer, public :: inew inew=0 for usual tokamak&Ntor_grill; 1 or 2 for g' in ST&Npol_grill integer, public :: itor itor,      +-1, Btor direction in right coord{drho,dteta,dfi} integer, public :: i_pol ipol,      +-1, Bpol direction in right coord{drho,dteta,dfi} !!!!!!!!!!!  grill parameters and input LH spectrum !!!!!!!!!!!! real(kind=wp), public :: zplus Zplus,    upper grill corner in centimeters real(kind=wp), public :: zminus Zminus,   lower grill corner in centimeters integer, public :: ntet ntet,     theta grid number integer, public :: nnz nnz,      N_phi grid number integer, public :: spectrum_type spectrum type 1 - 1D, 2 = 2D, 3, scatter Subroutines public  subroutine show_parameters () Arguments None public  subroutine read_parameters (file_name) !!!!!!!!!!!  read  physical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read parameters for alphas calculation !!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!!!!!!  read grill parameters and input LH spectrum !!!!!!!!!!!!\n!!!!!!!!!!! checking initial parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name character :: file_name","tags":"","loc":"module\\rt_parameters.html"},{"title":"runge_kutta_module – FRTС project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses kind_module Contents Abstract Interfaces Iderivs_func Subroutines rkqc rk4 runge_kutta_qs rkck Abstract Interfaces abstract interface public  subroutine Iderivs_func(x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(inout) :: dydx (:) Subroutines public  subroutine rkqc (y, dydx, n, x, htry, eps, yscal, hdid, hnext, derivs) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: y (n) real(kind=wp), intent(inout) :: dydx (n) integer, intent(in) :: n real(kind=wp), intent(inout) :: x real(kind=wp), intent(in) :: htry real(kind=wp), intent(in) :: eps real(kind=wp), intent(in) :: yscal (n) real(kind=wp), intent(inout) :: hdid real(kind=wp), intent(inout) :: hnext procedure( Iderivs_func ) :: derivs public  subroutine rk4 (y, dydx, n, x, h, yout, derivs) Arguments Type Intent Optional Attributes Name real :: y real :: dydx integer, intent(in) :: n real :: x real :: h real :: yout procedure( Iderivs_func ) :: derivs public  subroutine runge_kutta_qs (y, dydx, n, x, htry, eps, yscal, hdid, hnext, derivs) метод рунге-кутта Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: y (n) real(kind=wp), intent(inout) :: dydx (n) integer, intent(in) :: n real(kind=wp), intent(inout) :: x real(kind=wp), intent(in) :: htry real(kind=wp), intent(in) :: eps real(kind=wp), intent(in) :: yscal (n) real(kind=wp), intent(inout) :: hdid real(kind=wp), intent(inout) :: hnext procedure( Iderivs_func ) :: derivs public  subroutine rkck (y, dydx, n, x, h, yout, yerr, derivs) метод рунге-кутта, нужны подробности Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: y (n) real(kind=wp), intent(in) :: dydx (n) integer, intent(in) :: n real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out) :: yout (n) real(kind=wp), intent(out) :: yerr (n) procedure( Iderivs_func ) :: derivs","tags":"","loc":"module\\runge_kutta_module.html"},{"title":"savelyev_solver_module – FRTС project","text":"Uses kind_module Contents Functions rplusk rplusk2 rmink rmink2 rs qf k2 kinv kinv2 Subroutines savelyev_solver savelyev_abccoef tridag Functions public  function rplusk (x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) public  function rplusk2 (x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) public  function rmink (x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) public  function rmink2 (x, dif, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) public  function rs (x, alfa2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: alfa2 Return Value real(kind=wp) public  function qf (x) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function k2 (x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif Return Value real(kind=wp) public  function kinv (x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif Return Value real(kind=wp) public  function kinv2 (x, dif) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: dif Return Value real(kind=wp) Subroutines public  subroutine savelyev_solver (alfa2, nt, h, dt, n, ybeg, yend, d1, d2, d3, y) разностная схема Савельева для уравнения Фоккера-Планка Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 integer, intent(in) :: nt real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) real(kind=wp), intent(inout) :: y (n) public  subroutine savelyev_abccoef (alfa2, a, b, c, f, y, dt, n, ybeg, yend, xx, h, d1, d2, d3) -- fill abc matrix Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: alfa2 real(kind=wp), intent(inout) :: a (n) real(kind=wp), intent(inout) :: b (n) real(kind=wp), intent(inout) :: c (n) real(kind=wp), intent(inout) :: f (n) real(kind=wp), intent(inout) :: y (n) real(kind=wp), intent(in) :: dt integer, intent(in) :: n real(kind=wp), intent(in) :: ybeg real(kind=wp), intent(in) :: yend real(kind=wp), intent(in) :: xx (n+1) real(kind=wp), intent(in) :: h real(kind=wp), intent(in) :: d1 (n+1) real(kind=wp), intent(in) :: d2 (n+1) real(kind=wp), intent(in) :: d3 (n+1) public  subroutine tridag (a, b, c, r, u, n) создает трехдиагональнйю матрицу Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a (n) real(kind=wp), intent(in) :: b (n) real(kind=wp), intent(in) :: c (n) real(kind=wp), intent(in) :: r (n) real(kind=wp), intent(inout) :: u (n) integer, intent(in) :: n","tags":"","loc":"module\\savelyev_solver_module.html"},{"title":"spline_module – FRTС project","text":"сплайны\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses kind_module Contents Subroutines splne splnt dsplnt Subroutines public  subroutine splne (x, y, n, y2) Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) real(kind=wp) :: y (n) integer :: n real(kind=wp) :: y2 (n) public  subroutine splnt (xa, ya, y2a, n, x, y, dy) Arguments Type Intent Optional Attributes Name real(kind=wp) :: xa (n) real(kind=wp) :: ya (n) real(kind=wp) :: y2a (n) integer :: n real(kind=wp) :: x real(kind=wp) :: y real(kind=wp) :: dy public  subroutine dsplnt (xa, ya, y2a, n, x, y, dy, ddy) Arguments Type Intent Optional Attributes Name real(kind=wp) :: xa (n) real(kind=wp) :: ya (n) real(kind=wp) :: y2a (n) integer :: n real(kind=wp) :: x real(kind=wp) :: y real(kind=wp) :: dy real(kind=wp) :: ddy","tags":"","loc":"module\\spline_module.html"},{"title":"Utils – FRTС project","text":"Uses kind_module Contents Functions sys_time Functions public  function sys_time () Arguments None Return Value real(kind=wp)","tags":"","loc":"module\\utils.html"},{"title":"writer_module – FRTС project","text":"Uses kind_module Contents Subroutines write_v_array write_x_array write_matrix write_array write_distribution Subroutines public  subroutine write_v_array (v, a, time, array_name) сохраняет массивы расределения и скорости Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: v (:,:) real(kind=wp), intent(in) :: a (:,:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name public  subroutine write_x_array (x, arr, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x (:,:) real(kind=wp), intent(in) :: arr (:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name public  subroutine write_matrix (arr, time, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (:,:) real(kind=wp), intent(in) :: time character(len=*), intent(in) :: array_name public  subroutine write_array (arr, N, array_name) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (*) integer, intent(in) :: N character(len=*), intent(in) :: array_name public  subroutine write_distribution (arr, N, time) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: arr (*) integer, intent(in) :: N real(kind=wp), intent(in) :: time","tags":"","loc":"module\\writer_module.html"},{"title":"driven_current_module – FRTС project","text":"Driven Current Module Uses kind_module Contents Interfaces DrivenCurrent DrivenCurrentResult Derived Types DrivenCurrent DrivenCurrentResult Functions DrivenCurrent_constructor DrivenCurrentResult_constructor Subroutines DrivenCurrent_evaluate driven_current_result_print driven_current_result_save Interfaces public        interface DrivenCurrent public  function DrivenCurrent_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( DrivenCurrent ) public        interface DrivenCurrentResult public  function DrivenCurrentResult_constructor (positive_dc, negative_dc) result(this) Arguments Type Intent Optional Attributes Name type( DrivenCurrent ), intent(in) :: positive_dc type( DrivenCurrent ), intent(in) :: negative_dc Return Value type( DrivenCurrentResult ) Derived Types type, public :: DrivenCurrent Components Type Visibility Attributes Name Initial real(kind=wp), public :: cu ??  может лучше cuj real(kind=wp), public :: cu0 ??              cujoh real(kind=wp), public :: c ?? real(kind=wp), public :: c0 ?? real(kind=wp), public, dimension(:), allocatable :: outj outj(i)  = LH driven current density, MA/m&#94;2 real(kind=wp), public, dimension(:), allocatable :: ohj integer, public :: grid_size Constructor public\n\n                    \n                    function DrivenCurrent_constructor (size) Type-Bound Procedures procedure\n                    ,                  public\n                  :: evaluate => DrivenCurrent_evaluate Subroutine type, public :: DrivenCurrentResult Components Type Visibility Attributes Name Initial real(kind=wp), public :: cup real(kind=wp), public :: cp real(kind=wp), public :: cum real(kind=wp), public :: cm real(kind=wp), public :: cup0 real(kind=wp), public :: cp0 real(kind=wp), public :: cum0 real(kind=wp), public :: cm0 Constructor public\n\n                    \n                    function DrivenCurrentResult_constructor (positive_dc, negative_dc) Type-Bound Procedures procedure\n                    ,                  public\n                  :: print => driven_current_result_print Subroutine procedure\n                    ,                  public\n                  :: save => driven_current_result_save Subroutine Functions public  function DrivenCurrent_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( DrivenCurrent ) public  function DrivenCurrentResult_constructor (positive_dc, negative_dc) result(this) Arguments Type Intent Optional Attributes Name type( DrivenCurrent ), intent(in) :: positive_dc type( DrivenCurrent ), intent(in) :: negative_dc Return Value type( DrivenCurrentResult ) Subroutines public  subroutine DrivenCurrent_evaluate (this, ROC) Arguments Type Intent Optional Attributes Name class( DrivenCurrent ), intent(inout) :: this real(kind=wp), intent(in) :: ROC public  subroutine driven_current_result_print (this, time) Arguments Type Intent Optional Attributes Name class( DrivenCurrentResult ), intent(in) :: this real(kind=wp), intent(in) :: time public  subroutine driven_current_result_save (this, time) Arguments Type Intent Optional Attributes Name class( DrivenCurrentResult ), intent(in) :: this real(kind=wp), intent(in) :: time","tags":"","loc":"module\\driven_current_module.html"},{"title":"FokkerPlanck1D_mod – FRTС project","text":"модуль содержит функции для решения одномерного уравнения Фоккер-Планка Uses iso_fortran_env savelyev_solver_module Contents Interfaces FokkerPlanck1D Derived Types FokkerPlanck1D Functions FokkerPlanck1D_constructor Subroutines FokkerPlanck1D_print FokkerPlanck1D_init_zero_diffusion FokkerPlanck1D_init_diffusion FokkerPlanck1D_solve_time_step burying_procedure Interfaces public        interface FokkerPlanck1D public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) конструктор для FokkerPlanck1D Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Derived Types type, public :: FokkerPlanck1D solver of FP eq Components Type Visibility Attributes Name Initial real(kind=dp), public :: enorm = 0 электрическое поле real(kind=dp), public :: v_lim = 0 верхняя граница скорости электронов real(kind=dp), public, allocatable :: v (:) сетка скоростей real(kind=dp), public, allocatable :: f (:) распределение integer, public :: i0 = 0 size of distribution grid real(kind=dp), public :: alfa2 = 0 поле со знаком integer, public :: n = 0 size of local grid real(kind=dp), public :: h = 0 step of local grid real(kind=dp), public, allocatable :: d1 (:) диффузия real(kind=dp), public, allocatable :: d2 (:) диффузия real(kind=dp), public, allocatable :: d3 (:) диффузия Constructor public\n\n                    \n                    function FokkerPlanck1D_constructor (e, v_lim, v, f) конструктор для FokkerPlanck1D Type-Bound Procedures procedure\n                    ,                  public\n                  :: print => FokkerPlanck1D_print Subroutine procedure\n                    ,                  public\n                  :: solve_time_step => FokkerPlanck1D_solve_time_step Subroutine procedure\n                    ,                  public\n                  :: init_zero_diffusion => FokkerPlanck1D_init_zero_diffusion Subroutine procedure\n                    ,                  public\n                  :: init_diffusion => FokkerPlanck1D_init_diffusion Subroutine Functions public  function FokkerPlanck1D_constructor (e, v_lim, v, f) result(this) конструктор для FokkerPlanck1D Arguments Type Intent Optional Attributes Name real(kind=dp), value :: e real(kind=dp), value :: v_lim real(kind=dp), value :: v (:) real(kind=dp), value :: f (:) Return Value type( FokkerPlanck1D ) Subroutines public  subroutine FokkerPlanck1D_print (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(in) :: this public  subroutine FokkerPlanck1D_init_zero_diffusion (this) Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this public  subroutine FokkerPlanck1D_init_diffusion (this, dif) инициализация диффузии для схемы савельева Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in), dimension(:) :: dif public  subroutine FokkerPlanck1D_solve_time_step (this, dt, nt) !!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! Arguments Type Intent Optional Attributes Name class( FokkerPlanck1D ), intent(inout) :: this real(kind=dp), intent(in) :: dt integer, intent(in) :: nt public  subroutine burying_procedure (v, f0, df0) процедура закапывания Arguments Type Intent Optional Attributes Name real(kind=8), intent(in) :: v (:) real(kind=8), intent(inout) :: f0 (:) real(kind=8), intent(inout), optional :: df0 (:)","tags":"","loc":"module\\fokkerplanck1d_mod.html"},{"title":"plasma – FRTС project","text":"Uses kind_module Contents Variables ngrid nspl tcur rm b_tor0 b_tor r0 z0 rh1 con tem temi zeff afld rh rha drhodr delta ell gamm amy tet1 tet2 xmi cnye cnyi xsz vt0 cnstvc ww cltn vperp cnstal zza zze valfa vpmax vk sk ipsy ncoef cdl cly cgm cmy coeffs y2dn y2tm y2tmi y2zeff ncheb chebne chebdne chebddne enorm fst Functions fn fvt fn1 fn2 ft fti zefff obeom ploshad gaussint Subroutines init_plasma init_parameters find_volums_and_surfaces calc_enorm init_maxwell Variables Type Visibility Attributes Name Initial integer, public :: ngrid ASTRA radial grid number integer, public :: nspl ASTRA radial grid number real(kind=wp), public :: tcur время (придумать название для переменной получше) real(kind=wp), public :: rm minor radius in mid-plane, cm real(kind=wp), public :: b_tor0 временно нужно две переменных, тоже нужно исправить real(kind=wp), public :: b_tor временно нужно две переменных, тоже нужно исправить real(kind=wp), public :: r0 real(kind=wp), public :: z0 real(kind=wp), public :: rh1 real(kind=wp), public, dimension(:), allocatable :: con real(kind=wp), public, dimension(:), allocatable :: tem real(kind=wp), public, dimension(:), allocatable :: temi real(kind=wp), public, dimension(:), allocatable :: zeff real(kind=wp), public, dimension(:), allocatable :: afld real(kind=wp), public, dimension(:), allocatable :: rh real(kind=wp), public, dimension(:), allocatable :: rha real(kind=wp), public, dimension(:), allocatable :: drhodr real(kind=wp), public, dimension(:), allocatable :: delta real(kind=wp), public, dimension(:), allocatable :: ell real(kind=wp), public, dimension(:), allocatable :: gamm real(kind=wp), public, dimension(:), allocatable :: amy real(kind=wp), public :: tet1 common /a0a2/ real(kind=wp), public :: tet2 common /a0a2/ real(kind=wp), public :: xmi /a0ef3/ xmi,cnye,cnyi,xsz,vt0 real(kind=wp), public :: cnye /a0ef3/ xmi,cnye,cnyi,xsz,vt0 real(kind=wp), public :: cnyi /a0ef3/ xmi,cnye,cnyi,xsz,vt0 real(kind=wp), public :: xsz /a0ef3/ xmi,cnye,cnyi,xsz,vt0 real(kind=wp), public :: vt0 /a0ef3/ xmi,cnye,cnyi,xsz,vt0 real(kind=wp), public :: cnstvc real(kind=wp), public :: ww common /a0ef2/ ww real(kind=wp), public :: cltn common /a0ef1/ cltn real(kind=wp), public :: vperp (50,100) real(kind=wp), public :: cnstal real(kind=wp), public :: zza real(kind=wp), public :: zze real(kind=wp), public :: valfa real(kind=wp), public :: vpmax real(kind=wp), public :: vk (100) real(kind=wp), public :: sk (100) integer, public, parameter :: ipsy = 5 ipsy = number of polinomial decomposition coefficients\nused for interpolation of Zakharov's moments. integer, public, parameter :: ncoef = 5 ipsy = number of polinomial decomposition coefficients\nused for interpolation of Zakharov's moments. real(kind=wp), public, dimension(ipsy) :: cdl real(kind=wp), public, dimension(ipsy) :: cly real(kind=wp), public, dimension(ipsy) :: cgm real(kind=wp), public, dimension(ipsy) :: cmy real(kind=wp), public, dimension(ipsy) :: coeffs real(kind=wp), public :: y2dn (501) common /a0l3/ real(kind=wp), public :: y2tm (501) common /a0l3/ real(kind=wp), public :: y2tmi (501) common /a0l3/ real(kind=wp), public :: y2zeff (501) common /a0l5/ integer, public :: ncheb real(kind=wp), public :: chebne (50) common/ne_cheb real(kind=wp), public :: chebdne (50) common/ne_cheb real(kind=wp), public :: chebddne (50) common/ne_cheb real(kind=wp), public :: enorm (100) em поле и еще что-то real(kind=wp), public :: fst (100) em поле и еще что-то Functions public  function fn (x) plasma  density,  cm&#94;-3 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function fvt (r) нет описания Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r Return Value real(kind=wp) public  function fn1 (x, fnp) plasma density and its derivative Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: fnp Return Value real(kind=wp) public  function fn2 (r, fnp, fnpp) plasma density and its first and second derivatives Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r real(kind=wp), intent(out) :: fnp real(kind=wp), intent(out) :: fnpp Return Value real(kind=wp) public  function ft (x) electron temperature, erg\n     ft=y            ! kev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function fti (x) ion temperature, kev Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function zefff (x) z_effective profile Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) public  function obeom (ptet, pa) Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value real(kind=wp) public  function ploshad (ptet, pa) Arguments Type Intent Optional Attributes Name real :: ptet real :: pa Return Value real(kind=wp) public  function gaussint (f, a, b, r, eps) что-то про гаусс Arguments Type Intent Optional Attributes Name real(kind=wp) :: f real(kind=wp) :: a real(kind=wp) :: b real(kind=wp) :: r real(kind=wp) :: eps Return Value real(kind=wp) Subroutines public  subroutine init_plasma (NA1, ABC, BTOR, RTOR, UPDWN, GP2, AMETR, RHO, SHIF, ELON, TRIA, MU, NE, TE, TI, ZEF, UPL) variant\n amy=(btor/q) rho (drho/dr) is a function of \"minor radius\" r=rh(i).\n Poloidal magnetic field: B_pol=amy(r)*sqrt(g22/g), where g is\n determinant of 3D metric tensor and g22 is the (22) element of\n the tensor, normalized on ABC&#94;4 and ABC&#94;2, correspondingly. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: NA1 real(kind=wp), intent(in) :: ABC real(kind=wp), intent(in) :: BTOR real(kind=wp), intent(in) :: RTOR real(kind=wp), intent(in) :: UPDWN real(kind=wp), intent(in) :: GP2 real(kind=wp), dimension(*) :: AMETR real(kind=wp), dimension(*) :: RHO real(kind=wp), dimension(*) :: SHIF real(kind=wp), dimension(*) :: ELON real(kind=wp), dimension(*) :: TRIA real(kind=wp), dimension(*) :: MU real(kind=wp), dimension(*) :: NE real(kind=wp), dimension(*) :: TE real(kind=wp), dimension(*) :: TI real(kind=wp), dimension(*) :: ZEF real(kind=wp), dimension(*) :: UPL public  subroutine init_parameters () !!!!!!      ptkev=ft(zero)/0.16d-8  !Te in keV\n      ccurnr=pqe pqe 0.333d-9/pme Arguments None public  subroutine find_volums_and_surfaces () Arguments None public  subroutine calc_enorm () fst(j)=pn xlogj c0 4/pi4/vt 3 Arguments None public  subroutine init_maxwell () Arguments None","tags":"","loc":"module\\plasma.html"},{"title":"spectrum_mod – FRTС project","text":"Uses kind_module Contents Interfaces Spectrum Derived Types SpectrumPoint Spectrum Functions spectrum_constructor get_positive_part_method get_negative_part_method read_spectrum make_spline_approximation Subroutines calc_max_power_method divide_spectrum Interfaces public        interface Spectrum public  function spectrum_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( Spectrum ) Derived Types type, public :: SpectrumPoint Components Type Visibility Attributes Name Initial real(kind=wp), public :: Ntor Ntau=-Ntor real(kind=wp), public :: Npol Ntet=Npol real(kind=wp), public :: power power type, public :: Spectrum Components Type Visibility Attributes Name Initial integer, public :: size size of spectrum real(kind=wp), public :: input_power power of spectrum real(kind=wp), public :: power_ratio доля входной мощности real(kind=wp), public :: max_power real(kind=wp), public :: sum_power суммарная power integer, public :: direction направление спектра   +1 или -1 или 0 - полный type( SpectrumPoint ), public, allocatable :: data (:) Constructor public\n\n                    \n                    function spectrum_constructor (size) Type-Bound Procedures procedure\n                    ,                  public\n                  :: get_positive_part => get_positive_part_method Function procedure\n                    ,                  public\n                  :: get_negative_part => get_negative_part_method Function procedure\n                    ,                  public\n                  :: calc_max_power => calc_max_power_method Subroutine Functions public  function spectrum_constructor (size) result(this) Arguments Type Intent Optional Attributes Name integer, value :: size Return Value type( Spectrum ) public  function get_positive_part_method (this) result(spectr) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value type( Spectrum ) public  function get_negative_part_method (this) result(spectr) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(in) :: this Return Value type( Spectrum ) public  function read_spectrum (file_name) result(spectr) Arguments Type Intent Optional Attributes Name character(len=*), value :: file_name Return Value type( Spectrum ) public  function make_spline_approximation (spectr) result(appx_spectr) approximation of input LH spectrum Arguments Type Intent Optional Attributes Name type( Spectrum ), intent(in) :: spectr Return Value type( Spectrum ) Subroutines public  subroutine calc_max_power_method (this) Arguments Type Intent Optional Attributes Name class( Spectrum ), intent(inout) :: this public  subroutine divide_spectrum (spectr, pos_spectr, neg_spectr) деление спектра на две части Arguments Type Intent Optional Attributes Name type( Spectrum ), intent(in) :: spectr type( Spectrum ), intent(out) :: pos_spectr type( Spectrum ), intent(out) :: neg_spectr","tags":"","loc":"module\\spectrum_mod.html"},{"title":"spectrum1D – FRTС project","text":"Uses iso_fortran_env spectrum_mod Contents Variables full_spectrum pos_spectr neg_spectr ispl plaun ynzm0 pm0 ynzm pm pabs Functions create_spectrum Subroutines read_positive_spectrum read_negative_spectrum spectrum_approximation copy_to_spectrum_1D write_spectrum Variables Type Visibility Attributes Name Initial type( Spectrum ), public :: full_spectrum type( Spectrum ), public :: pos_spectr type( Spectrum ), public :: neg_spectr integer, public :: ispl size of spectrum real(kind=wp), public :: plaun power of spectrum real(kind=wp), public :: ynzm0 (1001) real(kind=wp), public :: pm0 (1001) real(kind=wp), public :: ynzm (1001) common /a0a1/ ynzm(1001),pm(1001) real(kind=wp), public :: pm (1001) common /a0a1/ ynzm(1001),pm(1001) real(kind=wp), public :: pabs common /a0gh/ pabs Functions public  function create_spectrum () result(spectr) Arguments None Return Value type( Spectrum ) Subroutines public  subroutine read_positive_spectrum (file_name, p_in) Arguments Type Intent Optional Attributes Name character :: file_name real(kind=wp) :: p_in public  subroutine read_negative_spectrum (file_name, p_in) Arguments Type Intent Optional Attributes Name character :: file_name real(kind=wp) :: p_in public  subroutine spectrum_approximation (ispectr) approximation of input LH spectrum Arguments Type Intent Optional Attributes Name integer, intent(in) :: ispectr public  subroutine copy_to_spectrum_1D (spectr) Arguments Type Intent Optional Attributes Name type( Spectrum ) :: spectr public  subroutine write_spectrum (ispectr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ispectr","tags":"","loc":"module\\spectrum1d.html"},{"title":"current – FRTС project","text":"Uses kind_module Contents Variables dql pdl vzmin vzmax fcoll dens eta dq1 dq2 pdc pda ppv1 ppv2 pdfast dqi0 dncount Subroutines find_achieved_radial_points dfind Variables Type Visibility Attributes Name Initial real(kind=wp), public :: dql (101,100) real(kind=wp), public :: pdl (100) real(kind=wp), public :: vzmin (100) real(kind=wp), public :: vzmax (100) real(kind=wp), public :: fcoll (100) real(kind=wp), public :: dens (100) real(kind=wp), public :: eta (100) real(kind=wp), public :: dq1 (101,100) real(kind=wp), public :: dq2 (101,100) real(kind=wp), public :: pdc (100) real(kind=wp), public :: pda (100) real(kind=wp), public :: ppv1 real(kind=wp), public :: ppv2 real(kind=wp), public :: pdfast (100) real(kind=wp), public :: dqi0 (50,100) real(kind=wp), public :: dncount (101,100) Subroutines public  subroutine find_achieved_radial_points (nvpt) find achieved radial points jbeg-jend Arguments Type Intent Optional Attributes Name integer, intent(in) :: nvpt public  subroutine dfind (j, i, v, powpr, pil, pic, pia, df, decv, refr, vlf, vrt, ifast) !        adde=zze (dd/dens(j)) weight\n!        e2perp(i,j)=e2perp(i,j)+adde Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: i real(kind=wp), intent(in) :: v real(kind=wp), intent(in) :: powpr real(kind=wp), intent(in) :: pil real(kind=wp), intent(in) :: pic real(kind=wp), intent(in) :: pia real(kind=wp), intent(in) :: df real(kind=wp), intent(in) :: decv real(kind=wp), intent(in) :: refr real(kind=wp), intent(in) :: vlf real(kind=wp), intent(in) :: vrt integer, intent(in) :: ifast","tags":"","loc":"module\\current.html"},{"title":"power – FRTС project","text":"Contents None","tags":"","loc":"module\\power.html"},{"title":"dispersion_module – FRTС project","text":"Uses kind_module Contents Variables yn3 ivar icall1 icall2 iroot izn ider xnr1 xnr2 xnr3 xnr4 ynz ynpopq iconv irefl ipow jfoundr ifound vfound pdec1 pdec2 pdec3 pdecv pdecal dfdv icf1 icf2 cf1 cf2 cf3 cf4 cf5 cf6 dhdm dhdnr dhdtet dhdr ddn dhdn3 dhdv2v dhdu2u znakstart g11 g12 g22 g33 gg g si co ham pdec14 pdec24 pdec34 idec rsou sou npta dgdu kzero Functions zatukh Subroutines disp2 disp4 dhdomega source_new extd4 Variables Type Visibility Attributes Name Initial real(kind=wp), public :: yn3 common /abefo/ yn3 integer, public :: ivar common /bdeo/ ivar integer, public :: icall1 integer, public :: icall2 integer, public :: iroot common /beo/ iroot integer, public :: izn common /abcde/ izn integer, public :: ider common /be2/ ider real(kind=wp), public :: xnr1 common /be1/ xnr1,xnr2,xnr3,xnr4 real(kind=wp), public :: xnr2 common /be1/ xnr1,xnr2,xnr3,xnr4 real(kind=wp), public :: xnr3 common /be1/ xnr1,xnr2,xnr3,xnr4 real(kind=wp), public :: xnr4 common /be1/ xnr1,xnr2,xnr3,xnr4 real(kind=wp), public :: ynz common /bcef/ ynz,ynpopq real(kind=wp), public :: ynpopq common /bcef/ ynz,ynpopq integer, public :: iconv common /cefn/ iconv,irefl integer, public :: irefl common /cefn/ iconv,irefl integer, public :: ipow common /ceg/ ipow,jfoundr integer, public :: jfoundr common /ceg/ ipow,jfoundr integer, public :: ifound real(kind=wp), public :: vfound common /eg1/ vfound,ifound real(kind=wp), public :: pdec1 real(kind=wp), public :: pdec2 real(kind=wp), public :: pdec3 real(kind=wp), public :: pdecv real(kind=wp), public :: pdecal real(kind=wp), public :: dfdv integer, public :: icf1 common /eg2/ pdec1,pdec2,pdec3,pdecv,pdecal,dfdv,icf1,icf2 integer, public :: icf2 common /eg2/ pdec1,pdec2,pdec3,pdecv,pdecal,dfdv,icf1,icf2 real(kind=wp), public :: cf1 common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 real(kind=wp), public :: cf2 common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 real(kind=wp), public :: cf3 common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 real(kind=wp), public :: cf4 common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 real(kind=wp), public :: cf5 common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 real(kind=wp), public :: cf6 common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 real(kind=wp), public :: dhdm common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: dhdnr common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: dhdtet common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: dhdr common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: ddn common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: dhdn3 common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: dhdv2v common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: dhdu2u common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real(kind=wp), public :: znakstart common/direct/znakstart real(kind=wp), public :: g11 common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: g12 common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: g22 common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: g33 common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: gg common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: g common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: si common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: co common/metrika/g11,g12,g22,g33,gg,g,si,co real(kind=wp), public :: ham common/fjham/ham real(kind=wp), public :: pdec14 common /df/ pdec14,pdec24,pdec34,idec real(kind=wp), public :: pdec24 common /df/ pdec14,pdec24,pdec34,idec real(kind=wp), public :: pdec34 common /df/ pdec14,pdec24,pdec34,idec real(kind=wp), public :: idec common /df/ pdec14,pdec24,pdec34,idec real(kind=wp), public :: rsou (102) real(kind=wp), public :: sou (102) integer, public :: npta common /asou/ rsou(102),sou(102),npta\n используется в source_new и ourlhcd2017 real(kind=wp), public :: dgdu (50,100) integer, public :: kzero (100) common /arr/ dgdu(50,100),kzero(100)\n используется в zatukh, ourlhcd2017 и alphas Functions public  function zatukh (psy, j, u, n) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: psy integer, intent(in) :: j real(kind=wp), intent(in) :: u (:,:) integer, intent(in) :: n Return Value real(kind=wp) Subroutines public  subroutine disp2 (pa, yn2, ptet, xnro, prt, prm) old variant: Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: pa real(kind=wp), intent(in) :: yn2 real(kind=wp), intent(in) :: ptet real(kind=wp), intent(inout) :: xnro real(kind=wp), intent(inout) :: prt real(kind=wp), intent(inout) :: prm public  subroutine disp4 (pa, ptet, xnr, yn2) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n      dl=bs 2-4d0 as bs Read more… Arguments Type Intent Optional Attributes Name real :: pa real :: ptet real :: xnr real :: yn2 public  subroutine dhdomega (rho, theta, yn1, yn2) w*dH/dw=wdhdw: Arguments Type Intent Optional Attributes Name real :: rho real :: theta real :: yn1 real :: yn2 public  subroutine source_new (r, out) Arguments Type Intent Optional Attributes Name real :: r real :: out public  subroutine extd4 (x, y, dydx) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y (:) real(kind=wp), intent(inout) :: dydx (:)","tags":"","loc":"module\\dispersion_module.html"},{"title":"FluxSurface_mod – FRTС project","text":"все что связанно с магнитными поверхностями Uses kind_module Contents Derived Types FluxSurface Derived Types type, public :: FluxSurface класс магнитной поверхности Components Type Visibility Attributes Name Initial integer, public :: index номер магнитной поверхности real(kind=wp), public :: r радиус real(kind=wp), public :: vmax vmax=cltn/vto real(kind=wp), public :: vt наверно тепловая скорость электронов????? vt=fvt(r) integer, public :: ipt размер vgrid real(kind=wp), public, allocatable :: vgrid (:) real(kind=wp), public, allocatable :: vr_grid (:) бываший vrj real(kind=wp), public, allocatable :: diffusion (:) бывший dijk(i,j,k) или dj(i)","tags":"","loc":"module\\fluxsurface_mod.html"},{"title":"FokkerPlanck_module – FRTС project","text":"calculation of distribution functions at time t1=t+dtau !! Uses kind_module Contents Subroutines fokkerplanck_compute init_diffusion Subroutines public  subroutine fokkerplanck_compute (time, TAU) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: time real(kind=wp), intent(in) :: TAU public  subroutine init_diffusion (h, n, vj, dj, d1, d2, d3) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: h integer, intent(in) :: n real(kind=wp), intent(in), dimension(:) :: vj real(kind=wp), intent(in), dimension(:) :: dj real(kind=wp), intent(out), dimension(:) :: d1 real(kind=wp), intent(out), dimension(:) :: d2 real(kind=wp), intent(out), dimension(:) :: d3","tags":"","loc":"module\\fokkerplanck_module.html"},{"title":"iteration_result_mod – FRTС project","text":"Uses kind_module Contents Derived Types IterationResult Subroutines iteration_result_print iteration_result_save Derived Types type, public :: IterationResult Components Type Visibility Attributes Name Initial integer, public :: number iteration number 'iteration=',iterat integer, public :: spectr_direction 'ispectr=',ispectr real(kind=wp), public :: P_launched P_launched, MW=',plaun real(kind=wp), public :: P_landau 'P_landau, MW=',ol real(kind=wp), public :: P_coll 'P_coll, MW=',oc real(kind=wp), public :: P_alph 'P_alph, MW=',oa real(kind=wp), public :: alphas_power 'Alphas power, MW=',fuspow real(kind=wp), public :: P_fast real(kind=wp), public :: P_lost real(kind=wp), public :: P_not_accounted real(kind=wp), public :: P_landau_strong_absorption real(kind=wp), public :: P_landau_weak_absorption real(kind=wp), public :: P_turns real(kind=wp), public :: efficiency real(kind=wp), public :: avedens real(kind=wp), public :: r0 real(kind=wp), public :: eta_eff real(kind=wp), public :: residual невязка 'nevyazka=', pchg Type-Bound Procedures procedure\n                    ,                  public\n                  :: print => iteration_result_print Subroutine procedure\n                    ,                  public\n                  :: save => iteration_result_save Subroutine Subroutines public  subroutine iteration_result_print (this) Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this public  subroutine iteration_result_save (this, time_stamp) save Iteration Result to file Arguments Type Intent Optional Attributes Name class( IterationResult ), intent(in) :: this real(kind=wp), intent(in) :: time_stamp","tags":"","loc":"module\\iteration_result_mod.html"},{"title":"iterator_mod – FRTС project","text":"Uses kind_module Contents Variables vmid vz1 vz2 ibeg iend vrj dj djnew dj2 d2j vvj vdfj vgrid dfundv nvpt ipt1 ipt2 ipt kpt1 kpt3 iterat psum4 plost pnab Subroutines init_iteration recalculate_f_for_a_new_mesh Variables Type Visibility Attributes Name Initial real(kind=wp), public :: vmid (100) real(kind=wp), public :: vz1 (100) real(kind=wp), public :: vz2 (100) integer, public :: ibeg (100) integer, public :: iend (100) real(kind=wp), public :: vrj (101) real(kind=wp), public :: dj (101) real(kind=wp), public :: djnew (1001) real(kind=wp), public :: dj2 (101) real(kind=wp), public :: d2j (101) real(kind=wp), public, dimension(:), allocatable :: vvj real(kind=wp), public, dimension(:), allocatable :: vdfj real(kind=wp), public :: vgrid (101,100) common/gridv/vgrid(101,100),dfundv(101,100) real(kind=wp), public :: dfundv (101,100) common/gridv/vgrid(101,100),dfundv(101,100) integer, public :: nvpt common/gridv/nvpt integer, public :: ipt1 integer, public :: ipt2 integer, public :: ipt integer, public, parameter :: kpt1 = 20 integer, public, parameter :: kpt3 = 20 integer, public :: iterat real(kind=wp), public :: psum4 common /vvv2/ psum4 real(kind=wp), public :: plost common /a0a4/ plost,pnab real(kind=wp), public :: pnab common /a0a4/ plost,pnab Subroutines public  subroutine init_iteration () Arguments None public  subroutine recalculate_f_for_a_new_mesh (ispectr) recalculate f' for a new mesh\n!         if(vrj(i).gt.vvj(i0)) exit Arguments Type Intent Optional Attributes Name integer, intent(in) :: ispectr","tags":"","loc":"module\\iterator_mod.html"},{"title":"trajectory – FRTС project","text":"Uses kind_module Contents Variables length mpnt irs iabsorp rzz tetzz xmzz iznzz iwzz irszz hrad im4 nrefj dland dcoll perpn dalf vel tetai xnpar izz iww jrad mbeg mend mbad rbeg tetbeg xnrbeg xmbeg yn3beg Subroutines init_trajectory view traj driver4 Variables Type Visibility Attributes Name Initial integer, public, parameter :: length = 5000000 integer, public, parameter :: mpnt = 100000 integer, public :: irs integer, public :: iabsorp real(kind=wp), public :: rzz common /abc/ rzz,tetzz,xmzz real(kind=wp), public :: tetzz common /abc/ rzz,tetzz,xmzz real(kind=wp), public :: xmzz common /abc/ rzz,tetzz,xmzz integer, public :: iznzz common /abc/ iznzz,iwzz,irszz integer, public :: iwzz common /abc/ iznzz,iwzz,irszz integer, public :: irszz common /abc/ iznzz,iwzz,irszz real(kind=wp), public :: hrad integer, public :: im4 integer, public :: nrefj (mpnt) common/refl/nrefj(mpnt) real(kind=wp), public :: dland (length) real(kind=wp), public :: dcoll (length) real(kind=wp), public :: perpn (length) real(kind=wp), public :: dalf (length) real(kind=wp), public :: vel (length) real(kind=wp), public :: tetai (length) real(kind=wp), public :: xnpar (length) integer, public :: izz (length) common/agh/xnpar,vel,dland,dcoll,dalf,perpn,tetai,jrad,iww,izz integer, public :: iww (length) common/agh/xnpar,vel,dland,dcoll,dalf,perpn,tetai,jrad,iww,izz integer, public :: jrad (length) common/agh/xnpar,vel,dland,dcoll,dalf,perpn,tetai,jrad,iww,izz integer, public :: mbeg (mpnt) integer, public :: mend (mpnt) integer, public :: mbad (mpnt) real(kind=wp), public :: rbeg (mpnt) real(kind=wp), public :: tetbeg (mpnt) common/viewdat/mbeg,mend,mbad,rbeg,tetbeg,xnrbeg,xmbeg,yn3beg real(kind=wp), public :: xnrbeg (mpnt) common/viewdat/mbeg,mend,mbad,rbeg,tetbeg,xnrbeg,xmbeg,yn3beg real(kind=wp), public :: xmbeg (mpnt) common/viewdat/mbeg,mend,mbad,rbeg,tetbeg,xnrbeg,xmbeg,yn3beg real(kind=wp), public :: yn3beg (mpnt) common/viewdat/mbeg,mend,mbad,rbeg,tetbeg,xnrbeg,xmbeg,yn3beg Subroutines public  subroutine init_trajectory () Arguments None public  subroutine view (tview, iview, nnz, ntet) !writing trajectories into a file\n          pintld=-dland(i) (dflf+dfrt)/2d0\n          pdec1=-pdecv df Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: tview integer, intent(in) :: iview integer, intent(in) :: nnz integer, intent(in) :: ntet public  subroutine traj (xm0, tet0, xbeg, nmax, nb1, nb2, nomth, nomnz, pabs) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xm0 real(kind=wp), intent(in) :: tet0 real(kind=wp), intent(inout) :: xbeg integer, intent(inout) :: nmax integer, intent(inout) :: nb1 integer, intent(inout) :: nb2 integer, intent(in) :: nomth integer, intent(in) :: nomnz real(kind=wp), intent(in) :: pabs public  subroutine driver4 (ystart, x1, x2, rexi, hmin, derivs) var        if(dabs(dydx(3)).ne.zero) h=dabs(hmin1/dydx(3))/hdrob1\n    if(dabs(y(3)-rexi).gt.rrange.or.nstp.eq.maxstep4) then  ! exit !sav2008 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: ystart (:) real(kind=wp), intent(inout) :: x1 real(kind=wp), intent(inout) :: x2 real(kind=wp), intent(in) :: rexi real(kind=wp), intent(in) :: hmin procedure( Iderivs_func ) :: derivs","tags":"","loc":"module\\trajectory.html"},{"title":"manager_mod – FRTС project","text":"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! Uses kind_module Contents Variables pow inak lenstor lfree Functions rini Subroutines manager Variables Type Visibility Attributes Name Initial real(kind=wp), public :: pow common /acg/ pow integer, public :: inak integer, public :: lenstor integer, public :: lfree Functions public  function rini (xm, tet, xnr, point, hr, ifail) xm=yn dsqrt(g22)         !given yn=(N jpol) at Nfi=0\nyn3=yn*dsqrt(g33)       !if given Nfi at Nteta=0 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout) :: xm real(kind=wp), intent(in) :: tet real(kind=wp), intent(inout) :: xnr type( SpectrumPoint ), intent(in) :: point real(kind=wp), intent(in) :: hr integer, intent(inout) :: ifail Return Value real(kind=wp) Subroutines public  subroutine manager (iterat, iw0, ntet, spectr) Arguments Type Intent Optional Attributes Name integer :: iterat integer :: iw0 integer :: ntet type( Spectrum ) :: spectr","tags":"","loc":"module\\manager_mod.html"},{"title":"0_kind_module.f90 – FRTС project","text":"Contents Modules kind_module Source Code 0_kind_module.f90 Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Define the numeric kinds. module kind_module use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none private !integer,parameter,public :: wp = real32     !! single precision reals integer , parameter , public :: wp = real64 !! double precision reals !integer,parameter,public :: wp = real128    !! quad precision reals end module kind_module !*****************************************************************************************","tags":"","loc":"sourcefile\\0_kind_module.f90.html"},{"title":"1_approximation.f90 – FRTС project","text":"Contents Modules approximation Source Code 1_approximation.f90 Source Code module approximation !! polinomial approximation use kind_module implicit none contains real ( wp ) function polin ( k , x ) implicit none integer k real ( wp ) x polin = 1 d0 if ( k . gt . 1 ) polin = x ** ( k - 1 ) return end real ( wp ) function polin1 ( k , x ) implicit none integer k real ( wp ) x polin1 = x ** k return end real ( wp ) function polin2 ( k , x ) implicit none integer k real ( wp ) x polin2 = x ** ( k + 1 ) return end subroutine approx ( x , y , n , f , m , b ) !!     y(i)=y(x(i))  the data to be approximated. !!     n  number of points in the input data. !!     m  number of coefficients of decomposition !!            over base functions f(k,x) : !!     y(x)=sum_1&#94;m [b(k)*f(k,x)] !!     b(i)  found decomposition coefficients implicit real * 8 ( a - h , o - z ) integer , parameter :: np = 20 real ( wp ), parameter :: zero = 0.d0 real ( wp ) a ( np , np ), indx ( np ) real ( wp ) y ( n ), x ( n ), b ( * ) integer i , j , k , m , n if ( m . gt . np ) then write ( * , * ) 'index error subroutine \"approx\"' return end if do j = 1 , m do k = 1 , j a ( k , j ) = zero do i = 1 , n a ( k , j ) = a ( k , j ) + f ( j , x ( i )) * f ( k , x ( i )) end do end do end do do k = 2 , m do j = 1 , k - 1 a ( k , j ) = a ( j , k ) end do end do do k = 1 , m b ( k ) = zero do i = 1 , n b ( k ) = b ( k ) + y ( i ) * f ( k , x ( i )) end do end do call ludcmp ( a , m , np , indx , d ) call lubksb ( a , m , np , indx , b ) end subroutine ludcmp ( a , n , np , indx , d ) implicit real * 8 ( a - h , o - z ) integer , parameter :: nmax = 501 real ( wp ), parameter :: tiny = 1.d-20 , zero = 0.d0 real ( wp ) a ( np , np ), indx ( n ), vv ( nmax ) integer i , j , k , m , n , np , imax d = 1.d0 do i = 1 , n aamax = zero do j = 1 , n if ( dabs ( a ( i , j )). gt . aamax ) aamax = dabs ( a ( i , j )) end do if ( aamax . eq . zero ) pause 'singular matrix.' vv ( i ) = 1.d0 / aamax end do do j = 1 , n if ( j . gt . 1 ) then do i = 1 , j - 1 sum = a ( i , j ) if ( i . gt . 1 ) then do k = 1 , i - 1 sum = sum - a ( i , k ) * a ( k , j ) end do a ( i , j ) = sum endif end do endif aamax = zero do i = j , n sum = a ( i , j ) if ( j . gt . 1 ) then do k = 1 , j - 1 sum = sum - a ( i , k ) * a ( k , j ) end do a ( i , j ) = sum endif dum = vv ( i ) * dabs ( sum ) if ( dum . ge . aamax ) then imax = i aamax = dum endif end do if ( j . ne . imax ) then do k = 1 , n dum = a ( imax , k ) a ( imax , k ) = a ( j , k ) a ( j , k ) = dum end do d =- d vv ( imax ) = vv ( j ) endif indx ( j ) = imax if ( j . ne . n ) then if ( a ( j , j ). eq . zero ) a ( j , j ) = tiny dum = 1.d0 / a ( j , j ) do i = j + 1 , n a ( i , j ) = a ( i , j ) * dum end do endif end do if ( a ( n , n ). eq . zero ) a ( n , n ) = tiny return end subroutine lubksb ( a , n , np , indx , b ) implicit real * 8 ( a - h , o - z ) real ( wp ), parameter :: zero = 0.d0 real ( wp ) a ( np , np ), indx ( n ), b ( n ) integer i , j , ii , ll , n , np ii = 0 do i = 1 , n ll = indx ( i ) sum = b ( ll ) b ( ll ) = b ( i ) if ( ii . ne . 0 ) then do j = ii , i - 1 sum = sum - a ( i , j ) * b ( j ) end do else if ( sum . ne . zero ) then ii = i endif b ( i ) = sum end do do i = n , 1 , - 1 sum = b ( i ) if ( i . lt . n ) then do j = i + 1 , n sum = sum - a ( i , j ) * b ( j ) end do endif b ( i ) = sum / a ( i , i ) end do return end function fdf ( x , c , n , df ) result ( p ) !! вычисление значения полинома и его производной real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: c ( n ) integer , intent ( in ) :: n real ( wp ), intent ( out ) :: df integer :: j real ( wp ) :: p , dp p = c ( n ) dp = 0.d0 do j = n - 1 , 1 , - 1 dp = dp * x + p p = p * x + c ( j ) end do df = dp end real ( wp ) function fdfddf ( x , c , n , df , ddf ) real ( wp ) x , c ( n ), df , ddf integer n , j real ( wp ) p , dp , ddp p = c ( n ) dp = 0 d0 ddp = 0 d0 do j = n - 1 , 1 , - 1 ddp = ddp * x + 2 d0 * dp dp = dp * x + p p = p * x + c ( j ) end do fdfddf = p df = dp ddf = ddp end end module approximation","tags":"","loc":"sourcefile\\1_approximation.f90.html"},{"title":"1_chang_cooper_solver.f90 – FRTС project","text":"Contents Modules chang_cooper_module Source Code 1_chang_cooper_solver.f90 Source Code module chang_cooper_module use kind_module implicit none contains subroutine chang_cooper_solver ( alfa2 , nt , h , dt , n , ybeg , yend , d1 , d2 , d3 , y ) ! схема Ченга-Купера для уравнения Фоккера-Планка implicit none real ( wp ), intent ( in ) :: alfa2 integer , intent ( in ) :: nt , n real ( wp ), intent ( in ) :: h , dt real ( wp ), intent ( in ) :: ybeg , yend real ( wp ), intent ( in ) :: d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 ) real ( wp ), intent ( inout ) :: y ( n + 2 ) integer i , it , iz real ( wp ) xx ( n + 1 ), a ( n ), b ( n ), c ( n ), f ( n ) real ( wp ) y1 ( n ) !print *, 'TK abc n = ', n do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do i = 1 , n y1 ( i ) = y ( i + 1 ) end do do it = 1 , nt !call ABCcoef(a,b,c,f,y1,dt,n,ybeg,yend,x,xx,h,D1) call chang_cooper_abcoef ( alfa2 , a , b , c , f , y1 , dt , n , ybeg , yend , xx , h , d1 ) call tridag ( a , b , c , f , y1 , n ) !do i=1,n !    if (y1(i).lt.0.d0) then !        if (y1(i) > epsilon(y1(i))) then !            y1(i)=0.d0 !        else !            write(*,*) n, i, 'y(i)=',y1(i),' lt negative epsilon=',epsilon(y1(i)) !            !pause !            !stop !        endif !    endif !enddo iz = n do i = 1 , n if ( y1 ( i ). lt . epsilon ( yend )) then iz = i !print *, epsilon(yend) !print *, iz, n, yend, y1(i) exit endif enddo do i = iz , n y1 ( i ) = yend enddo end do do i = 1 , n y ( i + 1 ) = y1 ( i ) end do end subroutine ! -- subroutine chang_cooper_abcoef ( alfa2 , A , B , C , f , Y , dt , n , ybeg , yend , xx , h , df ) implicit none real ( wp ), intent ( in ) :: alfa2 real ( wp ), intent ( inout ) :: a ( n ), b ( n ), c ( n ), f ( n ), y ( n + 2 ) integer , intent ( in ) :: n real ( wp ), intent ( in ) :: dt , ybeg , yend , h real ( wp ), intent ( in ) :: xx ( n + 1 ) real ( wp ), intent ( in ) :: df ( n + 1 ) integer i real ( wp ) z , r , tmp1 , tmp2 , tmp3 r = dt / h do i = 1 , n tmp1 = dlt ( xx ( i ), h , df ( i ), alfa2 ) * B1 ( xx ( i ), alfa2 ) A ( i ) =- r * ( C1 ( xx ( i ), df ( i )) / h - tmp1 ) tmp2 = C1 ( xx ( i + 1 ), df ( i + 1 )) / h - dlt ( xx ( i + 1 ), h , df ( i + 1 ), alfa2 ) * B1 ( xx ( i + 1 ), alfa2 ) tmp3 = ( 1.d0 - dlt ( xx ( i ), h , df ( i ), alfa2 )) * B1 ( xx ( i ), alfa2 ) B ( i ) = r * ( tmp2 + tmp3 + C1 ( xx ( i ), df ( i )) / h ) + 1.d0 tmp1 = ( 1.d0 - dlt ( xx ( i + 1 ), h , df ( i + 1 ), alfa2 )) * B1 ( xx ( i + 1 ), alfa2 ) C ( i ) =- r * ( tmp1 + C1 ( xx ( i + 1 ), df ( i + 1 )) / h ) f ( i ) = Y ( i ) enddo f ( 1 ) = f ( 1 ) - A ( 1 ) * ybeg f ( n ) = f ( n ) - C ( n ) * yend !yend in either way=0 all the time contains function B1 ( xx , alfa2 ) result ( res ) implicit none real ( wp ) xx , alfa2 , beta , res res = - alfa2 + 1.d0 / ( xx * xx ) end function function C1 ( xx , dif ) result ( res ) implicit none real ( wp ) xx , dif , res res = dif + 1.d0 / ( xx * xx * xx ) end function function dlt ( xx , h , dif , alfa2 ) result ( res ) implicit none real ( wp ) res real ( wp ) xx , h , dif , alfa2 real ( wp ) w w = h * B1 ( xx , alfa2 ) / C1 ( xx , dif ) res = 1.d0 / w - 1.d0 / ( dexp ( w ) - 1.d0 ) end function end !cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc end module Chang_Cooper_module","tags":"","loc":"sourcefile\\1_chang_cooper_solver.f90.html"},{"title":"1_chebyshev.f90 – FRTС project","text":"Contents Modules chebyshev Source Code 1_chebyshev.f90 Source Code module chebyshev !! Chebyshev fit use kind_module implicit none contains SUBROUTINE chebft1 ( a , b , c , n , func ) !! Chebyshev fit: Given a function func, lower and upper limits !! of the interval [a,b], and a maximum degree n, this routine !! computes the n coefficients c(k) such that func(x) approximately = !! SUMM_(k=1)&#94;(k=n)[c(k)*T(k-1)(y)]-c(1)/2, where y and x are related by !! (5.8.10). This routine is to be used with moderately large n !! (e.g., 30 or 50), the array of cs subsequently to be truncated !! at the smaller value m such that c(m+1) and subsequent elements !! are negligible. Parameters: Maximum expected value of n, and ð. implicit none INTEGER n , NMAX real ( wp ) a , b , c ( n ), func , PI EXTERNAL func PARAMETER ( NMAX = 50 , PI = 3.141592653589793d0 ) INTEGER j , k real ( wp ) bma , bpa , fac , y , f ( NMAX ) real ( wp ) sum bma = 0.5d0 * ( b - a ) bpa = 0.5d0 * ( b + a ) do k = 1 , n y = cos ( PI * ( k - 0.5d0 ) / n ) f ( k ) = func ( y * bma + bpa ) end do fac = 2.d0 / n do j = 1 , n sum = 0.d0 do k = 1 , n sum = sum + f ( k ) * cos (( PI * ( j - 1 )) * (( k - 0.5d0 ) / n )) end do c ( j ) = fac * sum end do return END FUNCTION chebev ( a , b , c , m , x ) !! Chebyshev evaluation: All arguments are input. !! c(1:m) is an array of Chebyshev coefficients, the first m elements !! of c output from chebft (which must have been called with !! the same a and b). The Chebyshev polynomial evaluated !! and the result is returned as the function value. implicit none INTEGER m real ( wp ) chebev , a , b , x , c ( m ) INTEGER j real ( wp ) d , dd , sv , y , y2 if (( x - a ) * ( x - b ). gt . 0.d0 ) pause 'x not in range in chebev' d = 0.d0 dd = 0.d0 y = ( 2.d0 * x - a - b ) / ( b - a ) y2 = 2.d0 * y do j = m , 2 , - 1 sv = d d = y2 * d - dd + c ( j ) dd = sv end do chebev = y * d - dd + 0.5d0 * c ( 1 ) return END SUBROUTINE chder ( a , b , c , cder , n ) !! Given a,b,c(1:n), as output from routine chebft(), and given n, !! the desired degree of approximation (length of c to be used), !! this routine returns the array cder(1:n), the Chebyshev !! coefficients of the derivative of the function whose coefficients !! are c(1:n). implicit none INTEGER n real ( wp ) a , b , c ( n ), cder ( n ) INTEGER j real ( wp ) con cder ( n ) = 0.d0 cder ( n - 1 ) = 2 * ( n - 1 ) * c ( n ) do j = n - 2 , 1 , - 1 cder ( j ) = cder ( j + 2 ) + 2 * j * c ( j + 1 ) end do con = 2.d0 / ( b - a ) do j = 1 , n cder ( j ) = cder ( j ) * con end do return END end module chebyshev","tags":"","loc":"sourcefile\\1_chebyshev.f90.html"},{"title":"1_constants.f90 – FRTС project","text":"Contents Modules constants Source Code 1_constants.f90 Source Code module constants !! модуль с математическими и физическими константами !! nt_001 тестовый комментарий use kind_module implicit none real ( wp ), parameter :: zero = 0.0_wp real ( wp ), parameter :: one = 1.0_wp real ( wp ), parameter :: two = 2.0_wp real ( wp ), parameter :: one_third = 1.0_wp / 3.0_wp real ( wp ), parameter :: tiny = 1.e-100_wp real ( wp ), parameter :: tin = 1e-7_wp real ( wp ), parameter :: pi = acos ( - one ) !! число Пи = 3.1415.... real ( wp ), parameter :: pi2 = 2.0_wp * pi real ( wp ), parameter :: pi4 = 4.0_wp * pi real ( wp ), parameter :: piq = sqrt ( pi ) real ( wp ), parameter :: pisqrt = sqrt ( pi ) real ( wp ), parameter :: pi2sqrt = sqrt ( pi2 ) !pi2sqrt=2.506628274631d0,pisqrt=1.77245385090552d0) real ( wp ), parameter :: talfa = 3.5_wp !! alpha particles' birth energy, MeV real ( wp ), parameter :: zalfa = 2.0_wp !! alpha particles' electrical charge real ( wp ), parameter :: xmalfa = 4.0_wp !! alpha particles' atomic mass real ( wp ), parameter :: clt = 3.0e+10_wp !! скорость света real ( wp ), parameter :: pme = 9.11e-28_wp real ( wp ), parameter :: pme_e = 9.11e-28 real ( wp ), parameter :: pqe = 4.803e-10_wp real ( wp ), parameter :: xlog = 1 6.0_wp + dlog ( 1 6.0_wp ) real ( wp ), parameter :: c0 = sqrt ( pi4 * pqe ** 2 / pme ) real ( wp ), parameter :: c1 = pqe / pme / clt real ( wp ), parameter :: xsgs = 1e+13_wp real ( wp ), parameter :: xwtt = 1e-7_wp real ( wp ), parameter :: cnst1 = 0.2965924106e-6_wp !! cnst1=(m_e/m_p)**2, CGS real ( wp ), parameter :: cnst2 = 0.359680922e-35_wp !! cnst2=(m_e/e)**2,  CGS contains subroutine show_constants () print * , '---------------------------------------' print * , \"zero       = \" , zero print * , \"one        = \" , one print * , \"two        = \" , two print * , \"one_third  = \" , one_third print * , \"tiny       = \" , tiny print * , \"tin        = \" , tin print * print * , \"4*ATAN     = \" , 4.d0 * datan ( 1.d0 ) print * , \"pi         = \" , pi print * , \"pi2        = \" , pi2 print * , \"pi4        = \" , pi4 print * , \"piq        = \" , piq print * print * , \"talfa      = \" , talfa print * , \"zalfa      = \" , zalfa print * , \"xmalfa     = \" , xmalfa print * , \"clt        = \" , clt print * print * , \"pme_e      = \" , pme_e print * , \"pme        = \" , pme print * , \"9.11d-28   = \" , 9.11d-28 print * , \"pqe        = \" , pqe print * , \"xlog       = \" , xlog print * , \"c0         = \" , c0 print * , \"c1         = \" , c1 print * , \"xsgs       = \" , xsgs print * , \"xwtt       = \" , xwtt print * print * , \"cnst1  = \" , cnst1 print * , \"cnst2  = \" , cnst2 print * , '---------------------------------------' end subroutine show_constants end module constants","tags":"","loc":"sourcefile\\1_constants.f90.html"},{"title":"1_lock_module.f90 – FRTС project","text":"Contents Modules lock_module Source Code 1_lock_module.f90 Source Code module lock_module use kind_module implicit none contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine linf ( x , y , t , fout , klo , khi ) !! линейная аппроксимация !! TODO будет удобнее если переделать в функцию implicit none real ( wp ), intent ( in ) :: x ( * ), y ( * ), t real ( wp ), intent ( out ) :: fout integer , intent ( in ) :: klo , khi real ( wp ) :: dout dout = ( y ( khi ) - y ( klo )) / ( x ( khi ) - x ( klo )) fout = y ( klo ) + dout * ( t - x ( klo )) end subroutine lock ( xa , n , x , klo , khi , ierr ) !! что делает? implicit none real ( wp ), intent ( in ) :: xa ( * ), x integer , intent ( in ) :: n integer , intent ( inout ) :: klo , khi , ierr real ( wp ), parameter :: tiny = 1.d-14 integer :: k real ( wp ) :: dx1 , dx2 klo = 0 khi = 0 dx1 = x - xa ( 1 ) dx2 = x - xa ( n ) if ( dx1 * dx2 . ge . tiny ) then ierr = 1 return end if ierr = 0 klo = 1 khi = n do while ( khi - klo . gt . 1 ) k = ( khi + klo ) / 2 if ( xa ( k ). gt . x ) then khi = k else klo = k endif end do if ( khi . eq . klo ) ierr = 1 end subroutine lock2 ( xa , n , x , klo , khi , ierr ) !! что делает use constants , only : zero implicit none real ( wp ), intent ( in ) :: xa ( * ), x integer , intent ( in ) :: n integer , intent ( inout ) :: klo , khi , ierr real ( wp ), parameter :: tiny = 1.d-7 integer :: k real ( wp ) :: dx1 , dx2 ierr = 0 klo = 0 khi = 0 dx1 = x - xa ( 1 ) if ( abs ( dx1 ). lt . tiny ) then klo = 1 khi = 2 return else if ( dx1 . lt . zero ) then ierr = 1 return end if dx2 = x - xa ( n ) if ( abs ( dx2 ). lt . tiny ) then klo = n - 1 khi = n return else if ( dx2 . gt . zero ) then ierr = 2 return end if klo = 1 khi = n do while ( khi - klo . gt . 1 ) k = ( khi + klo ) / 2 if ( xa ( k ). gt . x ) then khi = k else klo = k endif end do if ( khi . eq . klo ) ierr = 3 end end module lock_module","tags":"","loc":"sourcefile\\1_lock_module.f90.html"},{"title":"1_maxwell.f90 – FRTС project","text":"Contents Modules maxwell Source Code 1_maxwell.f90 Source Code module maxwell !! Все что относится к распределению Максвелла use kind_module use constants , only : zero , pisqrt , pi2sqrt , pqe implicit none integer , parameter :: i0 = 1002 real ( wp ) v_grid ( i0 , 100 ) !! сетка обычных скоростей real ( wp ) vij ( i0 , 100 ), fij0 ( i0 , 100 , 2 ), fij ( i0 , 100 , 2 ) real ( wp ) dfij ( i0 , 100 , 2 ), dij ( i0 , 100 , 2 ) logical flag_d0 !! бывший d0 integer jindex , kindex !!common/dddql/ d0,jindex,kindex contains function currlhcd ( v , f ) result ( curs ) implicit none real ( wp ), intent ( in ) :: v (:), f (:) real ( wp ) curs integer i0 , k real ( wp ) vl , vr , fl , fr curs = 0.d0 i0 = size ( v ) do k = 1 , i0 - 1 vl = v ( k ) vr = v ( k + 1 ) fl = f ( k ) fr = f ( k + 1 ) curs = curs + ( fl * vl + fr * vr ) / 2 d0 * ( vr - vl ) end do end function create_vt_grid ( vclt ) result ( vt_grid ) !! создание сетки тепловых скоростей implicit none real ( wp ), intent ( in ) :: vclt real ( wp ) :: vt_grid ( i0 ) real ( wp ) vmax integer i !r=dble(j)/dble(nr+1) !vclt=3.d10/fvt(r) vmax = 2.d0 * vclt do i = 1 , i0 vt_grid ( i ) = dble ( i - 1 ) * vmax / dble ( i0 - 1 ) end do end function subroutine init_vi ( vclt , vi ) real ( wp ), intent ( in ) :: vclt real ( wp ), intent ( out ) :: vi ( i0 ) real ( wp ) vmax integer i vmax = 2.d0 * vclt do i = 1 , i0 vi ( i ) = dble ( i - 1 ) * vmax / dble ( i0 - 1 ) end do end subroutine subroutine init_fmaxw_classic ( vclt , enorm , fi , dfi ) real ( wp ), intent ( in ) :: vclt , enorm real ( wp ), intent ( out ) :: fi ( i0 ), dfi ( i0 ) real ( wp ) vi , vmax integer i vmax = 2.d0 * vclt do i = 1 , i0 vi = dble ( i - 1 ) * vmax / dble ( i0 - 1 ) if ( vi < vclt ) then fi ( i ) = fmaxw_classic ( vi , enorm , dfi ( i )) else fi ( i ) = zero dfi ( i ) = zero end if end do end subroutine subroutine init_fmaxw_ext ( vclt , enorm , fi , dfi ) real ( wp ), intent ( in ) :: vclt , enorm real ( wp ), intent ( out ) :: fi ( i0 ), dfi ( i0 ) real ( wp ) vi , vmax integer i vmax = 2.d0 * vclt do i = 1 , i0 vi = dble ( i - 1 ) * vmax / dble ( i0 - 1 ) if ( vi < vclt ) then fi ( i ) = fmaxw_ext ( vi , enorm , dfi ( i )) else fi ( i ) = zero dfi ( i ) = zero end if end do end subroutine real ( wp ) function funmaxwell ( v , dfunmaxwell ) !! распределение Максвелла !!  f(v) = \\frac{1}{\\sqrt{2\\pi}} \\exp(-\\frac{1}{2} v&#94;2 )) !! и его производная !!  dfmaxw = - v \\cdot f(v)  implicit none real ( wp ) v , dfunmaxwell , arg arg = - 0.5d0 * v ** 2 funmaxwell = exp ( arg ) / pi2sqrt dfunmaxwell = - v * funmaxwell end real ( wp ) function fmaxw_classic ( v , alfa2 , dfmaxw ) !! распределение Максвелла с альфа-частицами !!  f(v) = \\frac{1}{\\sqrt{2\\pi}} \\exp(-\\frac{1}{2} v&#94;2 (1.0 + \\frac{1}{2} \\cdot alfa_2 \\cdot v&#94;2)) !! и его производная !!  dfmaxw = - v \\cdot (1.0 + alfa_2 \\cdot v&#94;2) \\cdot f(v)  implicit none real ( wp ) v , alfa2 , dfmaxw real ( wp ) arg , alfa , api , b , psiq , f , df arg =- 0.5d0 * v ** 2 * ( 1.d0 + 0.5d0 * alfa2 * v ** 2 ) fmaxw_classic = dexp ( arg ) / pi2sqrt dfmaxw =- v * ( 1.d0 + alfa2 * v ** 2 ) * fmaxw_classic end real ( wp ) function fmaxw_ext ( v , alfa2 , dfmaxw ) !!  alfa = \\sqrt{alfa_2}  !!  api = 2 \\cdot alfa \\cdot \\exp({-\\frac{1}{4 alfa_2}})  !!  b = 2 - erf(0.5/alfa) + api  !!  f = psiq(v, alfa_2)  !!  fmaxw = \\frac{f+api}{b \\sqrt{2\\pi}}  implicit none real ( wp ) v , alfa2 , dfmaxw real ( wp ) arg , alfa , api , b , f , df alfa = dsqrt ( alfa2 ) api = 2.d0 * alfa * dexp ( - 0.25d0 / alfa2 ) / pisqrt b = 2.d0 - erfcc ( 0.5d0 / alfa ) + api f = psiq ( v , alfa2 ) fmaxw_ext = ( f + api ) / b / pi2sqrt df =- v * (( 1.d0 - alfa2 * v ** 2 ) * f + api ) dfmaxw = df / b / pi2sqrt end real ( wp ) function fmaxw ( v , alfa2 , dfmaxw ) implicit none real ( wp ) v , alfa2 , dfmaxw real ( wp ) arg , alfa , api , b , f , df if ( alfa2 . le . zero ) then arg =- 0.5d0 * v ** 2 * ( 1.d0 - 0.5d0 * alfa2 * v ** 2 ) fmaxw = dexp ( arg ) / pi2sqrt dfmaxw =- v * ( 1.d0 - alfa2 * v ** 2 ) * fmaxw else alfa = dsqrt ( alfa2 ) api = 2.d0 * alfa * dexp ( - 0.25d0 / alfa2 ) / pisqrt b = 2.d0 - erfcc ( 0.5d0 / alfa ) + api f = psiq ( v , alfa2 ) fmaxw = ( f + api ) / b / pi2sqrt df =- v * (( 1.d0 - alfa2 * v ** 2 ) * f + api ) dfmaxw = df / b / pi2sqrt end if end real ( wp ) function psiq ( v , alfa2 ) !!  psiq=exp(ksiV**2)*erfcc(ksiV)*exp(-0.25/alfa2)  implicit none real ( wp ) v , alfa2 , df real ( wp ) x , t , z , f , asymp , alfa , q , u real ( wp ), parameter :: zmax = 1 0.d0 alfa = dsqrt ( alfa2 ) q =- 0.25d0 / alfa2 x = 0.5d0 * ( alfa * v ** 2 - 1.d0 / alfa ) z = abs ( x ) if ( z . gt . zmax ) then !asymptotics f = dexp ( q ) * ( 1.d0 - 0.5d0 / z ** 2 + 0.75d0 / z ** 4 - 1 5.d0 / 8.d0 / z ** 6 ) / z / pisqrt else t = 1.d0 / ( 1.d0 + 0.5d0 * z ) f = t * exp ( q - 1.26551223d0 + t * ( 1.00002368d0 + t * (. 37409196 d0 + t * & &(. 09678418 d0 + t * ( - . 18628806 d0 + t * (. 27886807 d0 + t * ( - 1.13520398d0 + t * & &( 1.48851587d0 + t * ( - . 82215223 d0 + t * . 17087277 d0 ))))))))) end if if ( x . lt . zero ) then u =- 0.5d0 * v ** 2 + 0.25d0 * alfa2 * v ** 4 !u=x**2-0.25d0/alfa2 f = 2.d0 * dexp ( u ) - f end if psiq = f return end function erfcc ( x ) implicit none real ( wp ) erfcc , x real ( wp ) t , z real ( wp ), parameter :: zmax = 1 0.d0 z = abs ( x ) if ( z . gt . zmax ) then !asymptotics erfcc = ( 1.d0 - 0.5d0 / z ** 2 + 0.75d0 / z ** 4 - 1 5.d0 / 8.d0 / z ** 6 ) / z / pisqrt erfcc = exp ( - z * z ) * erfcc else t = 1.d0 / ( 1.d0 + 0.5d0 * z ) erfcc = t * exp ( - z * z - 1.26551223d0 + t * ( 1.00002368d0 + t * (. 37409196 d0 + t * & &(. 09678418 d0 + t * ( - . 18628806 d0 + t * (. 27886807 d0 + t * ( - 1.13520398d0 + t * & &( 1.48851587d0 + t * ( - . 82215223 d0 + t * . 17087277 d0 ))))))))) end if if ( x . lt . zero ) erfcc = 2.d0 - erfcc return end end module maxwell","tags":"","loc":"sourcefile\\1_maxwell.f90.html"},{"title":"1_rt_parameters.f90 – FRTС project","text":"Contents Modules rt_parameters Source Code 1_rt_parameters.f90 Source Code module rt_parameters use kind_module implicit none !   physical parameters real ( wp ) :: freq !! Freq,     RF frequency, GHz real ( wp ) :: xmi1 !!  Mi1/Mp,  relative mass of ions 1 real ( wp ) :: zi1 !! charge of ions 1 real ( wp ) :: xmi2 !! Mi2/Mp,  relative mass of ions 2 real ( wp ) :: zi2 !! charge of ions 2 real ( wp ) :: dni2 !!  0.03   Ni2/Ni1, relative density of ions 2 real ( wp ) :: xmi3 !!  Mi3/Mp,  relative mass of ions 3 real ( wp ) :: zi3 !!  charge of ions 3 real ( wp ) :: dni3 !!  Ni3/Ni1, relative density of ions 3 !!!!!!!!!!!!!  parameters for alphas calculations !!! integer :: itend0 !! itend0,   if = 0, no alphas real ( wp ) :: energy !! energy,   max. perp. energy of alphas (MeV) real ( wp ) :: factor !! factor,   factor in alpha source real ( wp ) :: dra !! dra,      relative alpha source broadening (dr/a) integer :: kv !! kv,       V_perp  greed number !!!!!!!!!!!!! numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer :: nr !! nr,  radial grid number  <= 505 real ( wp ) :: hmin1 !! hmin1, rel.(hr) min. step in the Fast comp. mode, <1.d0 real ( wp ) :: rrange !! rrange,   rel.(hr) size of a 'turning' point region, <1.d0 real ( wp ) :: eps !! eps,      accuracy real ( wp ) :: hdrob !! hdrob,    h4 correction, real ( wp ) :: cleft !! cleft,    left Vz plato border shift (<1) real ( wp ) :: cright !! cright,   right Vz plato border shift (>1) real ( wp ) :: cdel !! cdel,     (left part)/(Vz plato size) real ( wp ) :: rbord !! rbord,    relative radius of reflection, <1. real ( wp ) :: pchm !! pchm,     threshold between 'strong' and weak' absorption, <1. real ( wp ) :: pabs0 !! pabs,     part of remaining power interp. as absorption real ( wp ) :: pgiter !! pgiter,   relative accuracy to stop iterations integer :: ni1 !! ni1,      grid number in the left part of Vz plato integer :: ni2 !! ni2,      grid number in the right part of Vz plato integer :: niterat !! niterat,  maximal number of iterations integer :: nmaxm ( 4 ) !! nmaxm(1), permitted reflections at 0 iteration !! nmaxm(2), permitted reflections at 1 iteration !! nmaxm(3), permitted reflections at 2 iteration !! nmaxm(4), permitted reflections at 3 iteration integer :: maxstep2 !! maxstep2, maximal steps' number in Fast comp. mode integer :: maxstep4 !! maxstep4, maximal steps' number in Slow comp. mode !!!!!!!!!!!!!  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! integer :: ipri !! ipri, printing output monitoring: 0,1,2,3,4 integer :: iw !! iw, initial mode (slow=1, fast=-1) integer :: ismth !! ismth, if=0, no smoothing in Ne(rho),Te(rho),Ti(rho) integer :: ismthalf !! ismthalf,  if=0, no smoothing in D_alpha(vperp) integer :: ismthout !! ismthout,  if=0, no smoothing in output profiles integer :: inew !! inew=0 for usual tokamak&Ntor_grill; 1 or 2 for g' in ST&Npol_grill integer :: itor !! itor,      +-1, Btor direction in right coord{drho,dteta,dfi} integer :: i_pol !! ipol,      +-1, Bpol direction in right coord{drho,dteta,dfi} !!!!!!!!!!!!!  grill parameters and input LH spectrum !!!!!!!!!!!! real ( wp ) :: zplus !! Zplus,    upper grill corner in centimeters real ( wp ) :: zminus !! Zminus,   lower grill corner in centimeters integer :: ntet !! ntet,     theta grid number integer :: nnz !! nnz,      N_phi grid number integer :: spectrum_type !! spectrum type 1 - 1D, 2 = 2D, 3, scatter contains subroutine show_parameters () print * , \"Freq = \" , freq print * , \"xmi1 = \" , xmi1 print * , \"zi1 = \" , zi1 print * , \"xmi2 = \" , xmi2 print * , \"zi2 = \" , zi2 print * , \"dni2 = \" , dni2 print * , \"---------- grill parameters and input LH spectrum \" print * , \"zplus = \" , zplus print * , \"zminus = \" , zminus print * , \"ntet = \" , ntet print * , \"nnz = \" , nnz end subroutine show_parameters subroutine read_parameters ( file_name ) implicit none integer , parameter :: iunit = 20 character ( * ) file_name print * , file_name open ( iunit , file = file_name ) !!!!!!!!!!!!!  read  physical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) freq read ( iunit , * ) xmi1 read ( iunit , * ) zi1 read ( iunit , * ) xmi2 read ( iunit , * ) zi2 read ( iunit , * ) dni2 read ( iunit , * ) xmi3 read ( iunit , * ) zi3 read ( iunit , * ) dni3 !!!!!!!!!!!!!  read parameters for alphas calculation !!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) itend0 read ( iunit , * ) energy read ( iunit , * ) factor read ( iunit , * ) dra read ( iunit , * ) kv !!!!!!!!!!!!!  read  numerical parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) nr read ( iunit , * ) hmin1 read ( iunit , * ) rrange read ( iunit , * ) eps read ( iunit , * ) hdrob read ( iunit , * ) cleft read ( iunit , * ) cright read ( iunit , * ) cdel read ( iunit , * ) rbord read ( iunit , * ) pchm read ( iunit , * ) pabs0 read ( iunit , * ) pgiter read ( iunit , * ) ni1 read ( iunit , * ) ni2 read ( iunit , * ) niterat read ( iunit , * ) nmaxm ( 1 ) read ( iunit , * ) nmaxm ( 2 ) read ( iunit , * ) nmaxm ( 3 ) read ( iunit , * ) nmaxm ( 4 ) read ( iunit , * ) maxstep2 read ( iunit , * ) maxstep4 !!!!!!!!!!!!!  read  options !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) ipri read ( iunit , * ) iw read ( iunit , * ) ismth read ( iunit , * ) ismthalf read ( iunit , * ) ismthout read ( iunit , * ) inew read ( iunit , * ) itor !Btor direction in right-hand {drho,dteta,dfi} read ( iunit , * ) i_pol !Bpol direction in right-hand {drho,dteta,dfi} !!!!!!!!!!!!!  read grill parameters and input LH spectrum !!!!!!!!!!!! read ( iunit , * ) read ( iunit , * ) zplus read ( iunit , * ) zminus read ( iunit , * ) ntet read ( iunit , * ) nnz read ( iunit , * ) spectrum_type close ( iunit ) print * , 'checking initial parameters' !!!!!!!!!!!!! checking initial parameters !!!!!!!!!!!!!!!!!!!!!!!!!!!!! if ( kv . gt . 50 ) kv = 50 if ( nr . gt . 100 ) nr = 100 if ( ni1 . eq . 0 ) ni1 = 20 if ( ni2 . eq . 0 ) ni2 = 20 if ( ni1 + ni2 . gt . 100 ) then ni1 = 60 ni2 = 40 end if if ( nnz * ntet . gt . 10000 ) then nnz = 250 ntet = 40 pause 'nnz and ntet changed, because nnz*ntet>10000' end if call show_parameters end subroutine read_parameters end module rt_parameters","tags":"","loc":"sourcefile\\1_rt_parameters.f90.html"},{"title":"1_runge_kutta.f90 – FRTС project","text":"Contents Modules runge_kutta_module Source Code 1_runge_kutta.f90 Source Code module runge_kutta_module use kind_module implicit none abstract interface !    subroutine extd4(x,y,dydx) !    dimension y(*),dydx(*) subroutine Iderivs_func ( x , y , dydx ) import :: wp implicit none real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y (:) real ( wp ), intent ( inout ) :: dydx (:) end subroutine end  interface contains !---------------------------------------------------------------- subroutine rkqc ( y , dydx , n , x , htry , eps , yscal , hdid , hnext , derivs ) use constants , only : one real ( wp ), intent ( inout ) :: y ( n ) real ( wp ), intent ( inout ) :: dydx ( n ) integer , intent ( in ) :: n real ( wp ), intent ( inout ) :: x real ( wp ), intent ( in ) :: htry , eps real ( wp ), intent ( in ) :: yscal ( n ) real ( wp ), intent ( inout ) :: hdid , hnext procedure ( Iderivs_func ) :: derivs !external derivs integer , parameter :: nmax = 10 real ( wp ), parameter :: fcor = . 0666666667 d0 , safety = 0.9d0 , errcon = 6.d-4 integer :: i real ( wp ) :: ytemp ( nmax ), ysav ( nmax ), dysav ( nmax ) real ( wp ) :: pgrow , pshrnk , xsav real ( wp ) :: h , hh , errmax , v print * , 'start rkqc' pgrow =- 0.20d0 pshrnk =- 0.25d0 xsav = x do i = 1 , n ysav ( i ) = y ( i ) dysav ( i ) = dydx ( i ) enddo h = htry 1 hh = 0.5d0 * h call rk4 ( ysav , dysav , n , xsav , hh , ytemp , derivs ) x = xsav + hh call derivs ( x , ytemp , dydx ) call rk4 ( ytemp , dydx , n , x , hh , y , derivs ) x = xsav + h if ( x . eq . xsav ) then write ( * , * ) ' stepsize not significant in rkqc' write ( * , * ) 'xsav=' , xsav , ' h=' , h , ' htry=' , htry write ( * , 88 ) y , dydx pause end if 88 format ( 1 x , 10 ( e14 . 7 , 1 x )) call rk4 ( ysav , dysav , n , xsav , h , ytemp , derivs ) errmax = 0.d0 do i = 1 , n v = ytemp ( i ) ytemp ( i ) = y ( i ) - ytemp ( i ) errmax = dmax1 ( errmax , dabs ( ytemp ( i ) / yscal ( i ))) enddo errmax = errmax / eps if ( errmax . gt . one ) then h = safety * h * ( errmax ** pshrnk ) goto 1 else hdid = h if ( errmax . gt . errcon ) then hnext = safety * h * ( errmax ** pgrow ) else hnext = 4.d0 * h endif endif do i = 1 , n y ( i ) = y ( i ) + ytemp ( i ) * fcor enddo return end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine rk4 ( y , dydx , n , x , h , yout , derivs ) implicit real * 8 ( a - h , o - z ) integer , intent ( in ) :: n procedure ( Iderivs_func ) :: derivs integer nmax , i parameter ( nmax = 10 ) dimension y ( n ), dydx ( n ), yout ( n ), yt ( nmax ), dyt ( nmax ), dym ( nmax ) hh = h * 0.5d0 h6 = h / 6.d0 xh = x + hh do i = 1 , n yt ( i ) = y ( i ) + hh * dydx ( i ) enddo call derivs ( xh , yt , dyt ) dv1 = dyt ( 3 ) do i = 1 , n yt ( i ) = y ( i ) + hh * dyt ( i ) enddo call derivs ( xh , yt , dym ) do i = 1 , n yt ( i ) = y ( i ) + h * dym ( i ) dym ( i ) = dyt ( i ) + dym ( i ) enddo call derivs ( x + h , yt , dyt ) do i = 1 , n yout ( i ) = y ( i ) + h6 * ( dydx ( i ) + dyt ( i ) + 2.d0 * dym ( i )) enddo end !sav2008: below this line there are new subroutins and functions ! пришлось переименовать из rkqs - почему-то криво линковался subroutine runge_kutta_qs ( y , dydx , n , x , htry , eps , yscal , hdid , hnext , derivs ) !! метод рунге-кутта implicit none real ( wp ), intent ( inout ) :: y ( n ) real ( wp ), intent ( inout ) :: dydx ( n ) integer , intent ( in ) :: n real ( wp ), intent ( inout ) :: x real ( wp ), intent ( in ) :: htry , eps real ( wp ), intent ( in ) :: yscal ( n ) real ( wp ), intent ( inout ) :: hdid , hnext procedure ( Iderivs_func ) :: derivs !external derivs !integer,  parameter :: nmax = 50 real ( wp ), parameter :: safety = 0.9d0 , pgrow =- . 2 d0 , pshrnk =- . 25 d0 , errcon = 1.89d-4 integer :: i real ( wp ) :: ytemp ( n ), ysav ( n ), dysav ( n ), yerr ( n ) real ( wp ) :: xsav real ( wp ) :: h , htemp , errmax , xnew h = htry 1 call rkck ( y , dydx , n , x , h , ytemp , yerr , derivs ) errmax = 0.d0 do i = 1 , n errmax = max ( errmax , abs ( yerr ( i ) / yscal ( i ))) enddo errmax = errmax / eps if ( errmax . gt . 1.d0 ) then htemp = safety * h * ( errmax ** pshrnk ) h = sign ( max ( abs ( htemp ), 0.1d0 * abs ( h )), h ) xnew = x + h if ( xnew . eq . x ) pause 'stepsize underflow in rkqs' goto 1 else if ( errmax . gt . errcon ) then hnext = safety * h * ( errmax ** pgrow ) else hnext = 5.d0 * h endif hdid = h x = x + h do i = 1 , n y ( i ) = ytemp ( i ) enddo return endif end subroutine rkck ( y , dydx , n , x , h , yout , yerr , derivs ) !!  метод рунге-кутта, нужны подробности implicit none real ( wp ), intent ( in ) :: y ( n ) real ( wp ), intent ( in ) :: dydx ( n ) integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: h real ( wp ), intent ( out ) :: yerr ( n ) real ( wp ), intent ( out ) :: yout ( n ) procedure ( Iderivs_func ) :: derivs !external derivs !parameter (nmax=50) !cu    uses derivs integer i real ( wp ) ak2 ( n ), ak3 ( n ), ak4 ( n ), ak5 ( n ), ak6 ( n ), ytemp ( n ) real ( wp ) a2 , a3 , a4 , a5 , a6 , b21 , b31 , b32 , b41 , b42 , b43 , b51 , b52 , b53 , & b54 , b61 , b62 , b63 , b64 , b65 , c1 , c3 , c4 , c6 , dc1 , dc3 , dc4 , dc5 , dc6 parameter ( a2 = . 2 d0 , a3 = . 3 d0 , a4 = . 6 d0 , a5 = 1.d0 , a6 = . 875 d0 , b21 = . 2 d0 , b31 = 3.d0 / 4 0.d0 , & b32 = 9.d0 / 4 0.d0 , b41 = . 3 d0 , b42 =- . 9 d0 , b43 = 1.2d0 , b51 =- 1 1.d0 / 5 4.d0 , b52 = 2.5d0 , & b53 =- 7 0.d0 / 2 7.d0 , b54 = 3 5.d0 / 2 7.d0 , b61 = 163 1.d0 / 5529 6.d0 , b62 = 17 5.d0 / 51 2.d0 , & b63 = 57 5.d0 / 1382 4.d0 , b64 = 4427 5.d0 / 11059 2.d0 , b65 = 25 3.d0 / 409 6.d0 , c1 = 3 7.d0 / 37 8.d0 , & c3 = 25 0.d0 / 62 1.d0 , c4 = 12 5.d0 / 59 4.d0 , c6 = 51 2.d0 / 177 1.d0 , dc1 = c1 - 282 5.d0 / 2764 8.d0 , & dc3 = c3 - 1857 5.d0 / 4838 4.d0 , dc4 = c4 - 1352 5.d0 / 5529 6.d0 , dc5 =- 27 7.d0 / 1433 6.d0 , dc6 = c6 - . 25 d0 ) do i = 1 , n ytemp ( i ) = y ( i ) + b21 * h * dydx ( i ) enddo call derivs ( x + a2 * h , ytemp , ak2 ) do i = 1 , n ytemp ( i ) = y ( i ) + h * ( b31 * dydx ( i ) + b32 * ak2 ( i )) enddo call derivs ( x + a3 * h , ytemp , ak3 ) do i = 1 , n ytemp ( i ) = y ( i ) + h * ( b41 * dydx ( i ) + b42 * ak2 ( i ) + b43 * ak3 ( i )) enddo call derivs ( x + a4 * h , ytemp , ak4 ) do i = 1 , n ytemp ( i ) = y ( i ) + h * ( b51 * dydx ( i ) + b52 * ak2 ( i ) + b53 * ak3 ( i ) + b54 * ak4 ( i )) enddo call derivs ( x + a5 * h , ytemp , ak5 ) do i = 1 , n ytemp ( i ) = y ( i ) + h * ( b61 * dydx ( i ) + b62 * ak2 ( i ) + b63 * ak3 ( i ) + b64 * ak4 ( i ) + b65 * ak5 ( i )) enddo call derivs ( x + a6 * h , ytemp , ak6 ) do i = 1 , n yout ( i ) = y ( i ) + h * ( c1 * dydx ( i ) + c3 * ak3 ( i ) + c4 * ak4 ( i ) + c6 * ak6 ( i )) enddo do i = 1 , n yerr ( i ) = h * ( dc1 * dydx ( i ) + dc3 * ak3 ( i ) + dc4 * ak4 ( i ) + dc5 * ak5 ( i ) + dc6 * ak6 ( i )) enddo return end end module runge_kutta_module","tags":"","loc":"sourcefile\\1_runge_kutta.f90.html"},{"title":"1_savelyev_solver.f90 – FRTС project","text":"Contents Modules savelyev_solver_module Source Code 1_savelyev_solver.f90 Source Code module savelyev_solver_module use kind_module implicit none PRIVATE :: q , k , d contains subroutine savelyev_solver ( alfa2 , nt , h , dt , n , ybeg , yend , d1 , d2 , d3 , y ) !! разностная схема Савельева для уравнения Фоккера-Планка implicit none real ( wp ), intent ( in ) :: alfa2 integer , intent ( in ) :: nt , n real ( wp ), intent ( in ) :: h , dt real ( wp ), intent ( in ) :: ybeg , yend real ( wp ), intent ( in ) :: d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 ) real ( wp ), intent ( inout ) :: y ( n ) integer i , it real ( wp ) xx ( n + 1 ), a ( n ), b ( n ), c ( n ), f ( n ) do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do it = 1 , nt call savelyev_abccoef ( alfa2 , a , b , c , f , y , dt , n , ybeg , yend , xx , h , d1 , d2 , d3 ) call tridag ( a , b , c , f , y , n ) end do end subroutine subroutine savelyev_abccoef ( alfa2 , a , b , c , f , y , dt , n , ybeg , yend , xx , h , d1 , d2 , d3 ) !! -- fill abc matrix implicit none real ( wp ), intent ( in ) :: alfa2 real ( wp ), intent ( inout ) :: a ( n ), b ( n ), c ( n ), f ( n ), y ( n ) real ( wp ), intent ( in ) :: dt integer , intent ( in ) :: n real ( wp ), intent ( in ) :: ybeg , yend , h real ( wp ), intent ( in ) :: xx ( n + 1 ) real ( wp ), intent ( in ) :: d1 ( n + 1 ), d2 ( n + 1 ), d3 ( n + 1 ) integer i , iunit , iunit2 real ( wp ) a1 ( n ), b1 ( n ), c1 ( n ), f1 ( n ), a2 ( n ), b2 ( n ), c2 ( n ), f2 ( n ) !real(wp) kinv,rs,rmink,rplusk,q,qf,r1,rmink2,rplusk2,kinv2 real ( wp ) r , kappa , sum , bmin , bplus , sum2 , sum3 , sum4 real ( wp ) dc , as ( n + 1 ) !external kinv,rs,rmink,rplusk,q,kinv2,rmink2,rplusk2,d sum = ( kinv ( xx ( 1 ) - h / 2 d0 , d2 ( 1 )) + kinv ( xx ( 1 ) + h / 2 d0 , d3 ( 1 ))) * h / 2 d0 as ( 1 ) = h / sum sum = ( kinv ( xx ( 2 ) - h / 2 d0 , d2 ( 2 )) + kinv ( xx ( 2 ) + h / 2 d0 , d3 ( 2 ))) * h / 2 d0 as ( 2 ) = h / sum r = h / 2 d0 * dabs ( rs ( xx ( 1 ) + h / 2 d0 , alfa2 )) / k ( xx ( 1 ) + h / 2 d0 , d3 ( 1 )) kappa = 1 d0 / ( 1 d0 + r ) sum = ( rmink ( xx ( 1 ), d1 ( 1 ), alfa2 ) + rmink ( xx ( 2 ), d1 ( 2 ), alfa2 )) * h / 2 d0 bmin = sum / h sum = ( rplusk ( xx ( 1 ), d1 ( 1 ), alfa2 ) + rplusk ( xx ( 2 ), d1 ( 2 ), alfa2 )) * h / 2 d0 bplus = sum / h sum = qf ( xx ( 2 )) - qf ( xx ( 1 )) dc = sum / h a ( 1 ) = as ( 1 ) * ( kappa / h ** 2 - bmin / h ) c ( 1 ) = as ( 2 ) * ( kappa / h ** 2 + bplus / h ) b ( 1 ) = - ( 1 d0 / dt + a ( 1 ) + c ( 1 ) + dc ) f ( 1 ) = - y ( 1 ) / dt - a ( 1 ) * ybeg do i = 2 , n sum = ( kinv ( xx ( i + 1 ) - h / 2 d0 , d2 ( i + 1 )) + kinv ( xx ( i + 1 ) + h / 2 d0 , d3 ( i + 1 ))) sum = sum * h / 2 d0 as ( i + 1 ) = h / sum r = h / 2 d0 * dabs ( rs ( xx ( i ) + h / 2 d0 , alfa2 )) / k ( xx ( i ) + h / 2 d0 , d3 ( i )) kappa = 1 d0 / ( 1 d0 + r ) sum = ( rmink ( xx ( i ), d1 ( i ), alfa2 ) + rmink ( xx ( i + 1 ), d1 ( i + 1 ), alfa2 )) * h / 2 d0 bmin = sum / h sum = ( rplusk ( xx ( i ), d1 ( i ), alfa2 ) + rplusk ( xx ( i + 1 ), d1 ( i + 1 ), alfa2 )) * h / 2 d0 bplus = sum / h sum = qf ( xx ( i + 1 )) - qf ( xx ( i )) dc = sum / h a ( i ) = as ( i ) * ( kappa / h ** 2 - bmin / h ) c ( i ) = as ( i + 1 ) * ( kappa / h ** 2 + bplus / h ) b ( i ) = - ( 1 d0 / dt + a ( i ) + c ( i ) + dc ) f ( i ) = - y ( i ) / dt end do f ( n ) = f ( n ) - c ( n ) * yend a ( 1 ) = 0 d0 c ( n ) = 0 d0 end real ( wp ) function rplusk ( x , dif , alfa2 ) implicit none real ( wp ), intent ( in ) :: x , dif real ( wp ), intent ( in ) :: alfa2 rplusk = 0.5d0 * ( rs ( x , alfa2 ) + dabs ( rs ( x , alfa2 ))) / k ( x , dif ) end real ( wp ) function rplusk2 ( x , dif , alfa2 ) implicit none real ( wp ), intent ( in ) :: x , dif real ( wp ), intent ( in ) :: alfa2 rplusk2 = 0.5d0 * ( rs ( x , alfa2 ) + dabs ( rs ( x , alfa2 ))) / k2 ( x , dif ) end real ( wp ) function rmink ( x , dif , alfa2 ) implicit none real ( wp ), intent ( in ) :: x , dif real ( wp ), intent ( in ) :: alfa2 rmink = 0.5d0 * ( rs ( x , alfa2 ) - dabs ( rs ( x , alfa2 ))) / k ( x , dif ) end real ( wp ) function rmink2 ( x , dif , alfa2 ) implicit none real ( wp ), intent ( in ) :: x , dif real ( wp ), intent ( in ) :: alfa2 rmink2 = 0.5d0 * ( rs ( x , alfa2 ) - dabs ( rs ( x , alfa2 ))) / k2 ( x , dif ) end real ( wp ) function rs ( x , alfa2 ) implicit none real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: alfa2 !common/ef/ alfa2 rs = 1 d0 / x ** 2 - alfa2 end real ( wp ) function q ( x ) implicit none real ( wp ), intent ( in ) :: x q = 2 d0 / x ** 3 end real ( wp ) function qf ( x ) implicit none real ( wp ), intent ( in ) :: x qf =- 1 d0 / x ** 2 end real ( wp ) function k ( x , dif ) implicit none real ( wp ), intent ( in ) :: x , dif k = dif + 1 d0 / x ** 3 end real ( wp ) function k2 ( x , dif ) implicit none real ( wp ), intent ( in ) :: x , dif k2 = d ( x ) + 1 d0 / x ** 3 end real ( wp ) function kinv ( x , dif ) implicit none real ( wp ), intent ( in ) :: x , dif kinv = x ** 3 / ( dif * x ** 3 + 1 d0 ) end real ( wp ) function kinv2 ( x , dif ) implicit none real ( wp ), intent ( in ) :: x , dif kinv2 = x ** 3 / ( d ( x ) * x ** 3 + 1 d0 ) end subroutine tridag ( a , b , c , r , u , n ) !! создает трехдиагональнйю матрицу implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: a ( n ), b ( n ), c ( n ), r ( n ) real ( wp ), intent ( inout ) :: u ( n ) integer , parameter :: nmax = 1000000 integer j real ( wp ) bet , gam ( nmax ) if ( b ( 1 ). eq . 0.d0 ) pause 'tridag: rewrite equations' bet = b ( 1 ) u ( 1 ) = r ( 1 ) / bet do j = 2 , n gam ( j ) = c ( j - 1 ) / bet bet = b ( j ) - a ( j ) * gam ( j ) if ( bet . eq . 0.d0 ) then write ( * , * ) 'b(j)=' , b ( j ), 'a(j)=' , a ( j ), 'gam(j)=' , gam ( j ) pause 'tridag failed' end if u ( j ) = ( r ( j ) - a ( j ) * u ( j - 1 )) / bet end do do j = n - 1 , 1 , - 1 u ( j ) = u ( j ) - gam ( j + 1 ) * u ( j + 1 ) end do end subroutine real ( wp ) function d ( x ) !! возможно одна из самых замедляющих функций use maxwell use lock_module implicit none !integer i0 !parameter(i0=1002) !real*8 vij,fij0,fij,dfij,dij,enorm,fst !common/lh/vij(i0,100),fij0(i0,100,2),fij(i0,100,2),dfij(i0,100,2),dij(i0,100,2),enorm(100),fst(100) real ( wp ), dimension (:), allocatable :: vvj , ddj integer klo , khi , ierr real ( wp ) x integer k , j , i !common/dddql/ d0,jindex,kindex d = zero if ( flag_d0 ) return j = jindex if ( x . ge . vij ( i0 , j )) return k = kindex allocate ( vvj ( i0 ), ddj ( i0 )) do i = 1 , i0 vvj ( i ) = vij ( i , j ) ddj ( i ) = dij ( i , j , k ) end do call lock ( vvj , i0 , x , klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , j , ' v=' , x write ( * , * ) 'vj(1)=' , vvj ( 1 ), ' vj(i0)=' , vvj ( i0 ) pause stop end if d = ddj ( klo ) deallocate ( vvj , ddj ) end end module savelyev_solver_module","tags":"","loc":"sourcefile\\1_savelyev_solver.f90.html"},{"title":"1_spline.f90 – FRTС project","text":"Contents Modules spline_module Source Code 1_spline.f90 Source Code module spline_module !! сплайны use kind_module implicit none contains subroutine splne ( x , y , n , y2 ) integer , parameter :: nn = 2001 real ( wp ), parameter :: zero = 0 d0 integer n real ( wp ) x ( n ), y ( n ), y2 ( n ), u ( nn ) integer i , k real ( wp ) p , qn , un , sig if ( n . gt . nn ) stop 'n>nn in splne!' y2 ( 1 ) = zero u ( 1 ) = zero do i = 2 , n - 1 sig = ( x ( i ) - x ( i - 1 )) / ( x ( i + 1 ) - x ( i - 1 )) p = sig * y2 ( i - 1 ) + 2.d0 y2 ( i ) = ( sig - 1.d0 ) / p u ( i ) = ( 6.d0 * (( y ( i + 1 ) - y ( i )) / ( x ( i + 1 ) - x ( i )) - ( y ( i ) - y ( i - 1 )) / ( x ( i ) - x ( i - 1 ))) / ( x ( i + 1 ) - x ( i - 1 )) - sig * u ( i - 1 )) / p end do qn = zero un = zero y2 ( n ) = ( un - qn * u ( n - 1 )) / ( qn * y2 ( n - 1 ) + 1.d0 ) do k = n - 1 , 1 , - 1 y2 ( k ) = y2 ( k ) * y2 ( k + 1 ) + u ( k ) end do return end subroutine splnt ( xa , ya , y2a , n , x , y , dy ) real ( wp ), parameter :: zero = 0 d0 integer n real ( wp ) xa ( n ), ya ( n ), y2a ( n ) integer k , klo , khi real ( wp ) x , h , a , b , aa , bb , hh , ax , bx , y , dy klo = 1 khi = n do while ( khi - klo . gt . 1 ) k = ( khi + klo ) / 2 if ( xa ( k ). gt . x ) then khi = k else klo = k endif end do h = xa ( khi ) - xa ( klo ) if ( h . eq . zero ) then write ( * , * ) 'bad x input in splnt(), x=' , x write ( * , * ) 'klo=' , klo , ' kho=' , khi stop end if a = ( xa ( khi ) - x ) / h b = ( x - xa ( klo )) / h aa = a ** 2 bb = b ** 2 hh = h ** 2 / 6 d0 ax =- 1 d0 / h bx =- ax y = a * ya ( klo ) + b * ya ( khi ) + ( a * ( aa - 1 d0 ) * y2a ( klo ) + b * ( bb - 1 d0 ) * y2a ( khi )) * hh dy = ax * ya ( klo ) + bx * ya ( khi ) + ax * (( 3.d0 * aa - 1 d0 ) * y2a ( klo ) - ( 3.d0 * bb - 1 d0 ) * y2a ( khi )) * hh end !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine dsplnt ( xa , ya , y2a , n , x , y , dy , ddy ) real ( wp ), parameter :: zero = 0 d0 integer n real ( wp ) xa ( n ), ya ( n ), y2a ( n ) integer k , klo , khi real ( wp ) x , h , a , b , aa , bb , hh , ax , bx , y , dy , ddy klo = 1 khi = n do while ( khi - klo . gt . 1 ) k = ( khi + klo ) / 2 if ( xa ( k ). gt . x ) then khi = k else klo = k endif end do h = xa ( khi ) - xa ( klo ) if ( h . eq . zero ) then write ( * , * ) 'bad x input in splnt(), x=' , x write ( * , * ) 'klo=' , klo , ' kho=' , khi stop end if a = ( xa ( khi ) - x ) / h b = ( x - xa ( klo )) / h aa = a ** 2 bb = b ** 2 hh = h ** 2 / 6 d0 ax =- 1 d0 / h bx =- ax y = a * ya ( klo ) + b * ya ( khi ) + ( a * ( aa - 1 d0 ) * y2a ( klo ) + b * ( bb - 1 d0 ) * y2a ( khi )) * hh dy = ax * ya ( klo ) + bx * ya ( khi ) + ax * (( 3.d0 * aa - 1 d0 ) * y2a ( klo ) - ( 3.d0 * bb - 1 d0 ) * y2a ( khi )) * hh ddy = 6.d0 * ax * ax * ( a * y2a ( klo ) + b * y2a ( khi )) * hh end end module spline_module","tags":"","loc":"sourcefile\\1_spline.f90.html"},{"title":"1_utils.f90 – FRTС project","text":"Contents Modules Utils Source Code 1_utils.f90 Source Code module Utils use kind_module contains function sys_time () ! ** return system time implicit none real ( wp ) sys_time integer count , count_rate , count_max call system_clock ( count , count_rate , count_max ) sys_time = count * 1.0 / count_rate return end end  module Utils","tags":"","loc":"sourcefile\\1_utils.f90.html"},{"title":"1_writer_module.f90 – FRTС project","text":"Contents Modules writer_module Source Code 1_writer_module.f90 Source Code module writer_module use kind_module implicit none contains subroutine write_v_array ( v , a , time , array_name ) !! сохраняет массивы расределения и скорости implicit none real ( wp ), intent ( in ) :: v (:,:) real ( wp ), intent ( in ) :: a (:,:,:) real ( wp ), intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name real ( wp ), allocatable :: gv (:), ga (:) integer i , N , nshape ( 3 ) character ( 120 ) fname integer , parameter :: iu = 21 if ( MOD ( INT ( time * 100000 ), 10 ) /= 0 ) then return end if nshape = shape ( a ) print * , 'write arr:' , array_name , nshape N = nshape ( 2 ) print * , N write ( fname , '(\"lhcd/\", A,\"/\", f9.7,\".dat\")' ) array_name , time print * , fname open ( iu , file = fname , position = \"append\" ) do i = 1 , N gv = glue_v_axis ( v (:, i )) write ( iu , '(2012(ES22.14))' ) gv (:) deallocate ( gv ) ga = glue_arrays ( a (:, i , 1 ), a (:, i , 2 )) write ( iu , '(2012(ES22.14))' ) ga (:) deallocate ( ga ) end do close ( iu ) contains function glue_v_axis ( a ) result ( g ) implicit none real ( wp ), intent ( in ) :: a (:) real ( wp ), allocatable :: g (:) integer i , N N = size ( a ) allocate ( g ( - N : N )) g ( - N : - 1 ) = - a ( N : 1 : - 1 ) g ( 1 : N ) = a (:) g ( 0 ) = 0 end function function glue_arrays ( a , b ) result ( g ) implicit none real ( wp ), intent ( in ) :: a (:), b (:) real ( wp ), allocatable :: g (:) integer i , N N = size ( a ) allocate ( g ( - N : N )) g ( - N : - 1 ) = a ( N : 1 : - 1 ) g ( 1 : N ) = b (:) g ( 0 ) = ( a ( 1 ) + b ( 1 )) / 2 d0 end function end subroutine subroutine write_x_array ( x , arr , time , array_name ) implicit none real ( wp ), intent ( in ) :: x (:,:) real ( wp ), intent ( in ) :: arr (:,:) real ( wp ), intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name integer i , N , nshape ( 2 ) character ( 120 ) fname integer , parameter :: iu = 21 nshape = shape ( arr ) print * , 'write arr:' , array_name , nshape N = nshape ( 2 ) print * , N write ( fname , '(\"lhcd/\", A,\"/xar\", f9.7,\".dat\")' ) array_name , time print * , fname open ( iu , file = fname , position = \"append\" ) do i = 1 , N write ( iu , '(2012(ES22.14))' ) x (: , i ) write ( iu , '(2012(ES22.14))' ) arr (:, i ) end do close ( iu ) end subroutine subroutine write_matrix ( arr , time , array_name ) implicit none real ( wp ), intent ( in ) :: arr (:,:) real ( wp ), intent ( in ) :: time character ( len =* ), intent ( in ) :: array_name integer i , N , nshape ( 2 ) character ( 120 ) fname integer , parameter :: iu = 21 nshape = shape ( arr ) print * , 'write_matrix:' , array_name , nshape N = nshape ( 1 ) print * , N write ( fname , '(\"lhcd/\", A,\"/\", f9.7,\".dat\")' ) array_name , time print * , fname open ( iu , file = fname , position = \"append\" ) do i = 1 , N write ( iu , ' ( I4.4, 100(ES21.14))' ) i , arr ( i , :) end do close ( iu ) end subroutine subroutine write_array ( arr , N , array_name ) implicit none real ( wp ), intent ( in ) :: arr ( * ) integer , intent ( in ) :: N character ( len =* ), intent ( in ) :: array_name integer i integer , parameter :: iunit = 21 character ( 80 ) fname print * , 'write_array:' , array_name , N write ( fname , '(\"lhcd/distribution/\", A,\".dat\")' ) array_name print * , fname open ( iunit , file = fname , position = \"append\" ) do i = 1 , n write ( iunit , * ) i , arr ( i ) end do close ( iunit ) end subroutine subroutine write_distribution ( arr , N , time ) implicit none real ( wp ), intent ( in ) :: arr ( * ) integer , intent ( in ) :: N real ( wp ), intent ( in ) :: time integer i integer itime integer , parameter :: iunit = 20 character ( 120 ) fname itime = INT ( time * 100000 ) !print *, N, time, itime, MOD(itime, 10) if ( MOD ( itime , 10 ) == 0 ) then write ( fname , '(\"lhcd/distribution/\", f9.7,\".dat\")' ) time !print *, fname open ( iunit , file = fname , position = \"append\" ) do i = 1 , N if ( arr ( i ) > 0 ) then write ( iunit , * ) i , arr ( i ) else exit end if end do close ( iunit ) end if end subroutine end module writer_module","tags":"","loc":"sourcefile\\1_writer_module.f90.html"},{"title":"2_driven_current_module.f90 – FRTС project","text":"Contents Modules driven_current_module Source Code 2_driven_current_module.f90 Source Code module driven_current_module !! Driven Current Module use kind_module implicit none type DrivenCurrent real ( wp ) :: cu !! ??  может лучше cuj real ( wp ) :: cu0 !! ??              cujoh real ( wp ) :: c !! ?? real ( wp ) :: c0 !! ?? real ( wp ), dimension (:), allocatable :: outj !! outj(i)  = LH driven current density, MA/m&#94;2 real ( wp ), dimension (:), allocatable :: ohj !! integer :: grid_size contains procedure :: evaluate => DrivenCurrent_evaluate end type interface DrivenCurrent module procedure :: DrivenCurrent_constructor end interface DrivenCurrent type DrivenCurrentResult real ( wp ) :: cup , cp !! real ( wp ) :: cum , cm !! real ( wp ) :: cup0 , cp0 !! real ( wp ) :: cum0 , cm0 !! contains procedure :: print => driven_current_result_print procedure :: save => driven_current_result_save end type DrivenCurrentResult interface DrivenCurrentResult module procedure :: DrivenCurrentResult_constructor end interface DrivenCurrentResult contains function DrivenCurrent_constructor ( size ) result ( this ) !- конструктор для DrivenCurrent implicit none type ( DrivenCurrent ) :: this integer , value :: size this % cu = 0 this % cu0 = 0 this % c = 0 this % c0 = 0 this % grid_size = size allocate ( this % outj ( size ), this % ohj ( size )) end function DrivenCurrent_constructor subroutine DrivenCurrent_evaluate ( this , ROC ) !- заключительное вычисление DrivenCurrent use constants , only : zero implicit none class ( DrivenCurrent ), intent ( inout ) :: this real ( wp ), intent ( in ) :: ROC external aiint real ( wp ) aiint integer :: i if ( this % cu0 . ne . zero ) then this % c0 = aiint ( this % ohj , ROC ) if ( this % c0 . ne . zero ) then do i = 1 , this % grid_size this % ohj ( i ) = this % cu0 * this % ohj ( i ) / this % c0 end do end if end if if ( this % cu . ne . zero ) then this % c = aiint ( this % outj , ROC ) if ( this % c . ne . zero ) then do i = 1 , this % grid_size this % outj ( i ) = this % cu * this % outj ( i ) / this % c end do end if end if end subroutine DrivenCurrent_evaluate function DrivenCurrentResult_constructor ( positive_dc , negative_dc ) result ( this ) !- конструктор для DrivenCurrentResult implicit none type ( DrivenCurrent ), intent ( in ) :: positive_dc type ( DrivenCurrent ), intent ( in ) :: negative_dc type ( DrivenCurrentResult ) :: this this % cup = positive_dc % cu this % cum = negative_dc % cu this % cp = positive_dc % c this % cm = negative_dc % c this % cup0 = positive_dc % cu0 this % cum0 = negative_dc % cu0 this % cp0 = positive_dc % c0 this % cm0 = negative_dc % c0 end function DrivenCurrentResult_constructor subroutine driven_current_result_print ( this , time ) class ( DrivenCurrentResult ), intent ( in ) :: this real ( wp ), intent ( in ) :: time print * , '------- driven current ---------' print * , 'time=' , time print * , 'cup=' , this % cup , ' cp=' , this % cp print * , 'cum=' , this % cum , ' cm=' , this % cm print * , 'cup0=' , this % cup0 , ' cp0=' , this % cp0 print * , 'cum0=' , this % cum0 , ' cm0=' , this % cm0 print * , 'sigma driven current, MA=' , this % cp0 + this % cm0 print * , 'driven current, MA=' , this % cup + this % cum print * , '--------------------------------' end subroutine driven_current_result_print subroutine driven_current_result_save ( this , time ) class ( DrivenCurrentResult ), intent ( in ) :: this real ( wp ), intent ( in ) :: time logical , save :: first_time = . TRUE . character ( 132 ) FNAME integer :: io FNAME = \"lhcd/dc_result.dat\" if ( first_time ) then open ( newunit = io , file = FNAME , status = \"replace\" , action = \"write\" ) write ( io , '(100A22)' ), \"Time\" , 'cup' , 'cp' , 'cum' , 'cm' , 'cup0' , 'cp0' , 'cum0' , 'cm0' close ( io ) first_time = . FALSE . else open ( newunit = io , file = FNAME , position = \"append\" ) write ( io , '(100f22.14)' ) time , this % cup , this % cp , this % cum , this % cm , this % cup0 , this % cp0 , this % cum0 , this % cm0 close ( io ) end if end subroutine driven_current_result_save end module driven_current_module","tags":"","loc":"sourcefile\\2_driven_current_module.f90.html"},{"title":"2_FokkerPlanck1D.f90 – FRTС project","text":"Contents Modules FokkerPlanck1D_mod Source Code 2_FokkerPlanck1D.f90 Source Code module FokkerPlanck1D_mod ! the module name defines the namespace !! модуль содержит функции для решения одномерного уравнения Фоккер-Планка use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 use savelyev_solver_module implicit none type FokkerPlanck1D !! solver of FP eq !integer          :: direction = 0 !- direction real ( dp ) :: enorm = 0 !! электрическое поле real ( dp ) :: v_lim = 0 !! верхняя граница скорости электронов real ( dp ), allocatable :: v (:) !! сетка скоростей real ( dp ), allocatable :: f (:) !! распределение integer :: i0 = 0 !! size of distribution grid real ( dp ) :: alfa2 = 0 !! поле со знаком integer :: n = 0 !! size of local grid real ( dp ) :: h = 0 !! step of local grid real ( dp ), allocatable :: d1 (:), d2 (:), d3 (:) !! диффузия contains procedure :: print => FokkerPlanck1D_print procedure :: solve_time_step => FokkerPlanck1D_solve_time_step procedure :: init_zero_diffusion => FokkerPlanck1D_init_zero_diffusion procedure :: init_diffusion => FokkerPlanck1D_init_diffusion end type FokkerPlanck1D interface FokkerPlanck1D module procedure :: FokkerPlanck1D_constructor end interface FokkerPlanck1D contains function FokkerPlanck1D_constructor ( e , v_lim , v , f ) result ( this ) !! конструктор для FokkerPlanck1D implicit none type ( FokkerPlanck1D ) :: this real ( dp ), value :: e , v_lim , v (:), f (:) integer :: n real ( dp ) :: h real ( dp ), parameter :: h0 = 0.1d0 !this%inst_field1 = cmplx(0.,0.) this % enorm = abs ( e ) this % v_lim = v_lim this % v = v this % f = f this % i0 = size ( v ) this % alfa2 = e n = v_lim / h0 - 1 h = v_lim / dble ( n + 1 ) if ( h . gt . h0 ) then n = n + 1 h = v_lim / dble ( n + 1 ) end if this % n = n this % h = h end function FokkerPlanck1D_constructor subroutine FokkerPlanck1D_print ( this ) class ( FokkerPlanck1D ), intent ( in ) :: this print * , 'e = ' , this % enorm , 'i0 =' , this % i0 end subroutine FokkerPlanck1D_print subroutine FokkerPlanck1D_init_zero_diffusion ( this ) implicit none class ( FokkerPlanck1D ), intent ( inout ) :: this integer :: n n = this % n allocate ( this % d1 ( n + 1 ), this % d2 ( n + 1 ), this % d3 ( n + 1 )) this % d1 (:) = 0 d0 this % d2 (:) = 0 d0 this % d3 (:) = 0 d0 end subroutine FokkerPlanck1D_init_zero_diffusion subroutine FokkerPlanck1D_init_diffusion ( this , dif ) !! инициализация диффузии для схемы савельева use lock_module implicit none class ( FokkerPlanck1D ), intent ( inout ) :: this integer :: n real ( dp ), dimension (:), intent ( in ) :: dif real ( dp ), dimension (:), allocatable :: xx real ( dp ) h integer :: i0 integer i , klo , khi , ierr , klo1 , khi1 integer klo2 , klo3 , khi2 , khi3 , ierr1 , ierr2 , ierr3 n = this % n h = this % h allocate ( this % d1 ( n + 1 ), this % d2 ( n + 1 ), this % d3 ( n + 1 )) i0 = this % i0 allocate ( xx ( n + 1 )) do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do i = 1 , n + 1 call lock ( this % v , i0 , xx ( i ), klo1 , khi1 , ierr1 ) call lock ( this % v , i0 , xx ( i ) - h / 2 d0 , klo2 , khi2 , ierr2 ) call lock ( this % v , i0 , xx ( i ) + h / 2 d0 , klo3 , khi3 , ierr3 ) if ( ierr1 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo1=' , klo1 , 'khi1=' , khi1 , 'i=' , i write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( i0 ) pause stop end if if ( ierr2 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo2=' , klo2 , 'khi2=' , khi2 , 'i=' , i write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( i0 ) pause stop end if if ( ierr3 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo3=' , klo3 , 'khi3=' , khi3 , 'i=' , i write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( i0 ) pause stop end if this % d1 ( i ) = dif ( klo1 ) this % d2 ( i ) = dif ( klo2 ) this % d3 ( i ) = dif ( klo3 ) end do end subroutine FokkerPlanck1D_init_diffusion subroutine FokkerPlanck1D_solve_time_step ( this , dt , nt ) use lock_module implicit none class ( FokkerPlanck1D ), intent ( inout ) :: this integer , intent ( in ) :: nt real ( dp ), intent ( in ) :: dt !real*8, intent (inout), optional :: dfj0(:) real ( dp ), parameter :: zero = 0.d0 real ( dp ) y ( this % n + 2 ), x ( this % n + 2 ) real ( dp ), dimension (:), allocatable :: fj , dfj , givi integer i , ii , it , ibeg , klo , khi , ierr , klo1 , khi1 real ( dp ) shift , ybeg , yend , tend , dff !!!!!! grid !!!!!!!!! !!  shift=h*0.1d0 !0.01d0 do i = 1 , this % n + 2 x ( i ) = this % h * dble ( i - 1 ) !+shift end do do i = 1 , this % n + 1 call lock ( this % v , this % i0 , x ( i + 1 ), klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error #1 in finction fokkerplanck' write ( * , * ) 'j=' , 123 , ' v=' , x ( i + 1 ) write ( * , * ) 'vj(1)=' , this % v ( 1 ), ' vj(i0)=' , this % v ( this % i0 ) pause stop end if call linf ( this % v , this % f , x ( i + 1 ), y ( i ), klo , khi ) end do ybeg = this % f ( 1 ) !boundary conditions yend = this % f ( this % i0 ) !zero !print *, ' yend =', yend !!!!!!!!!!!!   solve problem   !!!!!!!!!!!!!!!!!!!!!!!!!! call savelyev_solver ( this % alfa2 , nt , this % h , dt , this % n , ybeg , yend , this % d1 , this % d2 , this % d3 , y ) !call teplova_khavin_solver(this%alfa2, nt, this%h, dt, this%n, ybeg, yend, this%d1,this%d2,this%d3, y) allocate ( fj ( this % n + 2 )) fj ( 1 ) = ybeg fj ( this % n + 2 ) = yend do i = 1 , this % n fj ( i + 1 ) = y ( i ) end do do i = 2 , this % i0 - 1 if ( this % v ( i ). lt . this % v_lim ) then call lock ( x , this % n + 2 , this % v ( i ), klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error #2 in finction fokkerplanck' write ( * , * ) 'j=' , 123 , ' vij=' , this % v ( i ) write ( * , * ) 'x(1)=' , x ( 1 ), ' x(n+2)=' , x ( this % n + 2 ) pause stop end if call linf ( x , fj , this % v ( i ), this % f ( i ), klo , khi ) else this % f ( i ) = zero end if end do deallocate ( fj ) !if (present(dfj0)) then !    call burying_procedure(vj, fj0, dfj0) !else !    call burying_procedure(vj, fj0) !end if end subroutine FokkerPlanck1D_solve_time_step subroutine burying_procedure ( v , f0 , df0 ) !! процедура закапывания implicit none real * 8 , intent ( in ) :: v (:) real * 8 , intent ( inout ) :: f0 (:) real * 8 , intent ( inout ), optional :: df0 (:) integer i , ii , i0 , ibeg real * 8 , allocatable :: f (:), df (:) real * 8 fout1 , fout2 i0 = size ( f0 ) allocate ( f ( i0 ), df ( i0 )) f (:) = f0 (:) df (:) = 0 d0 do i = 2 , i0 - 1 df ( i ) = 0.5d0 * ( f ( i + 1 ) - f ( i - 1 )) / v ( 2 ) end do df ( 1 ) = 0 d0 df ( i0 ) = ( f ( i0 ) - f ( i0 - 1 )) / v ( 2 ) !   сдвиг расределения вправо. зачем-то ??? ii = 0 ibeg = 0 do i = i0 - 1 , 1 , - 1 if ( df ( i ). gt . 0 d0 ) then !          write(*,*) '#1 positive derivs' !          write(*,*) '#1 df>0: i,j,k=',i,j,k !          write(*,*) '#1 dfj(i),i,j,k=',dfj(i),i,j,k !          write(*,*) f0 ( i ) = f0 ( i + 1 ) if ( present ( df0 )) then df0 ( i ) = df0 ( i + 1 ) end if ii = i end if if ( f0 ( i ). lt . f0 ( i + 1 )) then f0 ( i ) = f0 ( i + 1 ) if ( present ( df0 )) then df0 ( i ) = df0 ( i + 1 ) end if ii = i end if end do if ( ibeg . gt . 0 ) then call integral ( ibeg , i0 , v , f , fout1 ) f (:) = f0 (:) if ( present ( df0 )) then df (:) = df0 (:) end if call integral ( ibeg , i0 , v , f , fout2 ) f0 ( ibeg : i0 ) = f ( ibeg : i0 ) * fout1 / fout2 if ( present ( df0 )) then df0 ( ibeg : i0 ) = df ( ibeg : i0 ) * fout1 / fout2 end if !      write(*,*)'#1 j,k,ibeg=',j,k,ibeg !      write(*,*)'#1 v(ibeg)=',vj(ibeg),' f1/f2=',fout1/fout2 end if deallocate ( f , df ) ibeg = ii end subroutine end module FokkerPlanck1D_mod","tags":"","loc":"sourcefile\\2_fokkerplanck1d.f90.html"},{"title":"2_plasma.f90 – FRTС project","text":"Contents Modules plasma Source Code 2_plasma.f90 Source Code module plasma use kind_module implicit none integer ngrid , nspl !! ASTRA radial grid number real ( wp ) tcur !! время (придумать название для переменной получше) real ( wp ) rm !! minor radius in mid-plane, cm real ( wp ) b_tor0 , b_tor !! временно нужно две переменных, тоже нужно исправить real ( wp ) r0 real ( wp ) z0 real ( wp ) rh1 real ( wp ), dimension (:), allocatable :: con , tem , temi , zeff , afld real ( wp ), dimension (:), allocatable :: rh , rha , drhodr , delta , ell , gamm , amy real ( wp ) tet1 , tet2 !!common /a0a2/ real ( wp ) xmi , cnye , cnyi , xsz , vt0 !!/a0ef3/ xmi,cnye,cnyi,xsz,vt0 real ( wp ) cnstvc real ( wp ) ww !!common /a0ef2/ ww real ( wp ) cltn !!common /a0ef1/ cltn real ( wp ) vperp ( 50 , 100 ), cnstal , zza , zze , valfa !,kv !common /a0i5/ vperp(50,100),cnstal,zza,zze,valfa!,kv real ( wp ) vpmax real ( wp ) vk ( 100 ), sk ( 100 ) !common /a0i2/ vk(100) integer , parameter :: ipsy = 5 , ncoef = 5 !!   ipsy = number of polinomial decomposition coefficients !!   used for interpolation of Zakharov's moments. real ( wp ), dimension ( ipsy ) :: cdl , cly , cgm , cmy , coeffs real ( wp ) y2dn ( 501 ), y2tm ( 501 ), y2tmi ( 501 ) !!common /a0l3/ real ( wp ) y2zeff ( 501 ) !!common /a0l5/ integer ncheb real ( wp ) chebne ( 50 ), chebdne ( 50 ), chebddne ( 50 ) !!common/ne_cheb real ( wp ) enorm ( 100 ), fst ( 100 ) !! em поле и еще что-то contains subroutine init_plasma ( NA1 , ABC , BTOR , RTOR , UPDWN , GP2 , AMETR , RHO , SHIF , ELON , TRIA , MU , NE , TE , TI , ZEF , UPL ) use constants use approximation use rt_parameters use spline_module use chebyshev implicit none integer , intent ( in ) :: NA1 real ( wp ), intent ( in ) :: ABC , BTOR , RTOR , UPDWN , GP2 real ( wp ), dimension ( * ) :: AMETR , RHO , SHIF , ELON , TRIA , MU , NE , TE , TI , ZEF , UPL integer i , k integer , parameter :: N = 501 real ( wp ) :: znak_tor , znak_pol , fpol , dfmy ngrid = NA1 nspl = ngrid if (. not . allocated ( rh )) then allocate ( rh ( N ), rha ( N ), drhodr ( N ), con ( N ), tem ( N ), source = 0.0_wp ) allocate ( temi ( N ), zeff ( N ), afld ( N ), source = 0.0_wp ) allocate ( delta ( N ), ell ( N ), gamm ( N ), amy ( N ), source = 0.0_wp ) end if do i = 1 , ngrid rh ( i ) = AMETR ( i ) / ABC rha ( i ) = RHO ( i ) / ABC !/ABC instead of /ROC is not a mistake! delta ( i ) = ( SHIF ( 1 ) - SHIF ( i )) / ABC !FRTC Shafr. shift. defin. ell ( i ) = ELON ( i ) gamm ( i ) = rh ( i ) * TRIA ( i ) con ( i ) = NE ( i ) tem ( i ) = TE ( i ) temi ( i ) = TI ( i ) zeff ( i ) = ZEF ( i ) afld ( i ) = UPL ( i ) / RTOR / GP2 !!variant end do rh ( ngrid ) = 1.d0 rh1 = rh ( 1 ) !saving the first ASTRA radial grid element rh ( 1 ) = 0.0d0 !shifting the first element to zero rha ( 1 ) = 0.0d0 !shifting the first element to zero delta ( 1 ) = 0.0d0 !putting delta(rh=0.)=0. gamm ( 1 ) = 0.0d0 !putting gamm(rh=0.)=0. b_tor0 = 1.d4 * BTOR * RTOR / ( RTOR + SHIF ( 1 )) !B_tor_(magnetic axis), Gauss rm = 1.d2 * ABC !minor radius in mid-plane, cm r0 = 1.d2 * ( RTOR + SHIF ( 1 )) !x-coordinate of the magnetic axis, cm z0 = 1.d2 * UPDWN !z-coordinate of the magnetic axis, cm !   spline approximation of plasma profiles ! !   shift as a function of \"minor radius\": call approx ( rh , delta , ngrid , polin1 , ipsy - 1 , coeffs ) cdl ( 1 ) = 0.0d0 do k = 2 , ipsy cdl ( k ) = coeffs ( k - 1 ) end do !   triangularity as a function of \"minor radius\": call approx ( rh , gamm , ngrid , polin1 , ipsy - 1 , coeffs ) cgm ( 1 ) = 0.0d0 do k = 2 , ipsy cgm ( k ) = coeffs ( k - 1 ) end do !   ellipticity as a function of \"minor radius\": call approx ( rh , ell , ngrid , polin , ipsy , cly ) !  \"poloidal magnetic field\": call diff ( rh , rha , ngrid , drhodr ) do i = 2 , ngrid amy ( i ) = 1.d4 * BTOR * MU ( i ) * rha ( i ) * drhodr ( i ) !print *, amy(i), BTOR, MU(i) end do !print *, '----------------' amy ( 1 ) = 0.d0 !! amy=(btor/q)*rho*(drho/dr) is a function of \"minor radius\" r=rh(i). !! Poloidal magnetic field: B_pol=amy(r)*sqrt(g22/g), where g is !! determinant of 3D metric tensor and g22 is the (22) element of !! the tensor, normalized on ABC&#94;4 and ABC&#94;2, correspondingly. !! !!  Polinomial approximation of the amy(r): !    inpt2=ngrid-3 call approx ( rh , amy , ngrid - 3 , polin1 , ipsy - 1 , coeffs ) cmy ( 1 ) = 0.d0 do k = 2 , ipsy cmy ( k ) = coeffs ( k - 1 ) end do ! зачем-то меняет знак коэффициентов???? znak_tor = dsign ( 1.d0 , dble ( itor )) b_tor = znak_tor * dabs ( b_tor0 ) fpol = fdf ( 1.d0 , cmy , ncoef , dfmy ) znak_pol = dsign ( 1.d0 , dble ( i_pol )) * dsign ( 1.d0 , fpol ) do i = 1 , ncoef cmy ( i ) = znak_pol * cmy ( i ) end do !!!!!!!!!!!!!!! spline approximation of plasma profiles !!!!!!!!!!!!!!!! call splne ( rh , con , nspl , y2dn ) call splne ( rh , tem , nspl , y2tm ) call splne ( rh , zeff , nspl , y2zeff ) call splne ( rh , temi , nspl , y2tmi ) if ( inew . ne . 0 ) then ncheb = 20 call chebft1 ( zero , 1.d0 , chebne , ncheb , fn ) call chder ( zero , 1.d0 , chebne , chebdne , ncheb ) call chder ( zero , 1.d0 , chebdne , chebddne , ncheb ) end if call init_parameters call find_volums_and_surfaces end subroutine subroutine init_parameters use constants use approximation use rt_parameters implicit none real ( wp ) :: xly , xlyp , arg1 , arg2 real ( wp ) :: hr , dn1 , dn2 , dn3 , sss !!! xly = fdf ( one , cly , ncoef , xlyp ) arg1 = ( zplus - z0 ) / ( xly * rm ) arg2 = ( zminus - z0 ) / ( xly * rm ) if ( dabs ( arg1 ). lt . 1.d0 ) then tet1 = dasin ( arg1 ) ! upper grill corner poloidal coordinate else tet1 = 0.5d0 * pi ! upper grill corner poloidal coordinate end if if ( dabs ( arg2 ). lt . 1.d0 ) then tet2 = dasin ( arg2 ) ! lower grill corner poloidal coordinate else tet2 =- 0.5d0 * pi ! lower grill corner poloidal coordinate end if !------------------------------------------------------------ ! calculate constants !--------------------------------------- hr = 1.d0 / dble ( nr + 1 ) dn1 = 1 d0 / ( zi1 + dni2 * zi2 + dni3 * zi3 ) dn2 = dni2 * dn1 dn3 = dni3 * dn1 sss = zi1 ** 2 * dn1 / xmi1 + zi2 ** 2 * dn2 / xmi2 + zi3 ** 2 * dn3 / xmi3 xmi = 183 6.d0 / sss cnstvc = (. 75 d0 * piq * sss / 183 6.d0 ) ** one_third ww = freq * pi2 * 1.0d+09 cnye = xlog / pi4 cnyi = dsqrt ( 2 d0 ) / ( 3 d0 * piq ) !%for Vt=sqrt(Te/m) vt0 = fvt ( zero ) !!!!!!!!      ptkev=ft(zero)/0.16d-8  !Te in keV cltn = clt / vt0 xsz = clt / ww / rm !ccur=pqe*vt0*0.333d-9 !!      ccurnr=pqe*pqe*0.333d-9/pme rrange = rrange * hr !ToDo если вызывается несколько раз то будут проблемы valfa = 1.d9 * dsqrt ( 1.91582d0 * talfa / xmalfa ) !  valfa (cgs units) = birth velocity zza = cnst1 * ( zalfa / xmalfa / valfa ) ** 2 * ( clt / valfa ) ** 3 / pi zze = cnst2 * 2.d9 * freq cnstal = ( dsqrt ( cnst1 ) / xmalfa / pi ) * ( zalfa * vt0 / valfa ) ** 2 * clt / valfa vpmax = dsqrt ( energy / talfa ) !  \"vpmax\" in valfa velocity units ! end subroutine subroutine find_volums_and_surfaces use constants use rt_parameters implicit none integer j real ( wp ) hr , rxx , vk0 , sk0 !-------------------------------------------------------- ! find volums and surfaces !-------------------------------------------------------- hr = 1.d0 / dble ( nr + 1 ) vk0 = pi2 * hr * rm ** 3 sk0 = hr * rm ** 2 do j = 1 , nr rxx = hr * dble ( j ) vk ( j ) = vk0 * gaussint ( obeom , zero , pi2 , rxx , eps ) sk ( j ) = sk0 * gaussint ( ploshad , zero , pi2 , rxx , eps ) end do end subroutine real ( wp ) function fn ( x ) !! plasma  density,  cm&#94;-3 use constants , only : zero use spline_module real ( wp ), intent ( in ) :: x real ( wp ) :: pa , r , y , dy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = dabs ( x ) if ( pa . le . rh ( nspl )) then call splnt ( rh , con , y2dn , nspl , pa , y , dy ) else r = pa - rh ( nspl ) y = con ( nspl ) * dexp ( - alfa * ( r / dr ) ** 2 ) end if fn = y * 1.d+13 !cm&#94;-3 end real ( wp ) function fvt ( r ) !! нет описания real ( wp ), intent ( in ) :: r real ( wp ) :: pt pt = ft ( r ) fvt = sqrt ( pt / 9.11d-28 ) end real ( wp ) function fn1 ( x , fnp ) !! plasma density and its derivative use constants , only : zero use spline_module real ( wp ), intent ( in ) :: x real ( wp ), intent ( out ) :: fnp real ( wp ) :: r , pa , y1 , y , s , dy , dy1 real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = abs ( x ) if ( pa . le . rh ( nspl )) then call splnt ( rh , con , y2dn , nspl , pa , y , dy ) else call splnt ( rh , con , y2dn , nspl , rh ( nspl ), y1 , dy1 ) r = pa - rh ( nspl ) y = rh ( nspl ) * exp ( - alfa * ( r / dr ) ** 2 ) dy =- 2.d0 * alfa * y * r / dr ** 2 !corrected end if fn1 = y * 1.d+13 !cm&#94;-3 fnp = dy * 1.d+13 end real ( wp ) function fn2 ( r , fnp , fnpp ) !! plasma density and its first and second derivatives use constants , only : zero use chebyshev real ( wp ), intent ( in ) :: r real ( wp ), intent ( out ) :: fnp , fnpp real ( wp ) :: x , y1 , y , s , dy , ddy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 x = abs ( r ) if ( x . le . 1.d0 ) then y = chebev ( zero , 1.d0 , chebne , ncheb , x ) dy = chebev ( zero , 1.d0 , chebdne , ncheb , x ) ddy = chebev ( zero , 1.d0 , chebddne , ncheb , x ) else y1 = chebev ( zero , 1.d0 , chebne , ncheb , 1.d0 ) s = x - 1.d0 y = y1 * exp ( - alfa * ( s / dr ) ** 2 ) dy =- 2.d0 * alfa * y * s / dr ** 2 ddy =- 2.d0 * alfa * y * ( 1.d0 - 2.d0 * alfa * ( s / dr ) ** 2 ) / dr ** 2 end if fn2 = y !cm&#94;-3 fnp = dy fnpp = ddy end real ( wp ) function ft ( x ) !! electron temperature, erg use constants , only : zero use spline_module real ( wp ), intent ( in ) :: x real ( wp ) :: pa , r , y , dy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = abs ( x ) !#@sav if ( pa . le . rh ( nspl )) then call splnt ( rh , tem , y2tm , nspl , pa , y , dy ) else r = pa - rh ( nspl ) y = tem ( nspl ) * exp ( - alfa * ( r / dr ) ** 2 ) end if !!      ft=y            ! kev ft = y * 0.16d-8 ! erg end real ( wp ) function fti ( x ) !! ion temperature, kev use constants , only : zero use spline_module real ( wp ), intent ( in ) :: x real ( wp ) :: pa , r , y , dy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = abs ( x ) !#@sav if ( pa . le . rh ( nspl )) then call splnt ( rh , temi , y2tmi , nspl , pa , y , dy ) else r = pa - rh ( nspl ) y = temi ( nspl ) * exp ( - alfa * ( r / dr ) ** 2 ) end if fti = y ! kev end real ( wp ) function zefff ( x ) !! z_effective profile use constants , only : zero use spline_module real ( wp ), intent ( in ) :: x real ( wp ) :: pa , r , y , dy real ( wp ), parameter :: alfa = 4.d0 , dr = . 02 d0 pa = abs ( x ) !#@sav if ( pa . le . rh ( nspl )) then call splnt ( rh , zeff , y2zeff , nspl , pa , y , dy ) else r = pa - rh ( nspl ) y = zeff ( nspl ) * exp ( - alfa * ( r / dr ) ** 2 ) end if zefff = y end subroutine calc_enorm use constants use rt_parameters , only : nr , inew use spline_module use maxwell use lock_module implicit none integer j , klo , khi , ierr real ( wp ) :: efld real ( wp ) :: r , pn , vt , tmp , xlogj , vmax real ( wp ) :: fnr , fnrr , dens !real*8 fn1,fn2 do j = 1 , nr r = dble ( j ) / dble ( nr + 1 ) call lock ( rh , nspl , r , klo , khi , ierr ) if ( ierr . eq . 1 ) then write ( * , * ) 'lock error in saveprofiles, Efield' write ( * , * ) 'j=' , j , ' rh(j)=' , rh ( j ), ' r=' , r pause stop end if call linf ( rh , afld , r , efld , klo , khi ) if ( inew . eq . 0 ) then !vardens pn = fn1 ( r , fnr ) else pn = fn2 ( r , fnr , fnrr ) end if vt = fvt ( r ) tmp = ft ( r ) / 0.16d-8 !Te,  KeV dens = pn / 1.d+13 !10&#94;13 cm&#94;-3 xlogj = dlog ( 5.1527d7 * tmp * 1 6.d0 * dsqrt ( tmp ) / dsqrt ( dens )) enorm ( j ) = ( 3.835d0 / xlogj ) * efld * tmp / dens enorm ( j ) = enorm ( j ) * 5.d0 / ( 5.d0 + zefff ( r )) !!fst(j)=pn*xlogj*c0**4/pi4/vt**3 fst ( j ) = (( 5.d0 + zefff ( r )) / 5.d0 ) * pn * xlogj * c0 ** 4 / pi4 / vt ** 3 end do end subroutine subroutine init_maxwell use constants use rt_parameters , only : nr , inew use spline_module use maxwell implicit none integer j real ( wp ) r , vclt do j = 1 , nr r = dble ( j ) / dble ( nr + 1 ) vclt = 3.d10 / fvt ( r ) !print *, vclt !call init_vi(vclt, vij(:,j)) vij ( 1 : i0 , j ) = create_vt_grid ( vclt ) call init_fmaxw_classic ( vclt , enorm ( j ), fij (:, j , 1 ), dfij (:, j , 1 )) call init_fmaxw_ext ( vclt , enorm ( j ), fij (:, j , 2 ), dfij (:, j , 2 )) end do fij0 (:,:,:) = fij (:,:,:) dij (:,:,:) = zero end subroutine real ( wp ) function obeom ( ptet , pa ) use constants use approximation implicit real * 8 ( a - h , o - z ) !common /a0befr/ pi,pi2 !common /a0ef1/ cltn !common /a0k/ cdl(10),cly(10),cgm(10),cmy(10),ncoef parameter ( pa0 = 0.d0 ) xdl = fdf ( pa , cdl , ncoef , xdlp ) xly = fdf ( pa , cly , ncoef , xlyp ) xgm = fdf ( pa , cgm , ncoef , xgmp ) xlyv = xlyp * pa + xly cotet = dcos ( ptet ) sitet = dsin ( ptet ) dxdr =- xdlp + cotet - xgmp * sitet ** 2 dxdt =- ( pa + two * xgm * cotet ) * sitet dzdr = xlyv * sitet dzdt = xly * pa * cotet x0 = r0 / rm - xdl + pa * cotet - xgm * sitet ** 2 dxdrdt =- sitet - two * xgmp * sitet * cotet dzdrdt = xlyv * cotet dxdtdt =- pa * cotet - two * xgm * ( cotet ** 2 - sitet ** 2 ) dzdtdt =- xly * pa * sitet x0t = dxdt !-------------------------------------- ! components of metric tensor !-------------------------------------- g11 = dxdr ** 2 + dzdr ** 2 g22 = dxdt ** 2 + dzdt ** 2 g12 = dxdr * dxdt + dzdr * dzdt g33 = x0 ** 2 xj = ( dzdr * dxdt - dxdr * dzdt ) ** 2 !gg=g11*g22-g12*g12 g = xj * g33 obeom = dsqrt ( g ) end real ( wp ) function ploshad ( ptet , pa ) use constants use approximation implicit real * 8 ( a - h , o - z ) !common /a0befr/ pi,pi2 !common /a0ef1/ cltn !common /a0k/ cdl(10),cly(10),cgm(10),cmy(10),ncoef parameter ( pa0 = 0.d0 ) xdl = fdf ( pa , cdl , ncoef , xdlp ) xly = fdf ( pa , cly , ncoef , xlyp ) xgm = fdf ( pa , cgm , ncoef , xgmp ) xlyv = xlyp * pa + xly cotet = dcos ( ptet ) sitet = dsin ( ptet ) dxdr =- xdlp + cotet - xgmp * sitet ** 2 dxdt =- ( pa + two * xgm * cotet ) * sitet dzdr = xlyv * sitet dzdt = xly * pa * cotet x0 = r0 / rm - xdl + pa * cotet - xgm * sitet ** 2 dxdrdt =- sitet - two * xgmp * sitet * cotet dzdrdt = xlyv * cotet dxdtdt =- pa * cotet - two * xgm * ( cotet ** 2 - sitet ** 2 ) dzdtdt =- xly * pa * sitet x0t = dxdt !-------------------------------------- ! components of metric tensor !-------------------------------------- g11 = dxdr ** 2 + dzdr ** 2 g22 = dxdt ** 2 + dzdt ** 2 g12 = dxdr * dxdt + dzdr * dzdt xj = ( dzdr * dxdt - dxdr * dzdt ) ** 2 !gg=g11*g22-g12*g12 ploshad = dsqrt ( xj ) end real ( wp ) function gaussint ( f , a , b , r , eps ) !! что-то про гаусс implicit none real ( wp ) w ( 12 ), x ( 12 ) real ( wp ) f , a , b , r , eps real ( wp ) aa , bb , c1 , c2 , s8 , s16 , u , y , delta integer i !!      save w,x,const !sav# real ( wp ), parameter :: const = 1.0d-12 data w & / 0.101228536290376 , 0.222381034453374 , 0.313706645877887 , & 0.362683783378362 , 0.027152459411754 , 0.062253523938648 , & 0.095158511682493 , 0.124628971255534 , 0.149595988816577 , & 0.169156519395003 , 0.182603415044924 , 0.189450610455069 / data x & / 0.960289856497536 , 0.796666477413627 , 0.525532409916329 , & 0.183434642495650 , 0.989400934991650 , 0.944575023073233 , & 0.865631202387832 , 0.755404408355003 , 0.617876244402644 , & 0.458016777657227 , 0.281603550779259 , 0.095012509837637 / delta = const * dabs ( a - b ) gaussint = 0 d0 aa = a 5 y = b - aa if ( dabs ( y ). le . delta ) return 2 bb = aa + y c1 = 0.5d0 * ( aa + bb ) c2 = c1 - aa s8 = 0 d0 s16 = 0 d0 do i = 1 , 4 u = x ( i ) * c2 s8 = s8 + w ( i ) * ( f ( c1 + u , r ) + f ( c1 - u , r )) end do do i = 5 , 12 u = x ( i ) * c2 s16 = s16 + w ( i ) * ( f ( c1 + u , r ) + f ( c1 - u , r )) end do s8 = s8 * c2 s16 = s16 * c2 if ( dabs ( s16 - s8 ) . gt . eps * ( 1 d0 + dabs ( s16 ))) go to 4 gaussint = gaussint + s16 aa = bb go to 5 4 y = 0.5d0 * y if ( dabs ( y ) . gt . delta ) go to 2 write ( * , 7 ) gaussint = 0 d0 return 7 format ( 1 x , 'gaussint ... too high accuracy required' ) end end module plasma","tags":"","loc":"sourcefile\\2_plasma.f90.html"},{"title":"2_spectrum.f90 – FRTС project","text":"Contents Modules spectrum_mod spectrum1D Source Code 2_spectrum.f90 Source Code module spectrum_mod use kind_module implicit none type SpectrumPoint !real(wp) nz и ny не нужны ! !real(wp) ny ! real ( wp ) Ntor !! Ntau=-Ntor real ( wp ) Npol !! Ntet=Npol real ( wp ) power !! power contains end type SpectrumPoint type Spectrum integer size !! size of spectrum real ( wp ) input_power !! power of spectrum real ( wp ) power_ratio !! доля входной мощности real ( wp ) max_power !! real ( wp ) sum_power !! суммарная power integer direction !! направление спектра   +1 или -1 или 0 - полный type ( SpectrumPoint ), allocatable :: data (:) !! contains procedure :: get_positive_part => get_positive_part_method procedure :: get_negative_part => get_negative_part_method procedure :: calc_max_power => calc_max_power_method end type Spectrum interface Spectrum module procedure :: spectrum_constructor !module procedure :: read_spectrum end interface Spectrum contains function spectrum_constructor ( size ) result ( this ) !- конструктор для spectrum implicit none type ( Spectrum ) :: this integer , value :: size this % size = size this % input_power = 0 this % sum_power = 0 allocate ( this % data ( size )) end function spectrum_constructor subroutine calc_max_power_method ( this ) use constants , only : xsgs use rt_parameters , only : ntet implicit none class ( Spectrum ), intent ( inout ) :: this type ( SpectrumPoint ) :: p real ( wp ) max_power , pnorm integer i max_power = 0 pnorm = this % power_ratio * xsgs / ntet print * , 'pnorm =' , pnorm do i = 1 , this % size p = this % data ( i ) p % power = p % power * pnorm p % Ntor = this % direction * p % Ntor this % data ( i ) = p if ( p % power > max_power ) max_power = p % power end do this % max_power = max_power print * , 'this%max_power = ' , this % max_power end subroutine function get_positive_part_method ( this ) result ( spectr ) !! implicit none class ( Spectrum ), intent ( in ) :: this type ( Spectrum ) :: spectr , tmp_spectr type ( SpectrumPoint ) :: p integer i , n print * , 'read positive' tmp_spectr = Spectrum ( this % size ) n = 0 do i = 1 , this % size p = this % data ( i ) if ( p % Ntor > 0 ) then n = n + 1 tmp_spectr % data ( n ) = p tmp_spectr % sum_power = tmp_spectr % sum_power + p % power end if end do tmp_spectr % size = n spectr = Spectrum ( n ) spectr % sum_power = tmp_spectr % sum_power do i = 1 , n spectr % data ( i ) = tmp_spectr % data ( i ) end do spectr % size = n spectr % direction = + 1 spectr % power_ratio = spectr % sum_power / this % sum_power spectr % input_power = spectr % power_ratio * this % input_power print * , this % size , n print * , 'sum_power ' , this % sum_power , spectr % sum_power print * , 'power_ratio ' , this % power_ratio , spectr % power_ratio print * , 'input_power ' , this % input_power , spectr % input_power end function get_positive_part_method function get_negative_part_method ( this ) result ( spectr ) !! implicit none class ( Spectrum ), intent ( in ) :: this type ( Spectrum ) :: spectr , tmp_spectr type ( SpectrumPoint ) :: p integer i , n print * , 'negative positive' tmp_spectr = Spectrum ( this % size ) n = 0 do i = 1 , this % size p = this % data ( i ) if ( p % Ntor < 0 ) then n = n + 1 p % Ntor = - p % Ntor tmp_spectr % data ( n ) = p tmp_spectr % sum_power = tmp_spectr % sum_power + p % power end if end do tmp_spectr % size = n spectr = Spectrum ( n ) spectr % sum_power = tmp_spectr % sum_power do i = 1 , n spectr % data ( i ) = tmp_spectr % data ( n + 1 - i ) end do spectr % size = n spectr % direction = - 1 spectr % power_ratio = spectr % sum_power / this % sum_power spectr % input_power = spectr % power_ratio * this % input_power print * , this % size , n print * , 'sum_power ' , this % sum_power , spectr % sum_power print * , 'power_ratio ' , this % power_ratio , spectr % power_ratio print * , 'input_power ' , this % input_power , spectr % input_power end function get_negative_part_method function read_spectrum ( file_name ) result ( spectr ) !- чтение spectrum из файла implicit none type ( Spectrum ) :: spectr character ( len = * ), value :: file_name logical :: res integer i , n , stat real ( wp ) sum_power !integer, value :: size print * , file_name ! Check if the file exists inquire ( file = trim ( file_name ), exist = res ) if (. not . res ) then print * , 'spectrum file not exists' stop end if open ( 20 , file = file_name ) n =- 1 stat = 0 do while ( stat == 0 ) n = n + 1 read ( 20 , * , iostat = stat ) enddo spectr % size = n spectr % input_power = 0 spectr % sum_power = 0 spectr % direction = 0 spectr % power_ratio = 1 sum_power = 0 allocate ( spectr % data ( n )) print * , 'Spectrum size = ' , n rewind ( 20 ) do i = 1 , n read ( 20 , * ) spectr % data ( i )% Ntor , spectr % data ( i )% Npol , spectr % data ( i )% power sum_power = sum_power + spectr % data ( i )% power enddo !sum_power !do i=1,n !    spectr%data(i)%power = spectr%data(i)%power/sum_power !enddo spectr % sum_power = sum_power close ( 20 ) end function read_spectrum subroutine divide_spectrum ( spectr , pos_spectr , neg_spectr ) !! деление спектра на две части implicit none type ( Spectrum ), intent ( in ) :: spectr type ( Spectrum ), intent ( out ) :: pos_spectr , neg_spectr type ( Spectrum ) :: tmp_spectr type ( SpectrumPoint ) :: p integer i , pos_n , neg_n pos_spectr = Spectrum ( spectr % size ) tmp_spectr = Spectrum ( spectr % size ) pos_n = 0 neg_n = 0 do i = 1 , spectr % size p = spectr % data ( i ) if ( p % Ntor > 0 ) then pos_n = pos_n + 1 pos_spectr % data ( pos_n ) = p pos_spectr % sum_power = pos_spectr % sum_power + p % power end if if ( p % Ntor < 0 ) then neg_n = neg_n + 1 p % Ntor = - p % Ntor tmp_spectr % data ( neg_n ) = p tmp_spectr % sum_power = tmp_spectr % sum_power + p % power endif end do pos_spectr % size = pos_n neg_spectr = Spectrum ( neg_n ) neg_spectr % sum_power = tmp_spectr % sum_power do i = 1 , neg_n neg_spectr % data ( i ) = tmp_spectr % data ( neg_n + 1 - i ) end do neg_spectr % size = neg_n pos_spectr % direction = + 1 neg_spectr % direction = - 1 pos_spectr % power_ratio = pos_spectr % sum_power / spectr % sum_power neg_spectr % power_ratio = neg_spectr % sum_power / spectr % sum_power pos_spectr % input_power = pos_spectr % power_ratio * spectr % input_power neg_spectr % input_power = neg_spectr % power_ratio * spectr % input_power print * , pos_n , neg_n print * , 'sum_power ' , spectr % sum_power , pos_spectr % sum_power , neg_spectr % sum_power print * , 'power_ratio ' , pos_spectr % power_ratio , neg_spectr % power_ratio print * , 'input_power ' , spectr % input_power , pos_spectr % input_power , neg_spectr % input_power end subroutine function make_spline_approximation ( spectr ) result ( appx_spectr ) !! approximation of input LH spectrum use constants , only : zero , xsgs use spline_module use rt_parameters , only : nnz , ntet , pabs0 implicit none type ( Spectrum ), intent ( in ) :: spectr type ( Spectrum ) :: appx_spectr integer :: ispectr , ispl real ( wp ), allocatable :: ynzm0 (:), pm0 (:) real ( wp ), allocatable :: ynzm (:), pm (:) real ( wp ), allocatable :: yn2z (:), powinp (:) integer innz , i real ( wp ) dxx , xx0 , xx1 , xx2 , yy1 , yy2 , pinp real ( wp ) dpw , dpower , pwcurr , ptot , dynn real ( wp ) pmax , pnorm , plaun ispectr = spectr % direction plaun = spectr % input_power ispl = spectr % size allocate ( ynzm ( nnz ), pm ( nnz )) allocate ( ynzm0 ( ispl ), pm0 ( ispl )) allocate ( yn2z ( ispl ), powinp ( ispl )) do i = 1 , spectr % size ynzm0 ( i ) = spectr % data ( i )% Ntor pm0 ( i ) = spectr % data ( i )% power end do call splne ( ynzm0 , pm0 , ispl , yn2z ) innz = 100 * ispl dxx = ( ynzm0 ( ispl ) - ynzm0 ( 1 )) / innz xx2 = ynzm0 ( 1 ) yy2 = pm0 ( 1 ) pinp = 0 d0 do i = 1 , innz xx1 = xx2 yy1 = yy2 xx2 = xx1 + dxx call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) pinp = pinp + dpw end do dpower = pinp / dble ( nnz ) xx2 = ynzm0 ( 1 ) yy2 = pm0 ( 1 ) pwcurr = zero ptot = zero do i = 1 , nnz - 1 xx0 = xx2 11 continue xx1 = xx2 yy1 = yy2 xx2 = xx1 + dxx call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) if ( pwcurr + dpw . gt . dpower ) then xx2 = xx1 + dxx * ( dpower - pwcurr ) / dpw call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) pwcurr = pwcurr + dpw else pwcurr = pwcurr + dpw go to 11 end if ynzm ( i ) = . 5 d0 * ( xx2 + xx0 ) pm ( i ) = pwcurr ptot = ptot + pwcurr pwcurr = zero end do ynzm ( nnz ) = . 5 d0 * ( ynzm0 ( ispl ) + xx2 ) pm ( nnz ) = pinp - ptot pnorm = plaun * xsgs / ( pinp * ntet ) print * , 'pnorm =' , pnorm pmax =- 1 d + 10 do i = 1 , nnz call splnt ( ynzm0 , pm0 , yn2z , ispl , ynzm ( i ), powinp ( i ), dynn ) pm ( i ) = pm ( i ) * pnorm if ( pm ( i ). gt . pmax ) pmax = pm ( i ) ynzm ( i ) = dble ( ispectr ) * ynzm ( i ) !sav2009 end do !pabs=pabs0*pmax/1.d2 appx_spectr = Spectrum ( nnz ) do i = 1 , nnz appx_spectr % data ( i ) = SpectrumPoint ( power = pm ( i ), Ntor = ynzm ( i ), Npol = 0 ) end do appx_spectr % input_power = plaun appx_spectr % max_power = pmax appx_spectr % direction = ispectr appx_spectr % power_ratio = spectr % power_ratio end function end module spectrum_mod module spectrum1D use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 use spectrum_mod implicit none type ( Spectrum ) :: full_spectrum type ( Spectrum ) :: pos_spectr , neg_spectr integer :: ispl !! size of spectrum real ( wp ) :: plaun !! power of spectrum real ( wp ) :: ynzm0 ( 1001 ) !+ real ( wp ) :: pm0 ( 1001 ) !+ real ( wp ) :: ynzm ( 1001 ), pm ( 1001 ) !!common /a0a1/ ynzm(1001),pm(1001) real ( wp ) :: pabs !!common /a0gh/ pabs integer , parameter , private :: HEADER_LENGTH = 53 contains subroutine read_positive_spectrum ( file_name , p_in ) implicit none character ( * ) file_name real ( wp ) :: p_in integer , parameter :: iunit = 20 integer :: i , i1 real ( wp ) :: anz , apz open ( iunit , file = file_name ) do i = 1 , HEADER_LENGTH read ( iunit , * ) end do do i = 1 , 10000 read ( iunit , * ) anz , apz if ( apz . eq . - 8888 8.d0 ) then plaun = p_in * anz !input power in positive spectrum exit end if ynzm0 ( i ) = anz pm0 ( i ) = apz i1 = i end do close ( iunit ) ispl = i1 if ( ispl . gt . 4001 ) stop 'too many points in spectrum' end subroutine read_positive_spectrum subroutine read_negative_spectrum ( file_name , p_in ) implicit none character ( * ) file_name real ( wp ) :: p_in integer , parameter :: iunit = 20 integer :: i , i1 real ( wp ) :: anz , apz open ( iunit , file = file_name ) do i = 1 , HEADER_LENGTH read ( iunit , * ) end do apz = 0.d0 do while ( apz . ne . - 8888 8.d0 ) read ( iunit , * ) anz , apz end do read ( iunit , * ) plaun = p_in * ( 1.d0 - anz ) !input power in negative spectrum if ( plaun > 0.d0 ) then do i = 1 , 10000 read ( iunit , * , end = 10 ) ynzm0 ( i ), pm0 ( i ) i1 = i end do end if 10 close ( iunit ) ispl = i1 if ( ispl . gt . 4001 ) stop 'too many points in spectrum' end subroutine read_negative_spectrum subroutine spectrum_approximation ( ispectr ) !! approximation of input LH spectrum use constants , only : zero , xsgs use spline_module use rt_parameters , only : nnz , ntet , pabs0 implicit none integer , intent ( in ) :: ispectr real ( wp ) yn2z ( 1001 ), powinp ( 1001 ) integer innz , i real ( wp ) dxx , xx0 , xx1 , xx2 , yy1 , yy2 , pinp real ( wp ) dpw , dpower , pwcurr , ptot , dynn real ( wp ) pmax , pnorm call splne ( ynzm0 , pm0 , ispl , yn2z ) innz = 100 * ispl dxx = ( ynzm0 ( ispl ) - ynzm0 ( 1 )) / innz xx2 = ynzm0 ( 1 ) yy2 = pm0 ( 1 ) pinp = 0 d0 do i = 1 , innz xx1 = xx2 yy1 = yy2 xx2 = xx1 + dxx call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) pinp = pinp + dpw end do dpower = pinp / dble ( nnz ) xx2 = ynzm0 ( 1 ) yy2 = pm0 ( 1 ) pwcurr = zero ptot = zero do i = 1 , nnz - 1 xx0 = xx2 11 continue xx1 = xx2 yy1 = yy2 xx2 = xx1 + dxx call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) if ( pwcurr + dpw . gt . dpower ) then xx2 = xx1 + dxx * ( dpower - pwcurr ) / dpw call splnt ( ynzm0 , pm0 , yn2z , ispl , xx2 , yy2 , dynn ) dpw = . 5 d0 * ( yy2 + yy1 ) * ( xx2 - xx1 ) pwcurr = pwcurr + dpw else pwcurr = pwcurr + dpw go to 11 end if ynzm ( i ) = . 5 d0 * ( xx2 + xx0 ) pm ( i ) = pwcurr ptot = ptot + pwcurr pwcurr = zero end do ynzm ( nnz ) = . 5 d0 * ( ynzm0 ( ispl ) + xx2 ) pm ( nnz ) = pinp - ptot pnorm = plaun * xsgs / ( pinp * ntet ) pmax =- 1 d + 10 do i = 1 , nnz call splnt ( ynzm0 , pm0 , yn2z , ispl , ynzm ( i ), powinp ( i ), dynn ) pm ( i ) = pm ( i ) * pnorm if ( pm ( i ). gt . pmax ) pmax = pm ( i ) ynzm ( i ) = dble ( ispectr ) * ynzm ( i ) !sav2009 end do pabs = pabs0 * pmax / 1.d2 end subroutine subroutine copy_to_spectrum_1D ( spectr ) use spectrum_mod implicit none type ( Spectrum ) :: spectr type ( SpectrumPoint ) :: p integer i do i = 1 , spectr % size p = spectr % data ( i ) ynzm0 ( i ) = p % Ntor pm0 ( i ) = p % power end do plaun = spectr % input_power ispl = spectr % size end subroutine function create_spectrum () result ( spectr ) use spectrum_mod use rt_parameters , only : nnz implicit none type ( Spectrum ) :: spectr type ( SpectrumPoint ) :: p integer i real ( wp ) :: pmax pmax = 0 spectr = Spectrum ( nnz ) do i = 1 , nnz p = SpectrumPoint ( power = pm ( i ), Ntor = ynzm ( i ), Npol = 0 ) if ( pm ( i ) > pmax ) pmax = pm ( i ) spectr % data ( i ) = p end do spectr % max_power = pmax end function subroutine write_spectrum ( ispectr ) implicit none integer , intent ( in ) :: ispectr !       call get_unit(iunit) !       if(iunit.eq.0) then !        write(*,*)'no free units up to 299' !        pause !        stop !       end if !       if(ispectr.eq.1) then !        open(iunit,file='lhcd/out/used_spectrP.dat') !       else if(ispectr.eq.-1) then !        open(iunit,file='lhcd/out/used_spectrM.dat') !       end if !       do i=1,nnz !        write(iunit,1008) ynzm(i),powinp(i) !       end do !       write(iunit,*) !      close(iunit) !1008   format (1x,10(e14.7,3x)) end subroutine end module spectrum1D","tags":"","loc":"sourcefile\\2_spectrum.f90.html"},{"title":"3_current_and_power.f90 – FRTС project","text":"Contents Modules current power Source Code 3_current_and_power.f90 Source Code module current use kind_module implicit none real ( wp ) :: dql ( 101 , 100 ) !! real ( wp ) :: pdl ( 100 ) !! real ( wp ) :: vzmin ( 100 ) !! real ( wp ) :: vzmax ( 100 ) !common /a0i3/ dql(101,100),pdl(100),vzmin(100),vzmax(100) real ( wp ) :: fcoll ( 100 ) real ( wp ) :: dens ( 100 ) real ( wp ) :: eta ( 100 ) !common /a0i4/ fcoll(100),dens(100),eta(100) real ( wp ) :: dq1 ( 101 , 100 ) real ( wp ) :: dq2 ( 101 , 100 ) real ( wp ) :: pdc ( 100 ) real ( wp ) :: pda ( 100 ) real ( wp ) :: ppv1 , ppv2 !common/vvv1/dq1(101,100),dq2(101,100),pdc(100),pda(100),ppv1,ppv2 real ( wp ) :: pdfast ( 100 ) !common /vvv3/ pdfast(100) real ( wp ) :: dqi0 ( 50 , 100 ) !common /alph/ dqi0(50,100) real ( wp ) :: dncount ( 101 , 100 ) !common/findsigma/dncount(101,100) contains subroutine find_achieved_radial_points ( nvpt ) !!  find achieved radial points jbeg-jend use rt_parameters , only : nr implicit none integer , intent ( in ) :: nvpt integer i , j , jbeg , jend , nvmin , nvach nvmin = 1 !minimum counted events at a given radius rho jbeg = 1 jend = 0 do j = 1 , nr nvach = 0 do i = 1 , nvpt nvach = nvach + dncount ( i , j ) end do if ( nvach . lt . nvmin ) then if ( jend . eq . 0 ) jbeg = jbeg + 1 else jend = j end if end do if ( jend . eq . 0. or . jbeg . ge . jend ) then write ( * , * ) 'failure: jbeg=' , jbeg , ' jend=' , jend pause stop end if end subroutine subroutine dfind ( j , i , v , powpr , pil , pic , pia , df , decv , refr , vlf , vrt , ifast ) use constants use plasma use rt_parameters implicit none integer , intent ( in ) :: i , j , ifast real ( wp ), intent ( in ) :: v , powpr , pil , pic , pia , df , decv , refr , vlf , vrt integer k real ( wp ) :: pchgl , pchgc , pchga , denom , powlandau , powdamped real ( wp ) :: fff , dd , domin , parn , dvz , dnpar , weight , addd real ( wp ) :: arg , hevis , adda !common /a0i3/ dql(101,100),pdl(100),vzmin(100),vzmax(100) !common /a0i4/ fcoll(100),dens(100),eta(100) !common/vvv1/dq1(101,100),dq2(101,100),pdc(100),pda(100),ppv1,ppv2 !common /vvv3/ pdfast(100) !common /alph/ dqi0(50,100) !common/findsigma/dncount(101,100) if ( v . gt . cltn ) return if ( pil . gt . zero ) then if ( v . lt . vzmin ( j )) vzmin ( j ) = v if ( v . gt . vzmax ( j )) vzmax ( j ) = v end if pchgl = zero pchgc = zero pchga = zero denom = pil + pic + pia powlandau = 1.d0 - dexp ( - 2.d0 * pil ) powdamped = 1.d0 - dexp ( - 2.d0 * denom ) domin = powpr * powdamped if ( denom . ne . zero ) then !!       pchgl=powpr*(1.d0-dexp(-2d0*pil)) !!       pchgc=powpr*dexp(-2d0*pil)*dabs(-2d0*pic) !!       pchga=powpr*dexp(-2d0*pil)*dabs(-2d0*pia) fff = domin / denom pchgl = dabs ( pil * fff ) pchgc = dabs ( pic * fff ) pchga = dabs ( pia * fff ) end if dd = zero if ( pil . eq . zero ) go to 1 !no Landau absorption if ( powlandau . gt . pchm ) then !strong absorption ppv1 = ppv1 + pchgl if ( dabs ( df ). gt . tiny ) then dd = dabs ( - pchgl / vk ( j ) / ( df * 1.d10 )) dncount ( i , j ) = dncount ( i , j ) + 1.d0 else dd = zero end if dq1 ( i , j ) = dq1 ( i , j ) + dd else ! weak absorption ppv2 = ppv2 + pchgl dd = dabs ( 2.d0 * decv * powpr * 1.d-10 / vk ( j )) dncount ( i , j ) = dncount ( i , j ) + 1.d0 dq2 ( i , j ) = dq2 ( i , j ) + dd end if 1 continue dql ( i , j ) = dql ( i , j ) + dd pdl ( j ) = pdl ( j ) + pchgl pdc ( j ) = pdc ( j ) + pchgc pda ( j ) = pda ( j ) + pchga if ( ifast . eq . - 1 ) pdfast ( j ) = pdfast ( j ) + pchgl + pchgc + pchga if ( itend0 . gt . 0 ) then parn = cltn / v dvz = vrt - vlf dnpar = cltn * dvz / v ** 2 weight = ( refr ** 2 - eta ( j )) ** 2 / ( refr ** 2 * parn ** 3 ) !!!        adde=zze*(dd/dens(j))*weight !!!        e2perp(i,j)=e2perp(i,j)+adde addd = zza * ( dd / dens ( j )) * weight / fcoll ( j ) / refr ** 3 arg = clt / ( refr * valfa ) do k = 1 , kv if ( vperp ( k , j ). gt . arg ) then hevis = dsqrt (( vperp ( k , j ) - arg ) * ( vperp ( k , j ) + arg )) adda = addd * hevis dqi0 ( k , j ) = dqi0 ( k , j ) + adda * dnpar end if end do end if return end end module current module power implicit none contains end module power","tags":"","loc":"sourcefile\\3_current_and_power.f90.html"},{"title":"3_dispersion.f90 – FRTС project","text":"Contents Modules dispersion_module Source Code 3_dispersion.f90 Source Code module dispersion_module use kind_module implicit none real ( wp ) :: yn3 !!common /abefo/ yn3 integer :: ivar !!common /bdeo/ ivar integer :: icall1 , icall2 !common /aef2/ icall1,icall2 integer :: iroot !!common /beo/ iroot integer :: izn !!common /abcde/ izn integer :: ider !!common /be2/ ider real ( wp ) :: xnr1 , xnr2 , xnr3 , xnr4 !!common /be1/ xnr1,xnr2,xnr3,xnr4 real ( wp ) :: ynz , ynpopq !!common /bcef/ ynz,ynpopq integer iconv , irefl !!common /cefn/ iconv,irefl integer ipow , jfoundr !!common /ceg/ ipow,jfoundr integer :: ifound real ( wp ) :: vfound !!common /eg1/ vfound,ifound real ( wp ) :: pdec1 , pdec2 , pdec3 , pdecv , pdecal , dfdv integer :: icf1 , icf2 !!common /eg2/ pdec1,pdec2,pdec3,pdecv,pdecal,dfdv,icf1,icf2 real ( wp ) :: cf1 , cf2 , cf3 , cf4 , cf5 , cf6 !!common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 real ( wp ) :: dhdm , dhdnr , dhdtet , dhdr , ddn , dhdn3 , dhdv2v , dhdu2u !!common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u real ( wp ) :: znakstart !!common/direct/znakstart real ( wp ) :: g11 , g12 , g22 , g33 , gg , g , si , co !!common/metrika/g11,g12,g22,g33,gg,g,si,co real ( wp ) :: ham !!common/fjham/ham real ( wp ) :: pdec14 , pdec24 , pdec34 , idec !!common /df/ pdec14,pdec24,pdec34,idec real ( wp ) :: rsou ( 102 ), sou ( 102 ) integer :: npta !!common /asou/ rsou(102),sou(102),npta !! используется в source_new и ourlhcd2017 real ( wp ) :: dgdu ( 50 , 100 ) integer :: kzero ( 100 ) !!common /arr/ dgdu(50,100),kzero(100) !! используется в zatukh, ourlhcd2017 и alphas contains subroutine disp2 ( pa , yn2 , ptet , xnro , prt , prm ) use constants use approximation use plasma use rt_parameters implicit none real ( wp ), intent ( in ) :: pa real ( wp ), intent ( in ) :: yn2 real ( wp ), intent ( in ) :: ptet real ( wp ), intent ( inout ) :: xnro real ( wp ), intent ( inout ) :: prt real ( wp ), intent ( inout ) :: prm !use manager_mod, only: ivar, yn3, icall1, icall2 !use trajectory !, only: iroot, izn, ynz,ynpopq !implicit real*8 (a-h,o-z) !common /abcde/ izn!,iw !common /bcef/ ynz,ynpopq !common /aef2/ icall1,icall2 !common /be1/ xnr1,xnr2,xnr3,xnr4 !common /be2/ ider !common /cefn/ iconv,irefl !common /ceg/ ipow,jfoundr !common /eg1/ vfound,ifound !common /eg2/ pdec1,pdec2,pdec3,pdecv,pdecal,dfdv,icf1,icf2 !common /eg3/ cf1,cf2,cf3,cf4,cf5,cf6 !common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u !common/direct/znakstart !common/metrika/g11,g12,g22,g33,gg,g,si,co !common/fjham/ham integer :: jr real ( wp ) :: xdl , xdlp , xly , xlyp real ( wp ) :: xgm , xgmp , xmy , xmyp , xlyv , cotet , sitet real ( wp ) :: dxdr , dxdt , dzdr , dzdt real ( wp ) :: x0 , x0t , xj real ( wp ) :: g2v1 , g2jq , g3v real ( wp ) :: b , bp , bt real ( wp ) :: dxdrdt , dxdtdt , dzdrdt , dzdtdt real ( wp ) :: pn , fnr , fnrr , wpq , whe , v , u1 , u real ( wp ) :: e1 , e2 , e3 real ( wp ) :: ynzq real ( wp ) :: as , bs , cs , pnew , yny , gpr , dls real ( wp ) :: dl1 , ynpopq1 , al , bl , cl , cl1 , dll real ( wp ) :: s1 , p1 , p2 , p3 , ynzt , e2t , u1t , cot , sit real ( wp ) :: bpt , g2jqt , btt , xjt real ( wp ) :: g11t , g22t , g33t , g12t , gprt real ( wp ) :: dl2 , xnr , ynyt , dnym real ( wp ) :: dnx , dll1 , bat , e1t real ( wp ) :: s2 , dnm , v1 , v2 , vvt , vvm , vz , vt real ( wp ) :: s21 , sjg , s23 , s24 , s22 , sl1 real ( wp ) :: pnewt , fder , aimh , pnye , pnyi real ( wp ) :: tmp , fcoll , source , argum real ( wp ) :: dek1 , dek2 , dek3 !external zatukh !real(wp) :: zatukh iconv = 0 irefl = 0 if ( pa . ge . one . or . pa . le . zero ) goto 70 icall1 = icall1 + 1 xdl = fdf ( pa , cdl , ncoef , xdlp ) xly = fdf ( pa , cly , ncoef , xlyp ) xgm = fdf ( pa , cgm , ncoef , xgmp ) xmy = fdf ( pa , cmy , ncoef , xmyp ) xlyv = xlyp * pa + xly cotet = dcos ( ptet ) sitet = dsin ( ptet ) dxdr =- xdlp + cotet - xgmp * sitet ** 2 dxdt =- ( pa + two * xgm * cotet ) * sitet dzdr = xlyv * sitet dzdt = xly * pa * cotet x0 = r0 / rm - xdl + pa * cotet - xgm * sitet ** 2 dxdrdt =- sitet - two * xgmp * sitet * cotet dzdrdt = xlyv * cotet dxdtdt =- pa * cotet - two * xgm * ( cotet ** 2 - sitet ** 2 ) dzdtdt =- xly * pa * sitet x0t = dxdt !-------------------------------------- ! components of metric tensor !-------------------------------------- g11 = dxdr ** 2 + dzdr ** 2 g22 = dxdt ** 2 + dzdt ** 2 g12 = dxdr * dxdt + dzdr * dzdt g33 = x0 ** 2 xj = ( dzdr * dxdt - dxdr * dzdt ) ** 2 !gg=g11*g22-g12*g12 gg = xj g = xj * g33 g2v1 = one / dsqrt ( g22 ) g2jq = dsqrt ( g22 / xj ) g3v = one / dsqrt ( g33 ) !-------------------------------------- !  magnetic field !-------------------------------------- bt = b_tor * ( r0 / rm ) / x0 bp = g2jq * g3v * xmy b = dsqrt ( bp * bp + bt * bt ) si = bp / b co = bt / b if ( ivar . eq . 1 ) return !--------------------------------------- ! components of dielectric tensor !--------------------------------------- !sav2008      pn=fn(pa) !var      pn=fn1(pa,fnr) !!      pn=fn1(pa,fnr) !!      pn=fn2(pa,fnr,fnrr) !sav2008 if ( inew . eq . 0 ) then !vardens pn = fn1 ( pa , fnr ) else pn = fn2 ( pa , fnr , fnrr ) end if wpq = c0 ** 2 * pn whe = b * c1 v = wpq / ww ** 2 u1 = whe / ww u = u1 ** 2 e1 = one - v * ( one / xmi - one / u ) e2 = v / u1 e3 = one - v !------------------------------------- ! dispersion equation !-------------------------------------- !sav2008      if(ivar.eq.2) yn2=(ynz-yn3*co*g3v)/(si*g2v1) ynz = yn2 * si * g2v1 + yn3 * co * g3v ynzq = ynz ** 2 as = e1 bs =- ( e1 ** 2 - e2 ** 2 + e1 * e3 - ( e1 + e3 ) * ynzq ) cs = e3 * ( e1 ** 2 - e2 ** 2 - two * e1 * ynzq + ynzq ** 2 ) !----------------------------- !est !sav2009 pnew = zero yny = - ( yn2 * g2v1 * co - yn3 * g3v * si ) if ( inew . gt . 0 ) then if ( inew . eq . 1 ) then yny = - ( yn2 * g2v1 * co - yn3 * g3v * si ) else if ( inew . eq . 2 ) then yny = - g2jq * ( yn2 * g2v1 * co - yn3 * g3v * si ) end if gpr = c0 ** 2 / ww ** 2 / u1 * fnr * xsz pnew = yny * gpr bs = bs + pnew cs = cs + pnew * ( ynzq - e3 ) end if !------------------------------------ dls = bs * bs - 4 d0 * as * cs !c      write(*,*)'rho=',pa,' teta=',ptet !c      write(*,*)'N2=',yn2,' N3=',yn3 !c      write(*,*)'Npar=',ynz,' e1=',e1 !c      write(*,*)'v=',v,' u=',u !c      write(*,*)'whe=',whe,' ww=',ww !c      write(*,*)'e2=',e2,' e3=',e3 !c      write(*,*)'bs=',bs,' as=',as !c      write(*,*)'cs=',cs,' dls=',dls !c      pause if ( dls . lt . zero ) then goto ( 60 , 20 , 10 ) iroot 10 xnr1 = 1 d + 10 xnr2 = 1 d + 10 xnr3 = 1 d + 10 xnr4 = 1 d + 10 return 20 prt = dls prm = 666 d0 return end if 30 continue dl1 = dfloat ( iw ) * dsqrt ( dls ) / two / as if ( iw . eq . - 1 ) ynpopq =- bs / ( two * as ) + dl1 if ( iw . eq . 1 ) ynpopq = two * cs / ( - bs - two * as * dl1 ) if ( iroot . eq . 3 ) ynpopq1 =- bs / ( two * as ) - dl1 !cc      write(*,*)'iw=',iw,' izn=',izn,' Nperp=',dsqrt(ynpopq) !cc      write(*,*)'Nperp2=',ynpopq,' ynpopq1=',-bs/(two*as)-dl1 !cc      pause if ( ynpopq . lt . zero . and . iroot . eq . 1 ) goto 70 al = g22 / xj bl =- yn2 * g12 / xj cl = g11 * yn2 ** 2 / xj + yn3 ** 2 / g33 - ynzq - ynpopq if ( iroot . eq . 3 ) cl1 = g11 * yn2 ** 2 / xj + yn3 ** 2 / g33 - ynzq - ynpopq1 dll = bl * bl - al * cl if ( iroot . eq . 2 ) then prt = dls prm = dll if ( dll . ge . zero ) then !sav2008 !!old variant: !cc        dl2=-dfloat(izn)*dsqrt(dll)/al !cc        if(izn.eq.1) xnr=-bl/al+dl2 !cc        if(izn.eq.-1) xnr=cl/(-bl-al*dl2) !cc        xnro=xnr !cc       end if !cc       return !cc      end if !!!!!!!!!!!!!! !!new variant: izn = 1 dl2 =- dsqrt ( dll ) / al xnr =- bl / al + dl2 call dhdomega ( pa , ptet , xnr , yn2 ) !cc        write(*,*)'#1: izn=',izn,' dl2=',dl2,' xnr=',xnr !cc        write(*,*)'znak=',znakstart,' -znak*dhdnr=',-znakstart*dhdnr if ( - znakstart * dhdnr . gt . zero ) then izn =- 1 dl2 = dsqrt ( dll ) / al xnr = cl / ( - bl - al * dl2 ) call dhdomega ( pa , ptet , xnr , yn2 ) !cc         write(*,*)'#2: izn=',izn,' dl2=',dl2,' xnr=',xnr !cc         write(*,*)'znak=',znakstart,' -znak*dhdnr=',-znakstart*dhdnr if ( - znakstart * dhdnr . gt . zero ) then write ( * , * ) 'Exception: both modes go outward !!' stop end if end if xnro = xnr !cc        pause end if return end if if ( dll . lt . zero ) goto ( 70 , 70 , 50 ) iroot 40 dl2 =- dfloat ( izn ) * dsqrt ( dll ) / al if ( izn . eq . 1 ) xnr =- bl / al + dl2 if ( izn . eq . - 1 ) xnr = cl / ( - bl - al * dl2 ) xnro = xnr if ( ivar . gt . 1 ) then !cccccc  find Nr of reflected wave dnx = two * as * ynpopq + bs dhdnr = dnx * ( two * g22 * xnr - two * g12 * yn2 ) / xj if ( - znakstart * dhdnr . gt . zero ) then izn =- izn goto 40 end if return end if 50 if ( iroot . eq . 3 ) then !--------------------------- !  find all roots !---------------------------- if ( dll . ge . zero ) then xnr1 = xnr xnr2 =- bl / al - dl2 else xnr1 = 1 d + 10 xnr2 = 1 d + 10 end if dll1 = bl ** 2 - al * cl1 if ( dll1 . lt . zero ) then xnr3 = 1 d + 10 xnr4 = 1 d + 10 else xnr3 =- bl / al - izn * dsqrt ( dll1 ) / al xnr4 =- bl / al + izn * dsqrt ( dll1 ) / al end if end if if ( ider . eq . 0 ) then prt = 0 d0 prm = 0 d0 return end if !-------------------------------------- !   calculation of derivatives !-------------------------------------- g11t = two * ( dxdr * dxdrdt + dzdr * dzdrdt ) g22t = two * ( dxdt * dxdtdt + dzdt * dzdtdt ) g33t = two * x0 * ( - pa * sitet - two * xgm * sitet * cotet ) g12t = dxdrdt * dxdt + dxdr * dxdtdt + dzdrdt * dzdt + dzdr * dzdtdt xjt = g11t * g22 + g22t * g11 - two * g12 * g12t btt =- b_tor * ( r0 / rm ) / x0 ** 2 * x0t g2jqt = ( g22t / xj - g22 / xj ** 2 * xjt ) / ( g2jq * two ) bpt = xmy * ( g2jqt * g3v - . 5 d0 * g2jq * g3v / g33 * g33t ) bat = one / b * ( bp * bpt + bt * btt ) sit = bpt / b - bp / b ** 2 * bat cot = btt / b - bt / b ** 2 * bat u1t = c1 / ww * bat e1t =- v / u ** 2 * two * u1 * u1t e2t =- v / u * u1t ynzt = yn2 * sit * g2v1 - yn2 * si * g2v1 ** 3 / two * g22t + yn3 * cot * g3v - yn3 * co * g3v ** 3 / two * g33t p1 = two * ynz * ynzt p2 = e1t p3 = ( e2 * e2t ) / e1 - e2 ** 2 / ( two * e1 ** 2 ) * e1t s1 =- p2 / ( two * e1 ** 2 ) * e3 * ( ynzq - e1 ) + ( e3 + e1 ) / ( two * e1 ) * ( p1 - p2 ) + p3 s2 = two * e3 / e1 * ( ynzq - e1 ) * ( p1 - p2 ) - p2 * e3 / ( e1 ** 2 ) * ( ynzq - e1 ) ** 2 - two * e3 * p3 dnm = two * ynz * si * g2v1 v1 = ( e3 + e1 ) / ( two * e1 ) * dnm v2 = two * e3 / e1 * ( ynzq - e1 ) * dnm !----------------------------------- !est !sav2009 if ( inew . gt . 0 ) then gprt =- c0 ** 2 / ww ** 2 * fnr / u * u1t * xsz if ( inew . eq . 1 ) then ynyt = - ( yn2 * cot * g2v1 - yn2 * co * g2v1 ** 3 / two * g22t - ( yn3 * sit * g3v - yn3 * si * g3v ** 3 / two * g33t )) dnym = - co * g2v1 else if ( inew . eq . 2 ) then ynyt = - g2jq * ( yn2 * cot * g2v1 - yn2 * co * g2v1 ** 3 / two * g22t - ( yn3 * sit * g3v - yn3 * si * g3v ** 3 / two * g33t )) ynyt = ynyt - g2jqt * ( yn2 * g2v1 * co - yn3 * g3v * si ) dnym = - g2jq * co * g2v1 end if pnewt = ( ynyt * gpr + yny * gprt ) s1 = s1 + pnewt / ( two * e1 ) - pnew / ( two * e1 ** 2 ) * e1t s2 = s2 + ( pnewt * ( ynzq - e3 ) + pnew * p1 ) / e1 - pnew * ( ynzq - e3 ) / e1 ** 2 * e1t v1 = v1 + dnym * gpr / ( two * e1 ) v2 = v2 + gpr * ( dnym * ( ynzq - e3 ) + yny * dnm ) / e1 end if !--------------------------------------------- vvt =- s1 + ( bs / as * s1 - s2 ) / ( two * dl1 ) vvm =- v1 + ( bs / as * v1 - v2 ) / ( two * dl1 ) s1 =- yn2 * ( g12t / g22 - g12 / g22 ** 2 * g22t ) s21 = yn2 ** 2 * ( g11t / g22 - g11 / g22 ** 2 * g22t ) s22 = yn3 ** 2 * ( xjt / ( g33 * g22 ) - xj / ( g33 * g22 ) ** 2 * ( g33t * g22 + g22t * g33 ) ) sjg = ( xjt * g22 - xj * g22t ) / g22 ** 2 s23 = two * ynz * ynzt * xj / g22 + sjg * ynzq s24 = vvt * xj / g22 + ynpopq * sjg s2 = s21 + s22 - s23 - s24 prt =- s1 + ( two * ( bl / al ) * s1 - s2 ) / ( two * dl2 ) s1 =- g12 / g22 s21 = two * yn2 * g11 / g22 s22 = dnm * xj / g22 s23 = vvm * xj / g22 s2 = s21 - s22 - s23 prm =- s1 + ( two * ( bl / al ) * s1 - s2 ) / ( two * dl2 ) if ( ipow . gt . 0 ) then !-------------------------------------- !  calculation of decrements !-------------------------------------- dnx = two * as * ynpopq + bs dhdnr = dnx * ( two * g22 * xnr - two * g12 * yn2 ) / xj sl1 = ( ynzq - e1 ) * ( ynzq + ynpopq - e1 ) - e2 ** 2 cf3 = ynz cf4 = xnr cf5 = yn2 vz = cltn / dabs ( ynz ) if ( vz . gt . cltn ) vz = cltn !sav2010 vt = fvt ( pa ) jr = jfoundr icf1 = iw icf2 = izn call distr ( vz , jr , ifound , fder ) dfdv = fder vfound = vz cf2 = ptet cf6 = yny aimh = wpq / ww ** 2 * pi * sl1 * cltn ** 2 / ynzq pdecv = dabs ( aimh / dhdnr / xsz ) !!        pdec1=-pdecv*dfdv pdec1 = dabs ( pdecv * dfdv ) pnye = cnye * wpq ** 2 / ( pn * vt ** 3 ) pnyi = cnyi * pnye * zefff ( pa ) pdec2 = dabs ( pnyi / ww * ( wpq / whe ** 2 * ynpopq + wpq / ww ** 2 * ynzq ) * ynpopq / dhdnr / xsz ) cf1 = dsqrt ( ynpopq ) if ( itend0 . gt . 0 ) then tmp = ft ( pa ) / 0.16d-8 fcoll = . 5 d - 13 * pn * zalfa ** 2 * xlog / xmalfa / tmp ** 1.5d0 !cc          ddens=dn1*pn !cc          tdens=dn2*pn !cc          tt=fti(pa)**0.33333d0    ! (ti, kev)&#94;1/3 !cc          source=4d-12*factor*ddens*tdens*dexp(-20d0/tt)/tt**2 call source_new ( pa , source ) dek1 = cnstal * pdecv * ( 1.d0 - e3 / ynpopq ) ** 2 / cf1 dek2 = source / ( fcoll * pn ) pdecal = dek1 * dek2 pdec3 = zero if ( itend0 . gt . 0 ) then argum = clt / ( cf1 * valfa ) dek3 = zatukh ( argum , jr , vperp , kv ) pdec3 = pdecal * dek3 end if end if end if return ! conversion 60 iconv = 1 if ( ivar . ne . 0 ) ivar =- 1 return !  reflection 70 irefl = 1 if ( ivar . gt . 1. and . ivar . ne . 10 ) then iw =- iw ivar = 10 goto 30 end if if ( ivar . eq . 10 ) ivar =- 1 return end subroutine disp4 ( pa , ptet , xnr , yn2 ) use constants use approximation use plasma use rt_parameters !use trajectory, only: !use dispersion_module, only: yn3, icall1, icall2, ynz, ynpopq !use dispersion_module, only: disp2, source_new implicit real * 8 ( a - h , o - z ) !common /bcef/ ynz,ynpopq !common /aef2/ icall1,icall2 !integer :: irefl, iconv !common /cefn/ iconv,irefl !common /df/ pdec14,pdec24,pdec34,idec !common/metrika/g11,g12,g22,g33,gg,g,si,co !common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u !common/fjham/ham integer :: idec irefl = 0 iconv = 0 if ( pa . eq . zero ) pa = 1.d-7 if ( pa . lt . zero ) pa = dabs ( pa ) !sav2008      if(pa.gt.one) then !sav2008       dhdm=666d0 !sav2008       dhdtet=-666d0 !sav2008       dhdnr=666d0 !sav2008       dhdr=-666d0 !sav2008       irefl=1 !sav2008       return !sav2008      end if icall2 = icall2 + 1 !!      pn=fn1(pa,fnr) !!      pn=fn2(pa,fnr,fnrr) if ( inew . eq . 0 ) then !vardens pn = fn1 ( pa , fnr ) else pn = fn2 ( pa , fnr , fnrr ) end if !cc        hstp=1.d-7 !cc        pplus=fn2(pa+hstp,fnr2,fnrr2) !cc        pminus=fn2(pa-hstp,fnr1,fnrr1) !cc        fnr=0.5d0*(pplus-pminus)/hstp !cc        fnrr=0.5d0*(fnr2-fnr1)/hstp !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! wpq = c0 ** 2 * pn xdl = fdfddf ( pa , cdl , ncoef , xdlp , xdlpp ) xly = fdfddf ( pa , cly , ncoef , xlyp , xlypp ) xgm = fdfddf ( pa , cgm , ncoef , xgmp , xgmpp ) xmy = fdf ( pa , cmy , ncoef , xmyp ) cotet = dcos ( ptet ) sitet = dsin ( ptet ) xlyv = xly + xlyp * pa !-------------------------------------- ! components of metric tensor !-------------------------------------- dxdr =- xdlp + cotet - xgmp * sitet ** 2 dxdt =- ( pa + two * xgm * cotet ) * sitet dzdr = xlyv * sitet dzdt = xly * pa * cotet x0 = r0 / rm - xdl + pa * cotet - xgm * sitet ** 2 dxdrdr =- xdlpp - xgmpp * sitet ** 2 dxdtdt =- cotet * ( pa + two * xgm * cotet ) + sitet ** 2 * two * xgm dxdtdr =- sitet * ( one + two * xgmp * cotet ) dxdrdt = dxdtdr dzdrdr = ( two * xlyp + pa * xlypp ) * sitet dzdtdt =- xly * pa * sitet dzdtdr = xlyv * cotet dzdrdt = dzdtdr x0t = dxdt x0r = dxdr g11 = dxdr ** 2 + dzdr ** 2 g22 = dxdt ** 2 + dzdt ** 2 g12 = dxdr * dxdt + dzdr * dzdt g33 = x0 ** 2 xj = ( dzdr * dxdt - dxdr * dzdt ) ** 2 !gg=g11*g22-g12*g12 gg = xj g = xj * g33 g2jq = dsqrt ( g22 / xj ) g2gq = dsqrt ( g22 / g ) g22q = dsqrt ( g22 ) g33q = dsqrt ( g33 ) !c-------------------------------------- !c  magnetic field !c-------------------------------------- bt = b_tor * ( r0 / rm ) / x0 bp = g2gq * xmy b = dsqrt ( bp * bp + bt * bt ) whe = b * c1 si = bp / b co = bt / b !c--------------------------------------- !c components of dielectric tensor !c--------------------------------------- v = wpq / ww ** 2 u1 = whe / ww u = u1 ** 2 e1 = one - v * ( one / xmi - one / u ) e2 = v / u1 e3 = one - v !c------------------------------------- !c dispersion equation !c-------------------------------------- ynz = yn2 * si / g22q + yn3 * co / g33q ynzq = ynz ** 2 vpop = xnr ** 2 * g22 - two * xnr * yn2 * g12 + g11 * yn2 ** 2 ynpopq = vpop / xj + yn3 ** 2 / g33 - ynzq as = e1 bs =- ( e1 ** 2 - e2 ** 2 + e1 * e3 - ( e1 + e3 ) * ynzq ) cs = e3 * ( e1 ** 2 - e2 ** 2 - two * e1 * ynzq + ynzq ** 2 ) !c---------------------------------------------------- !sav2009 dhdv = ( 1.d0 / ( u ** 2 * xmi ** 2 )) * (( 2.d0 - 2.d0 * ynpopq - 3.d0 * v ) * v * xmi ** 2 - & u ** 2 * ( 3.d0 * v ** 2 + 2.d0 * v * ( - 1.d0 + ynpopq * ( 1.d0 + xmi )& + 2.d0 * xmi * ( - 1.d0 + ynzq )) + & xmi * ( - 2.d0 + ynpopq + xmi * ( - 1.d0 + ynzq )) * ( - 1.d0 + ynpopq + ynzq ))& + u * xmi * ( 3.d0 * v ** 2 * ( 2.d0 + xmi )& + ( - 2.d0 + ynpopq ) * xmi * ( - 1.d0 + ynpopq + ynzq )& + v * ( - 4.d0 + 4.d0 * ynpopq * ( 1.d0 + xmi ) + xmi * ( - 6.d0 + 4.d0 * ynzq )))) dhdu =- ( 1.d0 / ( u ** 3 * xmi )) * ( v * ( - 1.d0 + ynpopq + v ) * ( 2.d0 * u * v - 2.d0 * v * xmi & + u * ( - 2.d0 + ynpopq + v ) * xmi ) + u * v * ( - 2.d0 + ynpopq + 2.d0 * v ) * xmi * ynzq ) dhdv2v = 2.d0 * v * dhdv !w*d(-H)/dv dhdu2u = 2.d0 * u * dhdu !w*d(-H)/du !c---------------------------------------------------- !est !sav2009 if ( inew . gt . 0 ) then if ( inew . eq . 1 ) then yny = - ( yn2 * co / g22q - yn3 * si / g33q ) else if ( inew . eq . 2 ) then yny = - g2jq * ( yn2 * co / g22q - yn3 * si / g33q ) end if gpr = c0 ** 2 / ww ** 2 / u1 * fnr * xsz gdop = yny * gpr bs = bs + gdop cs = cs + gdop * ( ynzq - e3 ) !sav2009: dgpr =- gpr !w*d(gpr)/dw wde3dw = 2.d0 * v !w*d(e3)/dw wdbsdw = yny * dgpr !w*d(bs)/dw wdcsdw = ( ynzq - e3 ) * wdbsdw - gdop * wde3dw !w*d(cs)/dw wdhdw = wdbsdw * ynpopq + wdcsdw !w*d(H1)/dw dhdv2v = dhdv2v - wdhdw !correction to dhdv2v: w*d(-H)/dv+w*d(-H1)/dw end if ham = as * ynpopq ** 2 + bs * ynpopq + cs !sav2009 !-------------------------------------------------------- !!      dl=bs**2-4d0*as*bs !c-------------------------------------- !c   calculation of derivatives !c-------------------------------------- g11r = two * dxdr * dxdrdr + two * dzdr * dzdrdr g22r = two * dxdt * dxdtdr + two * dzdt * dzdtdr g11t = two * dxdr * dxdrdt + two * dzdr * dzdrdt g22t = two * dxdt * dxdtdt + two * dzdt * dzdtdt g12r = dxdrdr * dxdt + dxdr * dxdtdr + dzdrdr * dzdt + dzdr * dzdtdr g12t = dxdrdt * dxdt + dxdr * dxdtdt + dzdrdt * dzdt + dzdr * dzdtdt g33r = two * x0 * x0r g33t = two * x0 * x0t g22qr = g22r / ( g22q * two ) g22qt = g22t / ( g22q * two ) g33qr = g33r / ( g33q * two ) g33qt = g33t / ( g33q * two ) xjr = g11r * g22 + g22r * g11 - two * g12 * g12r xjt = g11t * g22 + g22t * g11 - two * g12 * g12t g2jqr = ( g22r / xj - g22 / xj ** 2 * xjr ) / ( g2jq * two ) !sav2009 g2jqt = ( g22t / xj - g22 / xj ** 2 * xjt ) / ( g2jq * two ) !sav2009 gr = xjr * g33 + g33r * xj gt = xjt * g33 + g33t * xj g2gqt = ( g22t / g - g22 / g ** 2 * gt ) / ( g2gq * two ) g2gqr = ( g22r / g - g22 / g ** 2 * gr ) / ( g2gq * two ) bpt = xmy * g2gqt bpr = g2gqr * xmy + g2gq * xmyp btr =- b_tor * ( r0 / rm ) / x0 ** 2 * x0r btt =- b_tor * ( r0 / rm ) / x0 ** 2 * x0t bat = one / b * ( bp * bpt + bt * btt ) bar = one / b * ( bp * bpr + bt * btr ) sit = bpt / b - bp / b ** 2 * bat cot = btt / b - bt / b ** 2 * bat sir = bpr / b - bp / b ** 2 * bar cor = btr / b - bt / b ** 2 * bar dvdr = fnr * c0 ** 2 / ww ** 2 du1dr = c1 * bar / ww dudr = two * u1 * du1dr du1dt = c1 * bat / ww dudt = two * u1 * du1dt e1r =- dvdr * ( one / xmi - one / u ) - v * dudr / u ** 2 e1t =- v * dudt / u ** 2 e2r = dvdr / u1 - v / u1 ** 2 * du1dr e2t =- v / u1 ** 2 * du1dt e3r =- dvdr ynzr = yn2 * ( sir / g22q - si / g22q ** 2 * g22qr ) + yn3 * ( cor / g33q - co / g33q ** 2 * g33qr ) ynzt = yn2 * ( sit / g22q - si / g22q ** 2 * g22qt ) + yn3 * ( cot / g33q - co / g33q ** 2 * g33qt ) ynzqr = two * ynz * ynzr ynzqt = two * ynz * ynzt vpopr = ( xnr ** 2 * g22r - two * xnr * yn2 * g12r + yn2 ** 2 * g11r ) vpopt = ( xnr ** 2 * g22t - two * xnr * yn2 * g12t + yn2 ** 2 * g11t ) ynpopqr = vpopr / xj - vpop / xj ** 2 * xjr - yn3 ** 2 / g33 ** 2 * g33r - ynzqr ynpopqt = vpopt / xj - vpop / xj ** 2 * xjt - yn3 ** 2 / g33 ** 2 * g33t - ynzqt asr = e1r bsr = ( e3r + e1r ) * ( ynzq - e1 ) + ( e3 + e1 ) * ( ynzqr - e1r ) + two * e2 * e2r csr = e3r * (( ynzq - e1 ) ** 2 - e2 ** 2 ) + e3 * ( two * ( ynzq - e1 ) * ( ynzqr - e1r ) - two * e2 * e2r ) ast = e1t bst = e1t * ( ynzq - e1 ) + ( e3 + e1 ) * ( ynzqt - e1t ) + two * e2 * e2t cst = e3 * ( two * ( ynzq - e1 ) * ( ynzqt - e1t ) - two * e2 * e2t ) !--------------------------------------------------- !est !sav2009 if ( inew . gt . 0 ) then if ( inew . eq . 1 ) then ynyr = - ( yn2 * ( cor / g22q - co / g22q ** 2 * g22qr )& - yn3 * ( sir / g33q - si / g33q ** 2 * g33qr )) ynyt = - ( yn2 * ( cot / g22q - co / g22q ** 2 * g22qt ) - & - yn3 * ( sit / g33q - si / g33q ** 2 * g33qt )) else if ( inew . eq . 2 ) then ynyr = - g2jq * ( yn2 * ( cor / g22q - co / g22q ** 2 * g22qr )& - yn3 * ( sir / g33q - si / g33q ** 2 * g33qr )) ynyr = ynyr - g2jqr * ( yn2 * co / g22q - yn3 * si / g33q ) ynyt = - g2jq * ( yn2 * ( cot / g22q - co / g22q ** 2 * g22qt ) - & - yn3 * ( sit / g33q - si / g33q ** 2 * g33qt )) ynyt = ynyt - g2jqt * ( yn2 * co / g22q - yn3 * si / g33q ) end if gprr = c0 ** 2 / ww ** 2 * ( fnrr / u1 - fnr / u1 ** 2 * du1dr ) * xsz gprt =- c0 ** 2 / ww ** 2 * fnr / u1 ** 2 * du1dt * xsz gdopr = ynyr * gpr + yny * gprr gdopt = ynyt * gpr + yny * gprt bsr = bsr + gdopr csr = csr + gdopr * ( ynzq - e3 ) + gdop * ( ynzqr - e3r ) bst = bst + gdopt cst = cst + gdopt * ( ynzq - e3 ) + gdop * ynzqt end if !c--------------------------------------------------- dhdr = asr * ynpopq ** 2 + bsr * ynpopq + & as * two * ynpopq * ynpopqr + bs * ynpopqr + csr dhdtet = ast * ynpopq ** 2 + bst * ynpopq + & as * two * ynpopq * ynpopqt + bs * ynpopqt + cst dnx = two * as * ynpopq + bs dnz = ynpopq * ( e1 + e3 ) + two * ( ynzq - e1 ) * e3 dhdnr = dnx * two * ( g22 * xnr - g12 * yn2 ) / xj dhdm = dnx * two * ( yn2 * g11 - xnr * g12 ) / xj + ( dnz - dnx ) * two * ynz * si / g22q !sav2009 dhdn3 = two * (( yn3 - ynz * co * g33q ) * dnx + ynz * co * g33q * dnz ) / g33 !sav2009 !c---------------------------------------------------------------- !est !sav2009 if ( inew . gt . 0 ) then if ( inew . eq . 1 ) then dny = - gpr * ( ynpopq + ynzq - e3 ) else if ( inew . eq . 2 ) then dny = - g2jq * gpr * ( ynpopq + ynzq - e3 ) end if dhdm = dhdm + dny * co / g22q + two * ynz * yny * gpr * si / g22q dhdn3 = dhdn3 - dny * si / g33q + two * ynz * yny * gpr * co / g33q !sav2009 end if !c--------------------------------------------------- !sav2009 ddn2 = g11 * dhdnr ** 2 + g22 * dhdm ** 2 + 2.d0 * g12 * dhdnr * dhdm + g33 * dhdn3 ** 2 ddn = dsqrt ( ddn2 ) ! if ( idec . ne . 0 ) then vt = fvt ( pa ) sl1 = ( ynzq - e1 ) * ( ynzq + ynpopq - e1 ) - e2 ** 2 aimh = wpq / ww ** 2 * pi * sl1 * cltn ** 2 / ynzq pdec14 = dabs ( aimh / xsz / ddn ) pnye = cnye * wpq ** 2 / ( pn * vt ** 3 ) pnyi = cnyi * pnye * zefff ( pa ) pdec24 = dabs ( pnyi / ww * ( wpq / whe ** 2 * ynpopq + wpq / ww ** 2 * ynzq ) * ynpopq / & xsz / ddn ) if ( itend0 . gt . 0 ) then tmp = ft ( pa ) / 0.16d-8 fcoll = . 5 d - 13 * pn * zalfa ** 2 * xlog / xmalfa / tmp ** 1.5d0 !cc        ddens=dn1*pn !cc        tdens=dn2*pn !cc        tt=fti(pa)**0.33333d0    ! (ti, kev)&#94;1/3 !cc        source=4d-12*factor*ddens*tdens*dexp(-20d0/tt)/tt**2 call source_new ( pa , source ) dek1 = cnstal * pdec14 * ( 1.d0 - e3 / ynpopq ) ** 2 / dsqrt ( ynpopq ) dek2 = source / ( fcoll * pn ) pdec34 = dek1 * dek2 end if end if end subroutine dhdomega ( rho , theta , yn1 , yn2 ) !use dispersion_module, only: yn3 implicit real * 8 ( a - h , o - z ) !common /a0ef2/ ww !common /abefo/ yn3 !common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u !common/direct/znakstart parameter ( zero = 0.d0 , h = 1.d-6 ) call disp4 ( rho , theta , yn1 , yn2 ) !!w*dH/dw=wdhdw: wdhdw =- ( yn1 * dhdnr + yn2 * dhdm + yn3 * dhdn3 + dhdv2v + dhdu2u ) znak = dsign ( 1.d0 , wdhdw ) znakstart = znak !c      write(*,*)'formula: znak=',znak !c      write(*,*)'wdhdw=',wdhdw,' H=',ham !c      write(*,*)'rho=',rho,' teta=',theta !c      write(*,*)'yn1=',yn1,' yn2=',yn2 !c      write(*,*)'dhdnr=',dhdnr,' dhdm=',dhdm !c      write(*,*)'dhdr=',dhdr,' dhdtet=',dhdtet !c      write(*,*)'dhdn3=',dhdn3,' yn3=',yn3 !c      write(*,*)'yn1*dhdnr=',yn1*dhdnr,' yn2*dhdm=',yn2*dhdm !c      write(*,*)'yn1*dhdnr+yn2*dhdm=',yn1*dhdnr+yn2*dhdm !cc      pause end subroutine source_new ( r , out ) use lock_module implicit real * 8 ( a - h , o - z ) integer npta , klo , khi , ierr !common /asou/ rsou(102),sou(102),npta call lock2 ( rsou , npta , r , klo , khi , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) 'lock2 error in source_new' write ( * , * ) 'ierr=' , ierr , ' rho=' , r stop else call linf ( rsou , sou , r , fout , klo , khi ) out = dabs ( fout ) end if end real ( wp ) function zatukh ( psy , j , u , n ) use constants implicit real * 8 ( a - h , o - z ) real ( wp ), intent ( in ) :: psy real ( wp ), intent ( in ) :: u (:,:) integer , intent ( in ) :: j , n dimension x ( 50 ), y ( 50 ), a ( 50 ), b ( 50 ) !common /a0befr/ pi,pi2 !common /arr/ dgdu(50,100),kzero(100) integer :: km , k , i , l km = kzero ( j ) um = u ( km , j ) if ( um . ge . one ) then zatukh = zero if ( psy . lt . one ) zatukh = . 5 d0 * pi / psy ** 3 return end if if ( psy - um . le . zero . or . u ( n , j ) - psy . le . zero ) then zatukh = zero return end if do k = 1 , n x ( k ) = u ( k , j ) y ( k ) = dgdu ( k , j ) end do i = n - 1 do l = 1 , n - 1 if ( x ( l + 1 ) - psy . gt . zero . and . psy - x ( l ). ge . zero ) i = l end do do k = i , n - 1 b ( k ) = ( y ( k + 1 ) - y ( k )) / ( x ( k + 1 ) - x ( k )) a ( k ) = y ( k ) - b ( k ) * x ( k ) end do s2 = sqrt (( x ( i + 1 ) - psy ) * ( x ( i + 1 ) + psy )) ss2 = x ( i + 1 ) + s2 sum = a ( i ) * log ( psy / ss2 ) - b ( i ) * s2 do k = 2 , n - i s1 = sqrt (( x ( i + k - 1 ) - psy ) * ( x ( i + k - 1 ) + psy )) ss1 = x ( i + k - 1 ) + s1 s2 = sqrt (( x ( i + k ) - psy ) * ( x ( i + k ) + psy )) ss2 = x ( i + k ) + s2 sum = sum + a ( i + k - 1 ) * log ( ss1 / ss2 ) + b ( i + k - 1 ) * ( s1 - s2 ) end do zatukh = sum return end subroutine extd4 ( x , y , dydx ) !use dispersion_module implicit none !implicit real(wp) (a-h,o-z) real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y (:) real ( wp ), intent ( inout ) :: dydx (:) !common/fj/dhdm,dhdnr,dhdtet,dhdr,ddn,dhdn3,dhdv2v,dhdu2u !common/direct/znakstart real ( wp ) :: znak , xxx , ptet , yn2 , pa , yn1 znak = znakstart xxx = x ptet = y ( 1 ) yn2 = y ( 2 ) pa = y ( 3 ) yn1 = y ( 4 ) call disp4 ( pa , ptet , yn1 , yn2 ) !new variant dydx ( 1 ) =- znak * dhdm / ddn dydx ( 2 ) = znak * dhdtet / ddn dydx ( 3 ) =- znak * dhdnr / ddn dydx ( 4 ) = znak * dhdr / ddn !dydx(5)=-znak*dhdn3/ddn !! возможен выход за границы массива !c      dydx(1)=znak*dhdm/ddn !c      dydx(2)=-znak*dhdtet/ddn !c      dydx(3)=znak*dhdnr/ddn !c      dydx(4)=-znak*dhdr/ddn !c      dydx(5)=znak*dhdn3/ddn !old variant: !      dydx(1)=dhdm/ddn !      dydx(2)=-dhdtet/ddn !      dydx(3)=dhdnr/ddn !      dydx(4)=-dhdr/ddn !      dydx(5)=dhdn3/ddn end end module dispersion_module","tags":"","loc":"sourcefile\\3_dispersion.f90.html"},{"title":"3_flux_surface_mod.f90 – FRTС project","text":"Contents Modules FluxSurface_mod Source Code 3_flux_surface_mod.f90 Source Code module FluxSurface_mod !! все что связанно с магнитными поверхностями use kind_module type FluxSurface !! класс магнитной поверхности integer :: index !! номер магнитной поверхности real ( wp ) :: r !! радиус real ( wp ) :: vmax !! vmax=cltn/vto real ( wp ) :: vt !! наверно тепловая скорость электронов????? vt=fvt(r) integer :: ipt !! размер vgrid real ( wp ), allocatable :: vgrid (:) !! real ( wp ), allocatable :: vr_grid (:) !! бываший vrj real ( wp ), allocatable :: diffusion (:) !! бывший dijk(i,j,k) или dj(i) !   complex         :: inst_field1 contains !procedure :: set   => set_e !procedure :: print => e_print end type FluxSurface end module FluxSurface_mod","tags":"","loc":"sourcefile\\3_flux_surface_mod.f90.html"},{"title":"3_FokkerPlanck.f90 – FRTС project","text":"Contents Modules FokkerPlanck_module Source Code 3_FokkerPlanck.f90 Source Code module FokkerPlanck_module use kind_module implicit none contains !! calculation of distribution functions at time t1=t+dtau !! subroutine fokkerplanck_compute ( time , TAU ) use FokkerPlanck1D_mod use Utils use rt_parameters use writer_module use maxwell use plasma , only : fvt , enorm , fst implicit none type ( FokkerPlanck1D ) fokker_planck real ( wp ), intent ( in ) :: time , TAU real ( wp ) t , dtstep , dtau !integer nr !common /a0ab/ nr integer , parameter :: ntau = 10 !integer i0 !parameter(i0=1002) !real(wp) vij,fij0,fij,dfij,dij,enorm,fst !common/lh/vij(i0,100),fij0(i0,100,2),fij(i0,100,2),dfij(i0,100,2), dij(i0,100,2),enorm(100),fst(100) integer n , i , j , it , nt , k real ( wp ) xend , h , dt real ( wp ) znak , alfa2 , dt0 , h0 , r !common/ef/ alfa2 !real(wp) d0 !integer jindex,kindex !common/dddql/ d0,jindex,kindex parameter ( dt0 = 0.1d0 , h0 = 0.1d0 ) real time1 , time2 dtstep = TAU / dble ( ntau ) !seconds print * , 'fokkerplanck_compute' write ( * , * ) 'time=' , time , ' dt=' , dtstep time1 = sys_time () do j = 1 , nr jindex = j !common/dddql/ dtau = dtstep * fst ( j ) nt = 1 if ( dtau . gt . dt0 ) then nt = 1 + dtau / dt0 end if dt = dtau / nt r = dble ( j ) / dble ( nr + 1 ) xend = 3.d10 / fvt ( r ) do k = 1 , 2 kindex = k flag_d0 = . TRUE . ! d(x) enable znak = 2.d0 * dble ( k ) - 3.d0 fokker_planck = FokkerPlanck1D ( znak * enorm ( j ), xend , vij (:, j ), fij0 (:, j , k )) call fokker_planck % init_zero_diffusion do i = 1 , ntau call fokker_planck % solve_time_step ( dt , nt ) !call fokkerplanck1D_iter(alfa2, h, n, dt, nt, xend, d1, d2, d3, vij(:,j), fij0(:,j,k), out_fj) end do fij0 (:, j , k ) = fokker_planck % f flag_d0 = . FALSE . ! d(x) disable fokker_planck = FokkerPlanck1D ( znak * enorm ( j ), xend , vij (:, j ), fij (:, j , k )) call fokker_planck % init_diffusion ( dij (:, j , k )) do i = 1 , ntau call fokker_planck % solve_time_step ( dt , nt ) !call fokkerplanck1D_iter(alfa2, h, n, dt, nt, xend, d1, d2, d3, vij(:,j), fij(:,j,k),out_fj, dfij(:,j,k)) end do fij (:, j , k ) = fokker_planck % f end do call write_distribution ( fij0 (:, j , 2 ), i0 , time ) !call write_distribution(out_fj, n, time) end do write ( * , * ) 'fokkerplanck nr= ' , nr , ' ntau =' , ntau , 'nt =' , nt call write_v_array ( vij , fij0 (:, 1 : nr ,:), time , 'maxwell' ) call write_v_array ( vij , dij (:, 1 : nr ,:), time , 'diffusion' ) !call write_matrix(dij(1:i0,1:nr,1), time, 'diffusion') time2 = sys_time () - time1 print * , 'fokkerplanck_new eval time: ' , time2 end subroutine init_diffusion ( h , n , vj , dj , d1 , d2 , d3 ) ! инициализация диффузии для схемы савельева use lock_module implicit none integer , intent ( in ) :: n real ( wp ), intent ( in ) :: h real ( wp ), dimension (:), intent ( in ) :: vj , dj real ( wp ), dimension (:), intent ( out ) :: d1 , d2 , d3 real ( wp ), dimension (:), allocatable :: xx integer :: i0 integer i , klo , khi , ierr , klo1 , khi1 integer klo2 , klo3 , khi2 , khi3 , ierr1 , ierr2 , ierr3 i0 = size ( vj ) allocate ( xx ( n + 1 )) do i = 1 , n + 1 xx ( i ) = h / 2.d0 + h * dble ( i - 1 ) !+shift end do do i = 1 , n + 1 call lock ( vj , i0 , xx ( i ), klo1 , khi1 , ierr1 ) call lock ( vj , i0 , xx ( i ) - h / 2 d0 , klo2 , khi2 , ierr2 ) call lock ( vj , i0 , xx ( i ) + h / 2 d0 , klo3 , khi3 , ierr3 ) if ( ierr1 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo1=' , klo1 , 'khi1=' , khi1 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if if ( ierr2 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo2=' , klo2 , 'khi2=' , khi2 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if if ( ierr3 . eq . 1 ) then write ( * , * ) 'lock error in finction d2(x)' write ( * , * ) 'j=' , 123 , ' v=' , xx ( i ) write ( * , * ) 'klo3=' , klo3 , 'khi3=' , khi3 , 'i=' , i write ( * , * ) 'vj(1)=' , vj ( 1 ), ' vj(i0)=' , vj ( i0 ) pause stop end if d1 ( i ) = dj ( klo1 ) d2 ( i ) = dj ( klo2 ) d3 ( i ) = dj ( klo3 ) end do end subroutine end module FokkerPlanck_module","tags":"","loc":"sourcefile\\3_fokkerplanck.f90.html"},{"title":"3_iteration_result.f90 – FRTС project","text":"Contents Modules iteration_result_mod Source Code 3_iteration_result.f90 Source Code module iteration_result_mod use kind_module implicit none type IterationResult integer :: number !! iteration number 'iteration=',iterat integer :: spectr_direction !! 'ispectr=',ispectr real ( wp ) :: P_launched !!P_launched, MW=',plaun real ( wp ) :: P_landau !!'P_landau, MW=',ol real ( wp ) :: P_coll !! 'P_coll, MW=',oc real ( wp ) :: P_alph !!'P_alph, MW=',oa real ( wp ) :: alphas_power !!'Alphas power, MW=',fuspow real ( wp ) :: P_fast !write(*,*) 'P_fast (landau+coll), MW=',of real ( wp ) :: P_lost !write(*,*) 'P_lost, MW=',plost/xsgs real ( wp ) :: P_not_accounted !write(*,*) 'P_not accounted, MW=',pnab/xsgs real ( wp ) :: P_landau_strong_absorption !write(*,*) 'P_landau (strong absorption), MW=',ppv1/xsgs real ( wp ) :: P_landau_weak_absorption !write(*,*) 'P_landau (weak absorption), MW=',ppv2/xsgs real ( wp ) :: P_turns !write(*,*) 'P_turns, MW=', psum4/xsgs real ( wp ) :: efficiency !write(*,*) 'efficiency, I(MA)/P(MW)=',oi/plaun !sav2008 !call integral(1,nspl,rh,con,avedens) !sav2010 real ( wp ) :: avedens real ( wp ) :: r0 !write (*,*) '<Ne>, m&#94;-3=',avedens*1.d19,' R, m=',r0*1.d-2 real ( wp ) :: eta_eff !eta_eff=1.d17*avedens*r0*oi/plaun !write (*,*) 'eta_eff=<Ne>*R*I/P, A/(W*m&#94;2)=',eta_eff !sav2010 real ( wp ) :: residual !! невязка 'nevyazka=', pchg contains procedure :: print => iteration_result_print procedure :: save => iteration_result_save end type IterationResult contains subroutine iteration_result_print ( this ) class ( IterationResult ), intent ( in ) :: this print * , ' ---------' print * , 'ITERATION:' print * , 'iteration=' , this % number print * , 'ispectr=' , this % spectr_direction print * , 'P_launched, MW=' , this % P_launched print * , 'P_landau, MW=' , this % P_landau print * , 'P_coll, MW=' , this % P_coll print * , 'P_alph, MW=' , this % P_alph print * , 'Alphas power, MW=' , this % alphas_power print * , 'P_fast (landau+coll), MW=' , this % P_fast print * , 'P_lost, MW=' , this % P_lost print * , 'P_not accounted, MW=' , this % P_not_accounted print * , 'P_landau (strong absorption), MW=' , this % P_landau_strong_absorption print * , 'P_landau (weak absorption), MW=' , this % P_landau_weak_absorption print * , 'P_turns, MW=' , this % P_turns print * , 'efficiency, I(MA)/P(MW)=' , this % efficiency !call integral(1,nspl,rh,con,avedens) !sav2010 print * , '<Ne>, m&#94;-3=' , this % avedens , ' R, m=' , this % r0 !eta_eff=1.d17*avedens*r0*oi/plaun print * , 'eta_eff=<Ne>*R*I/P, A/(W*m&#94;2)=' , this % eta_eff print * , 'nevyazka=' , this % residual end subroutine iteration_result_print subroutine iteration_result_save ( this , time_stamp ) !! save Iteration Result to file class ( IterationResult ), intent ( in ) :: this real ( wp ), intent ( in ) :: time_stamp character ( 120 ) fname integer , parameter :: iu = 20 write ( fname , '(\"lhcd/rt-result/\", f9.7,\".dat\")' ) time_stamp print * , fname open ( iu , file = fname , position = \"append\" ) if ( this % number == 1 ) then write ( 20 , '(18A21)' ) 'iteration' , 'direction' , 'P_launched' , & 'P_landau' , 'P_coll' , 'P_alph' , 'alphas_power' , 'P_fast' , 'P_lost' , & 'P_not_accounted' , 'P_landau_strong_abs' , 'P_landau_weak_abs' , & 'P_turns' , 'efficiency' , 'avedens' , 'r0' , 'eta_eff' , 'residual' endif write ( 20 , '(2(I21), 16(ES21.14))' ) this % number , this % spectr_direction , & this % P_launched , this % P_landau , this % P_coll , this % P_alph , & this % alphas_power , this % P_fast , this % P_lost , this % P_not_accounted , & this % P_landau_strong_absorption , this % P_landau_weak_absorption , & this % P_turns , this % efficiency , this % avedens , this % r0 , & this % eta_eff , this % residual close ( iu ) end subroutine end module iteration_result_mod","tags":"","loc":"sourcefile\\3_iteration_result.f90.html"},{"title":"3_iterator_module.f90 – FRTС project","text":"Contents Modules iterator_mod Source Code 3_iterator_module.f90 Source Code module iterator_mod use kind_module implicit none real ( wp ) :: vmid ( 100 ), vz1 ( 100 ), vz2 ( 100 ) integer :: ibeg ( 100 ), iend ( 100 ) real ( wp ) :: vrj ( 101 ), dj ( 101 ), djnew ( 1001 ) real ( wp ) :: dj2 ( 101 ), d2j ( 101 ) real ( wp ), dimension (:), allocatable :: vvj , vdfj real ( wp ) :: vgrid ( 101 , 100 ), dfundv ( 101 , 100 ) !!common/gridv/vgrid(101,100),dfundv(101,100) integer :: nvpt !!common/gridv/nvpt integer :: ipt1 , ipt2 , ipt integer , parameter :: kpt1 = 20 , kpt3 = 20 integer :: iterat real ( wp ) :: psum4 !!common /vvv2/ psum4 real ( wp ) plost , pnab !!common /a0a4/ plost,pnab contains subroutine init_iteration use constants , only : zero use rt_parameters , only : itend0 use current use plasma , only : cltn implicit none ppv1 = zero ppv2 = zero psum4 = zero pnab = zero plost = zero dql = zero dq1 = zero dq2 = zero dncount = zero vzmin = cltn vzmax =- cltn pdl = zero pdc = zero pda = zero pdfast = zero if ( itend0 . gt . 0 ) then dqi0 = zero end if end subroutine recalculate_f_for_a_new_mesh ( ispectr ) !!   recalculate f' for a new mesh use constants , only : zero use rt_parameters , only : nr , ni1 , ni2 use plasma , only : vt0 , fvt , cltn use current , only : vzmin , vzmax use maxwell , only : i0 , vij , dfij use lock_module implicit none integer , intent ( in ) :: ispectr integer i , j , k real ( wp ) :: cdel , dfout integer :: klo , khi , ierr real ( wp ) :: r , hr , vt , vto , vmax real ( wp ) :: v1 , v2 , vp1 , vp2 hr = 1.d0 / dble ( nr + 1 ) k = ( 3 - ispectr ) / 2 do j = 1 , nr r = hr * dble ( j ) vt = fvt ( r ) vto = vt / vt0 if ( iterat . gt . 0 ) then v1 = dmin1 ( vzmin ( j ), vz1 ( j )) v2 = dmax1 ( vzmax ( j ), vz2 ( j )) else v1 = vzmin ( j ) v2 = vzmax ( j ) end if vmax = cltn / vto vp1 = v1 / vto vp2 = v2 / vto call gridvel ( vp1 , vp2 , vmax , cdel , ni1 , ni2 , ipt1 , kpt3 , vrj ) do i = 1 , i0 vvj ( i ) = vij ( i , j ) vdfj ( i ) = dfij ( i , j , k ) !=dfundv(i,j)*vto**2 end do do i = 1 , ipt call lock ( vvj , i0 , vrj ( i ), klo , khi , ierr ) if ( ierr . eq . 1 ) then !!!         if(vrj(i).gt.vvj(i0)) exit write ( * , * ) 'lock error in new v-mesh' write ( * , * ) 'j=' , j , ' i0=' , i0 write ( * , * ) 'vvj(1)=' , vvj ( 1 ), ' vvj(i0)=' , vvj ( i0 ) write ( * , * ) 'i=' , i , ' vrj(i)=' , vrj ( i ) write ( * , * ) pause 'next key = stop' stop end if call linf ( vvj , vdfj , vrj ( i ), dfout , klo , khi ) vgrid ( i , j ) = vrj ( i ) * vto dfundv ( i , j ) = dfout / vto ** 2 if ( dfundv ( i , j ). gt . zero ) dfundv ( i , j ) = zero end do vz1 ( j ) = v1 vz2 ( j ) = v2 end do end subroutine end module iterator_mod","tags":"","loc":"sourcefile\\3_iterator_module.f90.html"},{"title":"3_trajectory.f90 – FRTС project","text":"Contents Modules trajectory Source Code 3_trajectory.f90 Source Code module trajectory use kind_module implicit none integer , parameter :: length = 5000000 integer , parameter :: mpnt = 100000 integer :: irs !common /abcd/ irs integer :: iabsorp !common /abcdg/ iabsorp real ( wp ) :: rzz , tetzz , xmzz !!common /abc/ rzz,tetzz,xmzz integer :: iznzz , iwzz , irszz !!common /abc/ iznzz,iwzz,irszz real ( wp ) :: hrad !common /bcg/ hrad integer :: im4 !common /bg/ im4 integer nrefj ( mpnt ) !!common/refl/nrefj(mpnt) real ( wp ) dland ( length ), dcoll ( length ), perpn ( length ), dalf ( length ) real ( wp ) vel ( length ), tetai ( length ) real ( wp ) xnpar ( length ) integer izz ( length ), iww ( length ), jrad ( length ) !!common/agh/xnpar,vel,dland,dcoll,dalf,perpn,tetai,jrad,iww,izz integer mbeg ( mpnt ), mend ( mpnt ), mbad ( mpnt ) real ( wp ) rbeg ( mpnt ) !sav2008 real ( wp ) tetbeg ( mpnt ), xnrbeg ( mpnt ), xmbeg ( mpnt ), yn3beg ( mpnt ) !!common/viewdat/mbeg,mend,mbad,rbeg,tetbeg,xnrbeg,xmbeg,yn3beg !data mbad /mpnt*0/ contains subroutine init_trajectory use constants implicit none nrefj = 0 dland = zero dcoll = zero perpn = zero dalf = zero vel = zero jrad = zero iww = zero tetai = zero xnpar = zero izz = zero mbeg = zero mend = zero mbad = zero rbeg = zero tetbeg = zero xnrbeg = zero xmbeg = zero yn3beg = zero end subroutine subroutine view ( tview , iview , nnz , ntet ) !sav2008 !!!writing trajectories into a file use constants use approximation use plasma use dispersion_module , only : zatukh use rt_parameters , only : nr , itend0 , kv , nmaxm use spectrum1D , only : ynzm , pm implicit real ( wp ) ( a - h , o - z ) real ( wp ), intent ( in ) :: tview integer , intent ( in ) :: iview , nnz , ntet !sav# !common /bcef/ ynz,ynpopq common / vth / vthc ( length ), poloidn ( length ) real ( wp ) vthcg , npoli common / a0ghp / vlf , vrt , dflf , dfrt integer i , n , itr , ntraj integer jrc , nturn , ib , ie , jr , ifast , idir , iv integer jznak , jdlt , mn , mm , jchek , itet , inz integer , parameter :: unit_bias = 10 integer , parameter :: m = 7 real ( wp ), parameter :: pleft = 1.d-10 !m may be chaged together with name(m) real ( wp ) ptt ( m ), pll ( m ), pcc ( m ), paa ( m ) real ( wp ) pt_c ( m ), pl_c ( m ), pc_c ( m ), pa_c ( m ) character ( 40 ) fname character * 40 name ( m ) save name !sav# data name / 'lhcd/out/1.dat' , 'lhcd/out/2.dat' , 'lhcd/out/3.dat' , 'lhcd/out/4.dat' , 'lhcd/out/5.dat' , 'lhcd/out/rest.dat' , 'lhcd/out/traj.dat' / if ( iview . eq . 0 ) return print * , 'view_time=' , tview print * , name ( m ) write ( fname , '(\"lhcd/traj/\", f9.7,\".dat\")' ) tview print * , fname name ( m ) = fname print * , name ( m ) htet = zero h = 1 d0 / dble ( nr + 1 ) if ( ntet . ne . 1 ) htet = ( tet2 - tet1 ) / ( ntet - 1 ) open ( 1 , file = 'lhcd/out/lcms.dat' ) write ( 1 , * ) '     R(m)            Z(m)' write ( 1 , * ) xr = 1.d0 xdl = fdf ( xr , cdl , ncoef , xdlp ) xly = fdf ( xr , cly , ncoef , xlyp ) xgm = fdf ( xr , cgm , ncoef , xgmp ) do i = 1 , 101 th = dble ( i - 1 ) * pi2 / dble ( 100 ) cotet = dcos ( th ) sitet = dsin ( th ) xx =- xdl + xr * cotet - xgm * sitet ** 2 zz = xr * xly * sitet x = ( r0 + rm * xx ) / 1 d2 z = ( z0 + rm * zz ) / 1 d2 write ( 1 , 5 ) x , z end do close ( 1 ) open ( 1 , file = 'lhcd/out/npar_crit.dat' ) write ( 1 , * ) '  Npar_crit=sqrt(50/Te(keV))' write ( 1 , * ) write ( 1 , * ) '   rho         Npar_strong absorption' write ( 1 , * ) do i = 1 , 101 xr = dble ( i - 1 ) / dble ( 100 ) tmp = ft ( xr ) / 0.16d-8 !Te,  KeV parn_c = dsqrt ( 50 d0 / tmp ) write ( 1 , 5 ) xr , parn_c end do close ( 1 ) do n = 1 , m open ( n + unit_bias , file = name ( n )) write ( n + unit_bias , * ) close ( n + unit_bias ) open ( n + unit_bias , file = name ( n )) write ( n + unit_bias , 3 ) write ( n + unit_bias , * ) ptt ( n ) = zero pll ( n ) = zero pcc ( n ) = zero paa ( n ) = zero end do ntraj = 0 !sav2008 do itr = 1 , nnz * ntet !sav2008 pow = 1.d0 pl = zero pc = zero pa = zero pdec1 = zero pdec1z = zero pdec3 = zero pdec3z = zero pdecv = zero pintld = zero pintal = zero jrc = nr + 1 jznak =- 1 nturn = 1 if ( mbad ( itr ). eq . 0 ) then ntraj = ntraj + 1 ib = mbeg ( itr ) ie = mend ( itr ) 10 continue do i = ib , ie v = vel ( i ) jr = jrad ( i ) refr = perpn ( i ) npoli = poloidn ( i ) ifast = iww ( i ) vthcg = vthc ( i ) idir = izz ( i ) dek3 = zero th = tetai ( i ) parn = xnpar ( i ) !         xn1=an1(i) !         xn2=an2(i) if ( itend0 . gt . 0 ) then argum = clt / ( refr * valfa ) dek3 = zatukh ( argum , abs ( jr ), vperp , kv ) end if ! old variant ! call raspr(v,abs(jr),iv,df) ! call distr ( v , abs ( jr ), iv , df ) if ( jr . lt . 0 ) then !case of turn jr =- jr !variant          pintld=-dland(i)*df !!          pintld=-dland(i)*(dflf+dfrt)/2d0 pintld = dabs ( dland ( i ) * ( dflf + dfrt ) / 2 d0 ) pdec2 = dexp ( - 2 d0 * dcoll ( i )) pintal = dabs ( dalf ( i ) * dek3 ) else pdec2 = dcoll ( i ) pdecv = dland ( i ) !!          pdec1=-pdecv*df pdec1 = dabs ( pdecv * df ) pdec3 = dabs ( dalf ( i ) * dek3 ) pintld = ( pdec1 + pdec1z ) / 2 d0 * h pintal = ( pdec3 + pdec3z ) / 2 d0 * h pdec1z = pdec1 pdec3z = pdec3 end if powpr = pow powd = pow * dexp ( - 2 d0 * pintld ) powcol = powd * pdec2 powal = powcol * dexp ( - 2 d0 * pintal ) pow = powal pil = pintld pic = . 5 d0 * dabs ( dlog ( pdec2 )) pia = pintal pt = 1.d0 - pow !total absorbed power denom = pil + pic + pia powdamped = 1.d0 - dexp ( - 2.d0 * denom ) domin = powpr * powdamped if ( denom . ne . zero ) then fff = domin / denom pl = pl + dabs ( pil * fff ) !el. Landau absorbed power pc = pc + dabs ( pic * fff ) !el. collisions absorbed power pa = pa + dabs ( pia * fff ) !alpha Landau absorbed power end if xr = h * dble ( jr ) cotet = dcos ( th ) sitet = dsin ( th ) xdl = fdf ( xr , cdl , ncoef , xdlp ) xly = fdf ( xr , cly , ncoef , xlyp ) xgm = fdf ( xr , cgm , ncoef , xgmp ) xx =- xdl + xr * cotet - xgm * sitet ** 2 zz = xr * xly * sitet x = ( r0 + rm * xx ) / 1 d2 z = ( z0 + rm * zz ) / 1 d2 jdlt = jr - jrc jrc = jr if ( jdlt * jznak . lt . 0. and . nturn . lt . m - 1 ) then nturn = nturn + 1 jznak =- jznak end if mn = nturn + unit_bias write ( mn , 7 ) x , z , xr , th , parn , npoli , pt , pl , pc , pa , ifast , idir , itr mm = m + unit_bias write ( mm , 7 ) x , z , xr , th , parn , npoli , pt , pl , pc , vthcg , ifast , idir , itr do n = m , nturn , - 1 pt_c ( n ) = pt pl_c ( n ) = pl pc_c ( n ) = pc pa_c ( n ) = pa end do if ( pt . ge . 1 d0 - pleft ) go to 11 !maximal absorbed power along a ray end do jchek = jrad ( ie + 1 ) if ( jchek . ne . 0 ) then !continue this trajectory ib = idnint ( dland ( ie + 1 )) ie = idnint ( dcoll ( ie + 1 )) goto 10 end if 11 continue do n = 1 , m ptt ( n ) = ptt ( n ) + pt_c ( n ) pll ( n ) = pll ( n ) + pl_c ( n ) pcc ( n ) = pcc ( n ) + pc_c ( n ) paa ( n ) = paa ( n ) + pa_c ( n ) end do if ( itr . lt . nnz * ntet ) then write ( m + unit_bias , * ) write ( nturn + unit_bias , * ) end if end if end do do n = 1 , m close ( n + unit_bias ) end do do n = 1 , m ptt ( n ) = ptt ( n ) / dble ( ntraj ) pll ( n ) = pll ( n ) / dble ( ntraj ) pcc ( n ) = pcc ( n ) / dble ( ntraj ) paa ( n ) = paa ( n ) / dble ( ntraj ) end do open ( 1 , file = 'lhcd/out/info_traj.dat' ) write ( 1 , 20 ) tview write ( 1 , * ) do n = 1 , m - 1 if ( n . lt . m - 1 ) then write ( 1 , 8 ) n , ptt ( n ), pll ( n ), pcc ( n ), paa ( n ) else write ( 1 , 9 ) ptt ( n ), pll ( n ), pcc ( n ), paa ( n ) end if write ( 1 , * ) end do write ( 1 , * ) write ( 1 , 1 ) write ( 1 , * ) itr = 0 do itet = 1 , ntet tetin = tet1 + htet * ( itet - 1 ) do inz = 1 , nnz itr = itr + 1 write ( 1 , 6 ) itr , mbad ( itr ), tetin , ynzm ( inz ), rbeg ( itr ) end do end do close ( 1 ) open ( 1 , file = 'lhcd/out/absorp.dat' ) write ( 1 , 2 ) write ( 1 , * ) do n = 1 , m - 1 if ( n . eq . 1 ) then dpt = ptt ( n ) dpl = pll ( n ) dpc = pcc ( n ) dpa = paa ( n ) else dpt = ptt ( n ) - ptt ( n - 1 ) dpl = pll ( n ) - pll ( n - 1 ) dpc = pcc ( n ) - pcc ( n - 1 ) dpa = paa ( n ) - paa ( n - 1 ) end if write ( 1 , 4 ) n , ptt ( n ), pll ( n ), pcc ( n ), paa ( n ), dpt , dpl , dpc , dpa end do close ( 1 ) 1 format ( 2 x , 'N_traj' , 3 x , 'mbad' , 6 x , 'theta' , 9 x , 'Npar' , 9 x , 'rho_start' ) 2 format ( 'R_pass' , 4 x , 'Ptot' , 6 x , 'Pland' , 6 x , 'Pcoll' , 8 x , 'Pa' , 7 x , 'dPtot' , 6 x , 'dPland' , 5 x , 'dPcoll' , 6 x , 'dPa' ) 3 format ( 5 x , 'R' , 10 x , 'Z' , 11 x , 'rho' , 8 x , 'theta' , 7 x , 'N_par' , 7 x , 'N_pol' , 6 x , 'P_tot' , 7 x , 'P_land' , 6 x , 'P_coll' , 6 x , 'vth' , 4 x , 'slow=1' , 4 x , 'out=1' , 2 x , 'N_traj' , 6 x ) 4 format ( i3 , 5 x , 8 ( f6 . 3 , 5 x )) 5 format ( 6 ( e13 . 6 , 3 x )) 6 format ( 2 ( i6 , 2 x ), 4 ( e13 . 6 , 1 x )) 7 format ( 10 ( e11 . 4 , 1 x ), i5 , 2 x , i5 , 2 x , i5 ) 8 format ( 'after radial pass=' , i3 , 2 x , ' P_tot=' , f6 . 3 , 2 x , ' P_land=' , f5 . 3 , 2 x , ' P_coll=' , f6 . 3 , 2 x , ' P_a=' , f6 . 3 ) 9 format ( 'Total passes:           P_tot=' , f6 . 3 , 2 x , ' P_land=' , f5 . 3 , 2 x , ' P_coll=' , f6 . 3 , 2 x , ' P_a=' , f6 . 3 ) 20 format ( 'written time slice (seconds) =' , f9 . 3 ) end subroutine traj ( xm0 , tet0 , xbeg , nmax , nb1 , nb2 , nomth , nomnz , pabs ) !sav2009 use constants use approximation use plasma use rt_parameters use dispersion_module use runge_kutta_module real ( wp ), intent ( in ) :: xm0 real ( wp ), intent ( in ) :: tet0 real ( wp ), intent ( inout ) :: xbeg real ( wp ), intent ( in ) :: pabs integer , intent ( inout ) :: nmax integer , intent ( inout ) :: nb1 , nb2 integer , intent ( in ) :: nomth , nomnz !use manager_mod  !, only: ivar, iroot !implicit real*8 (a-h,o-z) !external extd4 !common /abc/ rzz,tetzz,xmzz,iznzz,iwzz,irszz !common /abcd/ irs !common /abcde/ izn!,iw !common /abcdg/ iabsorp !common /bcg/ hrad !common /bcef/ ynz,ynpopq !common /be1/ xnr1,xnr2,xnr3,xnr4 !common /be2/ ider !common /bg/ im4 integer :: nrefl integer :: irep integer :: irf , irf1 integer :: ib2 integer :: irs0 real ( wp ), parameter :: pgdop = 0.02d0 real ( wp ), parameter :: hmin = 0.d-7 !sav2008, old hmin=1.d-7 real ( wp ) :: eps0 real ( wp ) :: rrange0 , hdrob0 , tet , xm , hr real ( wp ) :: xsav , xend , hsav , h1 real ( wp ) :: ystart ( 2 ), yy ( 4 ) real ( wp ) :: rnew2 real ( wp ) :: cotet , sitet real ( wp ) :: xdl , xly , xgm , xgmp , xx , zz , xxx , zzz real ( wp ) :: xdlp , xlyp , xnr , prt , prm real ( wp ) :: ynz0 , x1 , x2 , rexi , tetnew real ( wp ) :: xmnew , rnew , xnrnew , xnrv real ( wp ) :: pg1 , pg2 , pg3 , pg4 , pg eps0 = eps rrange0 = rrange hdrob0 = hdrob iroot = 1 nrefl = 0 ider = 1 im4 = 0 nb1 = 0 nb2 = 0 irep = 0 tet = tet0 xm = xm0 hr = 1.d0 / dble ( nr + 1 ) !sav2008 hrad = hr !--------------------------------------- ! find saving point and define ! parameters, depending on direction !--------------------------------------- 10 irf1 = idnint ( xbeg / hr ) if ( dabs ( irf1 * hr - xbeg ). lt . tin ) then xsav = hr * irf1 else irf = int ( xbeg / hr ) if ( irs . eq . 1 ) xsav = hr * irf if ( irs . eq . - 1 ) xsav = hr * ( irf + 1 ) end if xend = 0.5d0 - 0.5d0 * irs + tin * irs if ( ipri . gt . 2 ) write ( * , * ) 'xbeg-xend' , xbeg , xend hsav = - hr * irs h1 = hsav !--------------------------------------- ! solve eqs. starting from xbeg !--------------------------------------- ystart ( 1 ) = tet ystart ( 2 ) = xm call driver2 ( ystart , xbeg , xend , xsav , hmin , h1 , pabs ) tet = ystart ( 1 ) xm = ystart ( 2 ) ib2 = 0 rnew2 = ystart ( 3 ) cotet = dcos ( tet ) sitet = dsin ( tet ) xdl = fdf ( rnew2 , cdl , ncoef , xdlp ) xly = fdf ( rnew2 , cly , ncoef , xlyp ) xgm = fdf ( rnew2 , cgm , ncoef , xgmp ) xx =- xdl + rnew2 * cotet - xgm * sitet ** 2 zz = rnew2 * xly * sitet xxx = ( r0 + rm * xx ) / 1 d2 zzz = ( z0 + rm * zz ) / 1 d2 ! open(33,file='lhcd/out/dots.dat',position=\"append\") ! write(33,*)xxx, zzz, nomth, nomnz ! close(33) !--------------------------------------- ! absorption !--------------------------------------- if ( iabsorp . ne . 0 ) then if ( ipri . gt . 2 ) write ( * , * ) 'in traj() iabsorp=' , iabsorp nmax = nrefl return end if if ( xend . eq . xbeg ) nb1 = nb1 + 1 !sav2008 20    continue !-------------------------------------------------------- !  pass turning point !-------------------------------------------------------- irs0 = irs ider = 0 call disp2 ( xend , xm , tet , xnr , prt , prm ) ider = 1 ynz0 = ynz 40 yy ( 1 ) = tet yy ( 2 ) = xm yy ( 3 ) = xend yy ( 4 ) = xnr x1 = 0 d0 x2 = 1 d + 10 rexi = xend call driver4 ( yy , x1 , x2 , rexi , hmin , extd4 ) if ( iabsorp . eq . - 1 ) return !failed to turn tetnew = yy ( 1 ) xmnew = yy ( 2 ) rnew = yy ( 3 ) xnrnew = yy ( 4 ) cotet = cos ( tetnew ) sitet = sin ( tetnew ) xdl = fdf ( rnew , cdl , ncoef , xdlp ) xly = fdf ( rnew , cly , ncoef , xlyp ) xgm = fdf ( rnew , cgm , ncoef , xgmp ) xx = - xdl + rnew * cotet - xgm * sitet ** 2 zz = rnew * xly * sitet xxx = ( r0 + rm * xx ) / 1 d2 zzz = ( z0 + rm * zz ) / 1 d2 ! open(33,file='lhcd/out/dots.dat',position=\"append\") ! write(33,*)xxx, zzz, nomth, nomnz ! close(33) if ( ipri . gt . 2 ) write ( * , * ) 'from r=' , rexi , 'to r=' , rnew !--------------------------------------- ! find mode !--------------------------------------- iroot = 3 ider = 0 xnrv = xnrnew call disp2 ( rnew , xmnew , tetnew , xnrv , prt , prm ) ider = 1 iroot = 1 !ipric      if (ipri.gt.2) then !ipric       write (*,*)'nr check, r=',rnew,' tet=',tetnew !ipric       write (*,*)'iw=',iw,' izn=',izn !ipric       write (*,*) xnrnew,xnr1 !ipric       write (*,*) xnr2,xnr3,xnr4 !ipric       pause !ipric      end if pg1 = abs ( xnrnew - xnr1 ) pg2 = abs ( xnrnew - xnr2 ) pg3 = abs ( xnrnew - xnr3 ) pg4 = abs ( xnrnew - xnr4 ) pg = dmin1 ( pg1 , pg2 , pg3 , pg4 ) if ( dabs ( pg / xnrnew ). gt . pgdop ) then !--------------------------------------------- ! bad accuracy, continue with 4 equations !-------------------------------------------- ib2 = ib2 + 1 nb2 = nb2 + 1 if ( ib2 . gt . 4 ) then if ( ipri . gt . 1 ) write ( * , * ) 'error: cant leave 4 eqs' iabsorp =- 1 return end if eps = eps / 5 d0 rrange = rrange * 2 d0 hdrob = hdrob * 2 d0 goto 40 end if !------------------------------------- !          change wave type !------------------------------------- if ( pg . ne . pg1 ) then if ( pg . eq . pg2 ) izn =- izn if ( pg . eq . pg3 ) iw =- iw if ( pg . eq . pg4 ) iw =- iw if ( pg . eq . pg4 ) izn =- izn end if if ( irs0 . ne . irs ) nrefl = nrefl + 1 xbeg = rnew tet = tetnew xm = xmnew im4 = 1 eps = eps0 rrange = rrange0 hdrob = hdrob0 if ( nrefl . lt . nmax ) goto 10 rzz = xbeg tetzz = tet xmzz = xm iznzz = izn iwzz = iw irszz = irs end subroutine driver4 ( ystart , x1 , x2 , rexi , hmin , derivs ) use constants use runge_kutta_module use plasma use rt_parameters !use trajectory, only: irs, iabsorp use dispersion_module implicit none real ( wp ), intent ( inout ) :: ystart (:) real ( wp ), intent ( inout ) :: x1 , x2 real ( wp ), intent ( in ) :: rexi , hmin !implicit real*8 (a-h,o-z) !procedure (Iderivs_func), pointer, intent(in) :: derivs procedure ( Iderivs_func ) :: derivs !external derivs !common /abcd/ irs !common /abcde/ izn!,iw !common /abcdg/ iabsorp !common /bdeo/ ivar !common /bcef/ ynz,ynpopq !common /df/ pdec14,pdec24,pdec34,idec real ( wp ) pintld4 , pintcl4 , pintal4 common / dg / pintld4 , pintcl4 , pintal4 integer , parameter :: iturns = 1 , maxat = 3 , nvar = 4 real ( wp ), parameter :: hbeg = 1.d-4 !sav2008 real ( wp ) :: x , xnr , prt , prm , dyd , hnext real ( wp ) :: yscal ( nvar ), y ( nvar ), dydx ( nvar ), yold ( nvar ) real ( wp ) :: eps1 , rbord1 , hdid , xold , rmm , h real ( wp ) :: hdrob1 , pdec14zz , pdec24zz , pdec34zz integer :: ipr1 , iat , i , ii , nstp ipr1 = 0 iat = 0 x = zero eps1 = eps hdrob1 = hdrob rbord1 = rbord hdid = zero pintld4 = zero pintcl4 = zero pintal4 = zero pdec14zz = zero pdec24zz = zero pdec34zz = zero xold = x do i = 1 , nvar y ( i ) = ystart ( i ) yold ( i ) = y ( i ) end do rmm = 1 d + 10 * irs !sav2008 !old      rexi1=rexi+rrange !old      rexi2=rexi-rrange !old      if(rexi1.gt.0.95d0) rexi1=1.d10 !old      if(rexi2.lt.0.05d0) rexi2=-1.d10 !est      if(rexi1.gt.0.9d0) rexi1=1.1d0 10 continue !c-------------------------------------- !c start integration !c-------------------------------------- do nstp = 1 , maxstep4 idec = iturns call derivs ( x , y , dydx ) idec = 0 pintld4 = pintld4 + abs (( pdec14 + pdec14zz ) / 2 d0 * hdid ) pintcl4 = pintcl4 + abs (( pdec24 + pdec24zz ) / 2 d0 * hdid ) pintal4 = pintal4 + abs (( pdec34 + pdec34zz ) / 2 d0 * hdid ) pdec14zz = pdec14 pdec24zz = pdec24 pdec34zz = pdec34 if ( nstp . eq . 1 ) then h = hbeg !!var        if(dabs(dydx(3)).ne.zero) h=dabs(hmin1/dydx(3))/hdrob1 if ( dabs ( dydx ( 3 )). ne . zero ) h = 0.5d0 * dabs ( rrange / dydx ( 3 )) / hdrob1 end if 20 continue if ( y ( 3 ). ge . rbord1 . and . dydx ( 3 ). gt . zero ) then !c-------------------------------------- !c forced reflection from periphery !c-------------------------------------- ivar = 3 izn =- izn call disp2 ( y ( 3 ), y ( 2 ), y ( 1 ), xnr , prt , prm ) if ( ivar . eq . - 1 ) then !out of dispersion curve - restart do i = 1 , nvar y ( i ) = ystart ( i ) end do x = zero iat = iat + 1 if ( iat . gt . maxat ) then if ( ipri . gt . 1 ) write ( * , * ) 'turn in driver4 failed' goto 40 end if eps1 = eps1 / 2.d0 hdrob1 = hdrob1 * 2.d0 ivar = 0 goto 10 end if irs =- irs y ( 4 ) = xnr call derivs ( x , y , dydx ) if ( dydx ( 3 ). gt . zero . and . ipri . gt . 1 ) then write ( * , * ) 'Unsuccesful turn: r, drds=' , y ( 3 ), dydx ( 3 ) end if ivar = 0 iat = 0 end if !sav2008       if((y(3).gt.rexi1.or.y(3).lt.rexi2)) then  ! exit !!    if(dabs(y(3)-rexi).gt.rrange.or.nstp.eq.maxstep4) then  ! exit !sav2008 if ( dabs ( y ( 3 ) - rexi ). gt . rrange ) then ! exit !sav2008 if ( dydx ( 3 ). gt . zero ) irs =- 1 if ( dydx ( 3 ). lt . zero ) irs = 1 if ( dydx ( 3 ). eq . zero ) then !sav2008 write ( * , * ) 'exception dr/ds=0 in driver4' pause 'zmi na pedal' go to 1 end if x2 = x x1 = rmm do i = 1 , nvar ystart ( i ) = y ( i ) end do return end if 1 continue !c--------------------------------------- !c remember old values !c--------------------------------------- xold = x do i = 1 , nvar dyd = dabs ( dydx ( i )) yscal ( i ) = dabs ( y ( i )) + dabs ( h * dyd ) + 1.d-30 / ( 1.d0 + dyd ) + 1.d-30 yold ( i ) = y ( i ) end do if ( y ( 3 ) * irs . lt . rmm * irs ) rmm = y ( 3 ) 30 continue call runge_kutta_qs ( y , dydx , nvar , x , h , eps1 , yscal , hdid , hnext , derivs ) if ( y ( 3 ). ge . 1.d0 ) then ! crossed plasma boundary do ii = 1 , nvar y ( ii ) = yold ( ii ) end do x = xold ipr1 = ipr1 + 1 if ( ipr1 . lt . maxat ) then h = h / 3.d0 goto 30 end if rbord1 = y ( 3 ) - 1.d-4 goto 20 end if ipr1 = 0 if ( dabs ( hnext ). lt . hmin ) then if ( ipri . gt . 1 ) write ( * , * ) 'error in dr4: step is too small' goto 40 end if h = hnext end do if ( ipri . gt . 1 ) write ( * , * ) 'error in dr4: too many steps.' if ( ipri . gt . 1 ) write ( * , * ) 'tet=' , y ( 1 ), 'xm=' , y ( 2 ), 'xend=' , y ( 3 ) 40 iabsorp =- 1 end end module trajectory","tags":"","loc":"sourcefile\\3_trajectory.f90.html"},{"title":"4_manager.f90 – FRTС project","text":"Contents Modules manager_mod Source Code 4_manager.f90 Source Code module manager_mod use kind_module implicit none real ( wp ) pow !!common /acg/ pow integer inak , lenstor , lfree !common /ag/ inak,lenstor,lfree contains !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! subroutine manager ( iterat , iw0 , ntet , spectr ) use constants use plasma use rt_parameters , only : nr , ipri , iw , nmaxm , pabs0 !use spectrum1D, only: ynzm, pm use trajectory use spectrum_mod use iterator_mod , only : plost , pnab use dispersion_module , only : icall1 , icall2 , yn3 , ivar , izn , iroot implicit none type ( Spectrum ) spectr type ( SpectrumPoint ) point real ( wp ) pabs integer iznzap ( mpnt ), iwzap ( mpnt ), irszap ( mpnt ) real ( wp ) rzap ( mpnt ), tetzap ( mpnt ), xmzap ( mpnt ), yn3zap ( mpnt ) !common /a0a1/ ynzm(1001),pm(1001) !common /a0a2/ tet1,tet2 ! real(wp) plost,pnab !common /a0a4/ plost,pnab !real(wp) rzz,tetzz,xmzz !common /abc/ rzz,tetzz,xmzz,iznzz,iwzz,irszz !common /abcd/ irs !common /abcde/ izn !common /abcdg/ iabsorp !common /abefo/ yn3 !common /a0gh/ pabs !common /aef2/ icall1,icall2 !common /ag/ inak,lenstor,lfree !common/refl/nrefj(mpnt) integer ntet , iout , itr , nnj , n_it integer maxref , iterat , nmax0 , ibad , itet , nref integer nbad1 , nbad2 , inz integer iw0 , ifail , iabsirp , inak0 , ib , ie integer nmax , i , nb1 , nb2 !integer iznzz, iwzz, irszz real ( wp ) htet , hr , yn , rin , xmin , rstart real ( wp ) xnr , powexit , dltpow , pow1 , pgamma , xm real ( wp ) tetin0 , tetin , tet pabs = spectr % max_power * pabs0 / 1.d2 print * , 'pabs =' , pabs , spectr % max_power , pabs0 lenstor = length htet = zero hr = 1.d0 / dble ( nr + 1 ) !sav2008 if ( ntet . ne . 1 ) htet = ( tet2 - tet1 ) / ( ntet - 1 ) irs = 1 iout = 0 mbeg ( 1 ) = 1 itr = 0 inak = 0 nnj = 0 do n_it = 0 , 3 nnj = nnj + nmaxm ( n_it + 1 ) end do maxref = nnj if ( iterat . lt . 3 ) nmax0 = nmaxm ( iterat + 1 ) if ( iterat . ge . 3 ) nmax0 = nmaxm ( 4 ) if ( ipri . gt . 1 ) then write ( * , 1001 ) iterat + 1 write ( * , 1002 ) end if ibad = 0 !-------------------------------------- ! begin outer loop on teta !-------------------------------------- do itet = 1 , ntet nref = 0 nbad1 = 0 nbad2 = 0 icall1 = 0 icall2 = 0 tetin = tet1 + htet * ( itet - 1 ) !-------------------------------------- ! begin inner loop on nz !-------------------------------------- do inz = 1 , spectr % size itr = itr + 1 !ipri          if(ipri.eq.4)  write(23,*) point = spectr % data ( inz ) if ( iterat . eq . 0 ) then !----------------------------------------- !    find initial radius for a trajectory !    on the 1th iteration !----------------------------------------- yn = point % Ntor pow = point % power !yn=ynzm(inz) !sav2008, yn is introduced !pow=pm(inz) irs = 1 iw = iw0 rin = rini ( xmin , tetin , xnr , point , hr , ifail ) if ( ifail . eq . 1 ) then if ( ipri . gt . 1 ) write ( * , * ) 'error: no roots' iabsorp = - 1 inak0 = inak go to 10 end if rbeg ( itr ) = rin !sav2008 tetbeg ( itr ) = tetin !sav2008 xnrbeg ( itr ) = xnr !sav2008 xmbeg ( itr ) = xmin !sav2008 yn3beg ( itr ) = yn3 !sav2008 else if ( mbad ( itr ). ne . 0 ) then plost = plost + point % power go to 31 end if ib = mbeg ( itr ) ie = mend ( itr ) powexit = point % power dltpow = pabs call dqliter ( dltpow , ib , ie , hr , powexit , iout ) if ( nmax0 . eq . 0 ) then ib = mbeg ( itr ) ie = mend ( itr ) pow1 = powexit pgamma = 1.d0 - pow1 / point % power powexit = pow1 / pgamma dltpow = powexit - pow1 + pabs call dqliter ( dltpow , ib , ie , hr , powexit , iout ) powexit = powexit - dltpow + pabs if ( powexit . lt . zero ) powexit = zero go to 30 end if if ( iout . eq . 0 ) then go to 30 else tetin = tetzap ( itr ) xmin = xmzap ( itr ) rin = rzap ( itr ) yn3 = yn3zap ( itr ) pow = powexit irs = irszap ( itr ) iw = iwzap ( itr ) izn = iznzap ( itr ) jrad ( ie + 1 ) = 1 dland ( ie + 1 ) = lfree inak = lfree - 1 end if end if !--------------------------------------- ! initial parameters for a trajectory !--------------------------------------- xm = xmin rstart = rin !sav2008 tet = tetin nmax = nmax0 iabsorp = 0 inak0 = inak !------------------------------------- ! call ray tracing !------------------------------------- call traj ( xm , tet , rstart , nmax , nb1 , nb2 , itet , inz , pabs ) !sav2009 nbad1 = nbad1 + nb1 nbad2 = nbad2 + nb2 nrefj ( itr ) = nrefj ( itr ) + nmax powexit = pow nref = nref + nmax 10 if ( iabsorp . lt . 0 ) then !------------------------------------- !    encounted problems !------------------------------------- if ( inak . eq . lenstor - 1 ) then write ( * , * ) 'fix maximal length' nmax0 = 0 do i = 1 , 4 nmaxm ( i ) = 0 end do iout = 1 goto 20 end if if ( ipri . gt . 1 ) then tetin0 = tet1 + htet * ( itet - 1 ) write ( * , 111 ) tetin0 , point % Ntor 111 format ( 1 x , 'traj. with tet0=' , f10 . 5 , 1 x , ', Ninput=' , f10 . 5 , 1 x , 'failed' ) end if mbad ( itr ) = 1 plost = plost + pow inak = inak0 mend ( itr ) = inak - 1 goto 30 end if !--------------------------------------- ! remember end point of trajectory !--------------------------------------- rzap ( itr ) = rzz tetzap ( itr ) = tetzz xmzap ( itr ) = xmzz yn3zap ( itr ) = yn3 iznzap ( itr ) = iznzz iwzap ( itr ) = iwzz irszap ( itr ) = irszz if ( iterat . eq . 0 ) then if ( itr . gt . 1 ) mbeg ( itr ) = mend ( itr - 1 ) + 2 mend ( itr ) = inak jrad ( mend ( itr ) + 1 ) = 0 lfree = mend ( itr ) + 2 inak = lfree - 1 end if 20 continue if ( iout . ne . 0 ) then dcoll ( ie + 1 ) = inak jrad ( inak + 1 ) = 0 lfree = inak + 2 end if if ( nrefj ( itr ). gt . maxref . and . pow . gt . pabs ) then !forced absorp if ( pow . ge . point % power ) go to 30 !sav2008 ib = mbeg ( itr ) ie = mend ( itr ) pow1 = pow pgamma = 1.d0 - pow1 / point % power powexit = pow1 / pgamma dltpow = powexit - pow1 + pabs call dqliter ( dltpow , ib , ie , hr , powexit , iout ) powexit = powexit - dltpow + pabs if ( powexit . lt . zero ) powexit = zero end if 30 continue pnab = pnab + powexit 31 continue end do if ( ipri . gt . 1 ) write ( * , 1003 ) itet , icall1 , icall2 , nref , lfree - 1 , nbad1 , nbad2 print * , 'itr =' , itr end do 1001 format ( 30 x , i4 , ' iteration' ) 1002 format ( 6 x , 'n' , 5 x , 'call2' , 6 x , 'call4' , 6 x , 'nrefl' , 4 x , 'last' , 5 x , 'bad2' , 5 x , 'bad4' ) 1003 format ( 3 x , i4 , 2 ( 1 x , i10 ), 2 x , i7 , 2 x , i8 , 2 ( 1 x , i7 ), 2 ( 2 x , i7 )) 1004 format ( 1 x , i8 ) 1005 format ( 1 x , i5 ) 1006 format ( e14 . 7 ) end real ( wp ) function rini ( xm , tet , xnr , point , hr , ifail ) !sav2009 use constants , only : zero use rt_parameters , only : inew use spectrum_mod !use trajectory use dispersion_module implicit none type ( SpectrumPoint ), intent ( in ) :: point real ( wp ), intent ( inout ) :: xm , xnr real ( wp ), intent ( in ) :: tet , hr integer , intent ( inout ) :: ifail integer :: ntry real ( wp ) :: vgrp ( 3 ), vph ( 3 ) !real(wp) :: ynz,ynpopq !common /bcef/ ynz,ynpopq !real(wp) :: g11,g12,g22,g33,gg,g,si,co !common/metrika/g11,g12,g22,g33,gg,g,si,co !sav2009 real ( wp ) :: pa , prt , prm real ( wp ) :: f1 , f2 real ( wp ), parameter :: rhostart = 1.d0 integer , parameter :: ntry_max = 5 ifail = 1 rini = zero ntry = 0 pa = rhostart do while ( ntry . lt . ntry_max . and . pa . ge . 2 d0 * hr ) pa = rhostart - hr * dble ( ntry ) - 1.d-4 ntry = ntry + 1 ivar = 1 call disp2 ( pa , xm , tet , xnr , prt , prm ) if ( inew . gt . 0 ) then !g' in ST and poloidal grill direction !yn3 = zero                 !Nfi=0 !xm = yn*dsqrt(g22)/si      !given Npar at Nfi=0 yn3 = point % Npol ** dsqrt ( g33 ) / co xm = point % Ntor * dsqrt ( g22 ) / si !!              xm=yn*dsqrt(g22)         !given yn=(N*jpol) at Nfi=0 else !usual tokamak and toroidal grill direction !xm = zero               !N2=0 !yn3 = yn*dsqrt(g33)/co  !if given Npar at Nteta=0 !!              yn3=yn*dsqrt(g33)       !if given Nfi at Nteta=0 yn3 = point % Ntor * dsqrt ( g33 ) / co xm = point % Npol * dsqrt ( g22 ) / si end if ivar = 0 iroot = 2 call disp2 ( pa , xm , tet , xnr , f1 , f2 ) if ( f1 . ge . zero . and . f2 . ge . zero ) then rini = pa ifail = 0 return end if end do end end module manager_mod","tags":"","loc":"sourcefile\\4_manager.f90.html"},{"title":"drivencurrent95.f90 – FRTС project","text":"Contents Subroutines drivencurrent95 lhcurrent Source Code drivencurrent95.f90 Source Code subroutine drivencurrent95 ( outj , sigmaj , UPL , NRD , NA1 , TIME , TAU , ROC , RTOR , GP2 ) !! ****************************************************************** !!   outj(i)  = LH driven current density, MA/m&#94;2 !!   dndt(i)  = d&#94;2Jr1/dt&#94;2/E, MA/m&#94;2/sec&#94;2/(V/m), ~runaway d(el.density)/dt/E !!   djdt(i)  = dJr2/dt, time drivative of runaway current Jr2, MA/m&#94;2/sec !!   outjrun(i)  = LH driven runaway current density, MA/m&#94;2 !!   outnerun(i) = runaway electron density/10&#94;19 m&#94;-3 !! ****************************************************************** use FokkerPlanck_module use driven_current_module implicit none ! variables imported from ASTRA integer NRD ! NRD     501 - Maximum size of the radial grid integer NA1 ! NA1     Edge grid point number: ROC=RHO(NA1) double precision TIME , TAU , RTOR , ROC , GP2 double precision UPL ( NRD ) real * 8 outj ( NRD ), sigmaj ( NRD ), afld ( NRD ), dtau integer i , inpt , ispectr real * 8 dt , cup , cup0 , cum , cum0 , cp , cm , cp0 , cm0 , aiint real * 8 , parameter :: zero = 0.d0 , eps = 1.d-2 type ( DrivenCurrentResult ) :: rc_result type ( DrivenCurrent ) :: positive_dc type ( DrivenCurrent ) :: negative_dc interface subroutine lhcurrent ( driven_current , ispectr ) use driven_current_module implicit none type ( DrivenCurrent ), intent ( inout ) :: driven_current integer , intent ( in ) :: ispectr end subroutine lhcurrent end interface inpt = NA1 do i = 1 , inpt afld ( i ) = UPL ( i ) / RTOR / GP2 !!variant end do ! ---- starting LH current calculation positive_dc = DrivenCurrent ( NA1 ) negative_dc = DrivenCurrent ( NA1 ) ! ---- positive spectrum: call lhcurrent ( positive_dc , ispectr = 1 ) call positive_dc % evaluate ( ROC ) ! ---- negative spectrum: call lhcurrent ( negative_dc , ispectr = - 1 ) call negative_dc % evaluate ( ROC ) do i = 1 , inpt outj ( i ) = positive_dc % outj ( i ) + negative_dc % outj ( i ) sigmaj ( i ) = zero if ( abs ( afld ( i )). gt . eps ) then sigmaj ( i ) = ( positive_dc % ohj ( i ) + negative_dc % ohj ( i )) / afld ( i ) end if !!!!       write(*,*) i,outj(i) end do rc_result = DrivenCurrentResult ( positive_dc , negative_dc ) call rc_result % print ( time ) call rc_result % save ( time ) call fokkerplanck_compute ( time , TAU ) end subroutine lhcurrent ( driven_current , ispectr ) !subroutine lhcurrent(outj,ohj,cuj,cujoh,inpt,ispectr) !!      implicit real*8 (a-h,o-z) use plasma , only : rh , rh1 , fn1 , fn2 , fvt , sk use lock_module use maxwell use rt_parameters , only : nr , inew use driven_current_module implicit none type ( DrivenCurrent ), intent ( inout ) :: driven_current integer , intent ( in ) :: ispectr !real*8 outj(*),ohj(*), real * 8 cuj , cujoh , curs , curs0 , curdir real * 8 currn , vt0 , ccur , cfull , cfull0 real * 8 r , pn , fnr , fnrr , vt , vto !,rh1 integer klo , khi , ierr , nrr , i , j , inpt , ismthout !common /a0ab/ nr !real*8 y2dn,y2tm,y2tmi !common /a0l3/ y2dn(501),y2tm(501),y2tmi(501) !integer inew !common /cnew/ inew !est !sav2008 real * 8 zv1 , zv2 , fout common / plosh / zv1 ( 100 , 2 ), zv2 ( 100 , 2 ) !,sk(100) integer k !parameter(i0=1002) !real*8 vij,fij0,fij,dfij,dij,enorm,fst !common/lh/ vij(i0,100), fij0(i0,100,2), fij(i0,100,2), dfij(i0,100,2), dij(i0,100,2), enorm(100), fst(100) real * 8 , dimension (:), allocatable :: vj , fj , fj0 , cur , cur0 , currnt , rxx , wrk parameter ( ismthout = 1 ) inpt = driven_current % grid_size allocate ( vj ( i0 ), fj ( i0 ), fj0 ( i0 ), cur ( nr ), cur0 ( nr ), currnt ( nr + 2 ), rxx ( nr + 2 ), wrk ( nr + 2 )) !--------------------------------------------------- ! initial constants !--------------------------------------------------- !pqe=4.803e-10 vt0 = fvt ( zero ) ccur = pqe * vt0 * 0.333d-9 curdir =- dble ( ispectr ) cfull = zero cfull0 = zero k = ( 3 - ispectr ) / 2 do j = 1 , nr do i = 1 , i0 vj ( i ) = vij ( i , j ) !Vpar/Vt fj0 ( i ) = fij0 ( i , j , k ) fj ( i ) = fij ( i , j , k ) - fij0 ( i , j , k ) end do r = dble ( j ) / dble ( nr + 1 ) if ( inew . eq . 0 ) then !vardens pn = fn1 ( r , fnr ) else pn = fn2 ( r , fnr , fnrr ) end if vt = fvt ( r ) vto = vt / vt0 curs = currlhcd ( vj , fj ) cur ( j ) = curs * pn * ccur * curdir * vto !Ampere/cm2 cfull = cfull + cur ( j ) * sk ( j ) curs0 = currlhcd ( vj , fj0 ) cur0 ( j ) = curs0 * pn * ccur * curdir * vto !Ampere/cm2 cfull0 = cfull0 + cur0 ( j ) * sk ( j ) end do !cuj=cfull*1d-6   !driven current, MA driven_current % cu = cfull * 1 d - 6 !cujoh=cfull0*1d-6   !driven current, MA driven_current % cu0 = cfull0 * 1 d - 6 !!      write(*,*) !!      write(*,*)'ccur',ccur,' curdir=',curdir,' nr=',nr !!      write(*,*)'cu_out, MA=',cu_out,' cfull, A=',cfull !!           close(111) !      pause currn = cur ( 1 ) ! Jstoped, A/cm&#94;2 currnt ( 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 rxx ( 1 ) = zero do j = 1 , nr rxx ( j + 1 ) = dble ( j ) / dble ( nr + 1 ) currn = cur ( j ) ! Jstopped, A/cm&#94;2 currnt ( j + 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 end do nrr = nr + 2 rxx ( nrr ) = 1.d0 currnt ( nr + 2 ) = zero if ( ismthout . ne . 0 ) then do i = 1 , nrr wrk ( i ) = currnt ( i ) end do call fsmoth4 ( rxx , wrk , nrr , currnt ) end if rh ( 1 ) = rh1 if ( rh ( inpt ). gt . 1 d0 ) rh ( inpt ) = 1.d0 do j = 1 , inpt call lock2 ( rxx , nrr , rh ( j ), klo , khi , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) 'lock2 error in current profile for ASTRA' write ( * , * ) 'ierr=' , ierr , ' j=' , j , ' rh(j)=' , rh ( j ) write ( * , * ) 'rxx(1)=' , rxx ( 1 ), ' rxx(nrr)=' , rxx ( nrr ) pause end if call linf ( rxx , currnt , rh ( j ), fout , klo , khi ) driven_current % outj ( j ) = fout end do rh ( 1 ) = zero !------------------------------------------------------ currn = cur0 ( 1 ) ! Jstoped, A/cm&#94;2 currnt ( 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 rxx ( 1 ) = zero do j = 1 , nr rxx ( j + 1 ) = dble ( j ) / dble ( nr + 1 ) currn = cur0 ( j ) ! Jstopped, A/cm&#94;2 currnt ( j + 1 ) = currn * 1.d-2 ! Jstoped, MA/m&#94;2 end do nrr = nr + 2 rxx ( nrr ) = 1.d0 currnt ( nr + 2 ) = zero if ( ismthout . ne . 0 ) then do i = 1 , nrr wrk ( i ) = currnt ( i ) end do call fsmoth4 ( rxx , wrk , nrr , currnt ) end if rh ( 1 ) = rh1 if ( rh ( inpt ). gt . 1 d0 ) rh ( inpt ) = 1.d0 do j = 1 , inpt call lock2 ( rxx , nrr , rh ( j ), klo , khi , ierr ) if ( ierr . ne . 0 ) then write ( * , * ) '#2 lock2 error in current profile for ASTRA' write ( * , * ) 'ierr=' , ierr , ' j=' , j , ' rh(j)=' , rh ( j ) write ( * , * ) 'rxx(1)=' , rxx ( 1 ), ' rxx(nrr)=' , rxx ( nrr ) pause end if call linf ( rxx , currnt , rh ( j ), fout , klo , khi ) driven_current % ohj ( j ) = fout end do rh ( 1 ) = zero deallocate ( vj , fj , fj0 , cur , cur0 , currnt , rxx , wrk ) end","tags":"","loc":"sourcefile\\drivencurrent95.f90.html"}]}